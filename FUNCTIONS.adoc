= Bashmatic Functions Index
:allow-uri-read:
:doctype: book
:sectnums:
:showtitle:
:toc:
:toclevels: 5

== Bashmatic Modules

* xref:#module-7z[7z]
* xref:#module-array[array]
* xref:#module-audio[audio]
* xref:#module-aws[aws]
* xref:#module-bashmatic[bashmatic]
* xref:#module-brew[brew]
* xref:#module-caller[caller]
* xref:#module-color[color]
* xref:#module-db[db]
* xref:#module-db_rails[db_rails]
* xref:#module-db_top[db_top]
* xref:#module-deploy[deploy]
* xref:#module-dir[dir]
* xref:#module-docker[docker]
* xref:#module-file[file]
* xref:#module-ftrace[ftrace]
* xref:#module-gem[gem]
* xref:#module-git[git]
* xref:#module-github[github]
* xref:#module-jemalloc[jemalloc]
* xref:#module-json[json]
* xref:#module-maths[maths]
* xref:#module-net[net]
* xref:#module-osx[osx]
* xref:#module-output[output]
* xref:#module-pdf[pdf]
* xref:#module-pids[pids]
* xref:#module-pipe[pipe]
* xref:#module-progress-bar[progress-bar]
* xref:#module-repositories[repositories]
* xref:#module-ruby[ruby]
* xref:#module-run[run]
* xref:#module-runtime[runtime]
* xref:#module-runtime-config[runtime-config]
* xref:#module-set[set]
* xref:#module-settings[settings]
* xref:#module-shell-set[shell-set]
* xref:#module-ssh[ssh]
* xref:#module-subshell[subshell]
* xref:#module-sym[sym]
* xref:#module-text[text]
* xref:#module-time[time]
* xref:#module-trap[trap]
* xref:#module-url[url]
* xref:#module-usage[usage]
* xref:#module-user[user]
* xref:#module-util[util]
* xref:#module-vim[vim]
* xref:#module-yaml[yaml]

== List of Bashmatic Functions


=== Module `7z`

==== `7z.a`

[source,bash]
----
7z.a () 
{ 
    7z.zip "$@"
}

----

==== `7z.install`

[source,bash]
----
7z.install () 
{ 
    [[ -n $(which 7z) ]] || run "brew install p7zip"
    [[ -n $(which 7z) ]] || { 
        error "7z is not found after installation"
        return 1
    }
    return 0
}

----

==== `7z.unzip`

[source,bash]
----
7z.unzip () 
{ 
    7z.install
    local archive="$1"
    [[ -f ${archive} ]] || archive="${archive}.tar.7z"
    [[ -f ${archive} ]] || { 
        error "Neither $1 nor ${archive} were found."
        return 1
    }
    info "Unpacking archive ${txtylw}${archive}$(txt-info), total of $(file.size ${archive}) bytes."
    run.set-next show-output-on
    run "7za x -so ${archive} | tar xfv -"
}

----

==== `7z.x`

[source,bash]
----
7z.x () 
{ 
    7z.unzip "$@"
}

----

==== `7z.zip`

[source,bash]
----
7z.zip () 
{ 
    local folder="$1"
    shift
    7z.install
    local archive="${folder}"
    [[ -f "${folder}" || -d "${folder}" ]] && archive="$(basename ${folder} | sedx 's/\./-/g').tar.7z"
    [[ -f ${archive} ]] && { 
        run.set-next on-decline-return
        run.ui.ask "File ${archive} already exists. Press Y to remove it and continue." || return 1
        run "rm -f ${archive}"
    }
    local -a flags=
    local -a args=
    for arg in $@
    do
        if [[ ${arg:0:1} == "-" ]]; then
            flags=(${flags[@]} "${arg}")
        else
            args=(${args[@]} "${arg}")
        fi
    done
    printf "${bldgrn}"
    printf "${args[*]}\n"
    printf "${bldylw}"
    set +e
    local command="tar cf - ${folder} ${args[*]} | 7za a ${flags[*]} -si -bd ${archive}"
    run.print-command "${command}"
    eval "${command}"
    local code=$?
    printf "${clr}"
    if [[ ${code} -eq 0 ]]; then
        success "${archive} created."
    else
        error "Tar/7z Exited with code ${code}"
        return 1
    fi
}

----


=== Module `array`

==== `array.eval.in-groups-of`

[source,bash]
----
array.eval.in-groups-of () 
{ 
    local chunk="$1"
    shift
    local function="$1"
    shift
    local -a group
    for item in "$@"
    do
        index="$(( index + 1 ))"
        if [[ ${#group[@]} -eq ${chunk} ]]; then
            ${function} "${group[@]}"
            group=("${item}")
        else
            group=("${group[@]}" "${item}")
        fi
    done
    if [[ ${#group[@]} -gt 0 ]]; then
        ${function} "${group[@]}"
    fi
    return 0
}

----

==== `array.from.stdin`

[source,bash]
----
array.from.stdin () 
{ 
    local array_name=$1
    shift
    local script="while IFS='' read -r line; do ${array_name}+=(\"\$line\"); done < <($*)"
    eval "${script}"
}

----

==== `array.has-element`

[source,bash]
----
array.has-element () 
{ 
    local search="$1"
    shift
    local r="false"
    local e
    [[ "$*" =~ ${search} ]] || { 
        echo -n $r
        return 1
    }
    for e in "${@}"
    do
        [[ "$e" == "${search}" ]] && r="true"
    done
    echo -n $r
    [[ $r == "false" ]] && return 1
    return 0
}

----

==== `array.includes`

[source,bash]
----
array.includes () 
{ 
    local search="$1"
    shift
    [[ "$*" =~ ${search} ]] || return 1
    for e in "${@}"
    do
        [[ "$e" == "${search}" ]] && { 
            return 0
        }
    done
    return 1
}

----

==== `array.includes-or-complain`

[source,bash]
----
array.includes-or-complain () 
{ 
    array.includes "$@" || { 
        element="$1"
        shift
        local -a output=()
        while true; do
            [[ -z "$1" ]] && break
            if [[ "$1" =~ " " ]]; then
                output=("${output[@]}" "$1")
            else
                output=("$1")
            fi
            shift
        done
        if [[ ${#output[@]} -gt 10 ]]; then
            error "Value ${element} must be one of the supplied values."
        else
            error "Value ${element} must be one of the supplied values:" "${output[@:0:10]}"
        fi
        echo
        return 0
    }
    return 1
}

----

==== `array.includes-or-exit`

[source,bash]
----
array.includes-or-exit () 
{ 
    array.includes-or-complain "$@" || exit 1
}

----

==== `array.join`

[source,bash]
----
array.join () 
{ 
    local sep="$1"
    shift
    local lines="$1"
    if [[ ${lines} == true || ${lines} == false ]]; then
        shift
    else
        lines=false
    fi
    local elem
    local len="$#"
    local last_index=$(( len - 1 ))
    local index=0
    for elem in "$@"
    do
        if ${lines}; then
            printf "${sep}%s\n" "${elem}"
        else
            printf "%s" "${elem}"
            [[ ${index} -lt ${last_index} ]] && printf '%s' "${sep}"
        fi
        index=$(( index + 1 ))
    done
}

----

==== `array.sort`

[source,bash]
----
array.sort () 
{ 
    local IFS_previous="${IFS}"
    export IFS=''
    printf "%s\n" "$@" | sort | tr '\n' ' ' | sed 's/ $//g'
    IFS="${IFS_previous}"
}

----

==== `array.sort-numeric`

[source,bash]
----
array.sort-numeric () 
{ 
    local IFS_previous="${IFS}"
    export IFS=''
    printf "%s\n" "$@" | sort -n | tr '\n' ' ' | sed 's/ $//g'
    IFS="${IFS_previous}"
}

----

==== `array.to.bullet-list`

[source,bash]
----
array.to.bullet-list () 
{ 
    array.join ' • ' true "$@"
}

----

==== `array.to.csv`

[source,bash]
----
array.to.csv () 
{ 
    array.join ', ' false "$@"
}

----

==== `array.to.piped-list`

[source,bash]
----
array.to.piped-list () 
{ 
    array.join ' | ' false "$@"
}

----

==== `array.uniq`

[source,bash]
----
array.uniq () 
{ 
    local IFS_previous="${IFS}"
    IFS=''
    printf "%s\n" "$@" | sort -u | tr '\n' ' ' | sed 's/ $//g'
    IFS="${IFS_previous}"
}

----


=== Module `audio`

==== `audio.dir.mp3-to-wav`

[source,bash]
----
audio.dir.mp3-to-wav () 
{ 
    local from="$1"
    local to="$2"
    run "cd \"${from}\""
    trap "return 1" INT
    while read -d '' filename; do
        audio.file.mp3-to-wav "${filename}" "${to}" < /dev/null
    done < <(find . -type f -name "*.mp3" -print0)
    run "cd -"
}

----

==== `audio.file.frequency`

[source,bash]
----
audio.file.frequency () 
{ 
    local file="$1"
    [[ -z $(command -V mdls) ]] && return 1
    local frequency=$(mdls "${file}" | grep kMDItemAudioSampleRate | sed 's/.*= //g')
    [[ -z ${frequency} ]] && frequency=48000
    local kHz=$(maths.eval "${frequency} / 1000.0" 0)
    printf ${kHz}
}

----

==== `audio.file.mp3-to-wav`

[source,bash]
----
audio.file.mp3-to-wav () 
{ 
    local from="${1/.\//}"
    local destination="$2"
    if [[ -z ${destination} ]]; then
        destination="$(dirname "${from}")"
    else
        destination="${destination}/$(dirname "${from}")"
    fi
    local to="${destination}/$(basename "${from/.mp3/.wav}")"
    if [[ ${from} =~ ".mp3" ]]; then
        h.blue "Source:      ${from}"
        cursor.up 1
        h.green "Destination: ${to}"
        [[ -f "${to}" ]] && { 
            info: "File already converted."
            return 0
        }
        run "mkdir -p \"${destination}\""
        run.set-next show-output-on
        run "lame --decode \"${from}\" \"${to}\""
    else
        error "File ${from} is not an MP3 file."
        return 1
    fi
}

----

==== `audio.make.mp3`

[source,bash]
----
audio.make.mp3 () 
{ 
    local file="$1"
    shift
    local nfile="$2"
    shift
    set +e
    [[ -n "$(command -V lame)" ]] || brew.package.install lame
    local default_options=" -m s -b 320 "
    [[ -n "${file}" ]] || { 
        audio.make.mp3.usage && return 1
    }
    [[ -s "${file}" ]] || { 
        error "File '${file}' does not exist."
        audio.make.mp3.usage && return 2
    }
    [[ -z ${nfile} ]] && nfile="$(echo "${file}" | sedx 's/\.(wav|aiff?)$/\.mp3/g')"
    local khz=$(audio.file.frequency "${file}")
    h2 "'$(basename "${file}")' —❯ ${txtylw}${nfile}${txtgrn}, sample rate: ${khz:-'Unknown'}kHz"
    info "lame ${default_options} $* '${file}' '${nfile}'"
    run.set-next show-output-on abort-on-error
    run "lame ${default_options}  $* '${file}' '${nfile}'"
    hr
    success "MP3 file ${nfile} is $(file.size.mb "${nfile}")Mb"
}

----

==== `audio.make.mp3.usage`

[source,bash]
----
audio.make.mp3.usage () 
{ 
    usage-box "audio.wav-to-mp3 [ file.wav | file.aif | file.aiff ] [ file.mp3 ] © Convert a RAW PCM Audio to highest quality MP3" "You can pass additional flags to ${txtylw}lame" "" "Just run ${txtylw}lame --longhelp for more info." "" "Default Flags: ${default_options}" ""
}

----

==== `audio.make.mp3s`

[source,bash]
----
audio.make.mp3s () 
{ 
    local dir="${1:-"."}"
    local kHz="${2:-"48"}"
    local first="$(find "${dir}" -type f -a \( -name "*.aif*" -o -name "*.wav" \) -print | head -1)"
    h3 "Converting WAV and AIF files to MP3 in ${txtylw}${dir}."
    if [[ -z ${first} ]]; then
        error "No AIFF or WAV files in the folder ${bldgrn}${dir}"
        return 1
    fi
    inf "Determining audio sampling rate (will apply the same rate to all files)... "
    kHz=$(audio.file.frequency "${first}")
    printf "${bldgrn} — ${kHz}kHz"
    ok:
    SAVEIFS=$IFS
    run.set-all show-command-on show-output-off abort-on-error
    find "${dir}" -type f -a \( -name "*.aif*" -o -name "*.wav" \) -print0 | while read -d '' file; do
        local fn=$(ascii-clean "${file}")
        mp3=$(echo "${file}" | sedx 's/\.(wav|aiff?)$/.mp3/g')
        inf "checking ${txtylw}${file} $(txt-info) ... "
        if [[ -f "${mp3}" && -z "${FORCE}" ]]; then
            printf "${bldgrn} OK, already converted. Use FORCE=1 to overwrite. ${clr}"
            ok:
            continue
        fi
        printf "${txtcyn} Transcoding...${clr}"
        ui.closer.kind-of-ok:
        inf "❯ ${txtylw}lame --silent -m s -b 320  \"${file}\""
        trap _term SIGINT
        lame --silent -m s -b 320 "${fn}" & child_pid=$!
        wait "$child_pid"
        code=$?
        if [[ ${code} -ne 0 ]]; then
            ui.closer.not-ok:
            info "${bakred}${bldwht}  ERROR: lame exited with an error code ${code}. Aborting!  "
            [[ -f "${mp3}" ]] && { 
                info "NOTE: removing unfinished MP3 file ${mp3}."
                rm -f "${mp3}" 1>&2 > /dev/null
            }
            break
        else
            ok:
        fi
    done
    success 'All done.'
}

----


=== Module `aws`

==== `aws.ec2`

[source,bash]
----
aws.ec2 () 
{ 
    local cmd="$1"
    local command="$cmd"
    case $command in 
        list | show | ls)
            __utf_table "$(aws ec2 describe-instances --query 'Reservations[*].Instances[*].{name: Name, instance_id: InstanceId, ip_address: PrivateIpAddress, state: State.Name}' --output table 2>/dev/null)"
            return $?
        ;
        *)
            error "Invalid Command: ${cmd}"
            return 1
        ;
    esac
}

----

==== `aws.rds.hostname`

[source,bash]
----
aws.rds.hostname () 
{ 
    local name=${1}
    [[ -z $(which jq) ]] && out=$(brew.install.package jq 2>/dev/null 1>/dev/null)
    [[ -z $(which aws) ]] && out=$(brew.install.package awscli 2>/dev/null 1>/dev/null)
    [[ -n ${name} ]] && aws rds describe-db-instances | jq '.[][].Endpoint.Address' | sedx 's/"//g' | ${GrepCommand} "^${name}\."
    [[ -z ${name} ]] && aws rds describe-db-instances | jq '.[][].Endpoint.Address' | sedx 's/"//g'
}

----

==== `aws.s3.upload`

[source,bash]
----
aws.s3.upload () 
{ 
    local pathname="$1"
    shift
    local skip_file_modification="$1"
    [[ -n ${skip_file_modification} ]] && skip_file_modification=true
    [[ -z ${skip_file_modification} ]] && skip_file_modification=false
    if [[ -z "${LibAws__DefaultUploadBucket}" || -z "${LibAws__DefaultUploadFolder}" ]]; then
        error "Required AWS S3 configuration is not defined." "Please set variables: ${bldylw}LibAws__DefaultUploadFolder" "and ${bldylw}LibAws__DefaultUploadBucket" "before using this function."
        return 1
    fi
    if [[ ! -f "${pathname}" ]]; then
        error "Local file was not found: ${bldylw}${pathname}"
        return 1
    fi
    local file=$(basename "${pathname}")
    local remote_file="${file}"
    local year=$(file.last-modified-year "${pathname}")
    local date=$(file.last-modified-date "${pathname}")
    [[ -z ${year} ]] && year=$(date +'%Y')
    [[ -z ${date} ]] && date=$(today)
    ${skip_file_modification} || { 
        [[ "${remote_file}" =~ "${date}" ]] && remote_file=$(echo "${remote_file}" | sedx "s/[_\.-]?${date}[_\.-]//g")
        [[ "${remote_file}" =~ "${date}" ]] || remote_file="${date}.${remote_file}"
    }
    remote_file=$(echo "${remote_file}" | sed -E 's/ /-/g;s/--+/-/g' | tr '[A-Z]' '[a-z]')
    local remote="s3://${LibAws__DefaultUploadBucket}/${LibAws__DefaultUploadFolder}/${year}/${remote_file}"
    run "aws s3 cp \"${pathname}\" \"${remote}\""
    if [[ ${LibRun__LastExitCode} -eq 0 ]]; then
        local remoteUrl="https://s3-${LibAws__DefaultRegion}.amazonaws.com/${LibAws__DefaultUploadBucket}/${LibAws__DefaultUploadFolder}/${year}/${remote_file}"
        [[ -n "${LibAws__ObjectUrlFile}" ]] && echo ${remoteUrl} > "${LibAws__ObjectUrlFile}"
        echo
        info "NOTE: You should now be able to access your resource at the following URL:"
        hr
        info "${bldylw}${remoteUrl}"
        hr
    else
        error "AWS S3 upload failed with code ${LibRun__LastExitCode}"
    fi
    return ${LibRun__LastExitCode}
}

----


=== Module `bashmatic`

==== `bashmatic.bash.exit-unless-version-four-or-later`

[source,bash]
----
bashmatic.bash.exit-unless-version-four-or-later () 
{ 
    bashmatic.bash.version-four-or-later || { 
        error "Sorry, this functionality requires BASH version 4 or later."
        exit 1 > /dev/null
    }
}

----

==== `bashmatic.bash.version`

[source,bash]
----
bashmatic.bash.version () 
{ 
    echo "${BASH_VERSION}" | cut -d '.' -f 1
}

----

==== `bashmatic.bash.version-four-or-later`

[source,bash]
----
bashmatic.bash.version-four-or-later () 
{ 
    [[ $(bashmatic.bash.version) -gt 3 ]]
}

----

==== `bashmatic.cache.add-file`

[source,bash]
----
bashmatic.cache.add-file () 
{ 
    bashmatic.bash.version-four-or-later || return 1
    [[ -n "${1}" ]] && BashMatic__LoadCache[${1}]=true
}

----

==== `bashmatic.cache.has-file`

[source,bash]
----
bashmatic.cache.has-file () 
{ 
    local file="$1"
    bashmatic.bash.version-four-or-later || return 1
    test -z "$file" && return 1
    if [[ -n "$1" && -n "${BashMatic__LoadCache["${file}"]}" ]]; then
        return 0
    else
        return 1
    fi
}

----

==== `bashmatic.cache.list`

[source,bash]
----
bashmatic.cache.list () 
{ 
    bashmatic.bash.version-four-or-later || return 1
    for f in "${!BashMatic__LoadCache[@]}"
    do
        echo $f
    done
}

----

==== `bashmatic.functions`

[source,bash]
----
bashmatic.functions () 
{ 
    bashmatic.functions-from '*.sh' "$@"
}

----

==== `bashmatic.functions-from`

[source,bash]
----
bashmatic.functions-from () 
{ 
    local pattern="${1}"
    [[ -n ${pattern} ]] && shift
    [[ -z ${pattern} ]] && pattern="[a-z]*.sh"
    cd "${BASHMATIC_HOME}" > /dev/null || return 1
    export SCREEN_WIDTH=$(screen-width)
    if [[ ! ${pattern} =~ "*" && ! ${pattern} =~ ".sh" ]]; then
        pattern="${pattern}.sh"
    fi
    ${GrepCommand} '^[_a-zA-Z0-9]+.*\(\)' lib/${pattern} | sedx 's/^lib\/.*\.sh://g' | sedx 's/^function //g' | sedx 's/\(\) *\{.*$//g' | tr -d '()' | sedx '/^ *$/d' | ${GrepCommand} '^_' -v | sort | uniq | columnize "$@"
    cd - > /dev/null || return 1
}

----

==== `bashmatic.functions.output`

[source,bash]
----
bashmatic.functions.output () 
{ 
    bashmatic.functions-from 'output.sh' "$@"
}

----

==== `bashmatic.functions.runtime`

[source,bash]
----
bashmatic.functions.runtime () 
{ 
    bashmatic.functions-from 'run*.sh' "$@"
}

----

==== `bashmatic.load-at-login`

[source,bash]
----
bashmatic.load-at-login () 
{ 
    local init_file="${1}"
    local -a init_files=(~/.bashrc ~/.bash_profile ~/.profile)
    [[ -n "${init_file}" && -f "${init_file}" ]] && init_files=("${init_file}")
    for file in "${init_files[@]}"
    do
        if [[ -f "${file}" ]]; then
            grep -q bashmatic "${file}" && { 
                success "BashMatic is already loaded from ${bldblu}${file}"
                return 0
            }
            grep -q bashmatic "${file}" || { 
                h2 "Adding BashMatic auto-loader to ${bldgrn}${file}..."
                echo "source ${BASHMATIC_HOME}/init.sh" >> "${file}"
            }
            source "${file}"
            break
        fi
    done
}

----

==== `bashmatic.reload`

[source,bash]
----
bashmatic.reload () 
{ 
    source "${BASHMATIC_INIT}"
}

----

==== `bashmatic.setup`

[source,bash]
----
bashmatic.setup () 
{ 
    [[ -z ${BashMatic__Downloader} && -n $(command -v curl) ]] && export BashMatic__Downloader="curl -fsSL --connect-timeout 5 "
    [[ -z ${BashMatic__Downloader} && -n $(command -v wget) ]] && export BashMatic__Downloader="wget -q -O --connect-timeout=5 - "
    if [[ ! -d "${BASHMATIC_LIBDIR}" ]]; then
        printf "\e[1;31mUnable to establish BashMatic's library source folder.\e[0m\n"
        return 1
    fi
    bashmatic.source util.sh git.sh file.sh color.sh
    bashmatic.source-dir "${BASHMATIC_LIBDIR}"
    [[ -d ${BASHMATIC_HOME}/.git ]] && bashmatic.auto-update
}

----

==== `bashmatic.source`

[source,bash]
----
bashmatic.source () 
{ 
    local path="${BASHMATIC_LIBDIR}"
    for file in "${@}"
    do
        [[ "${file}" =~ "/" ]] || file="${path}/${file}"
        [[ -s "${file}" ]] || { 
            echo "Can't source file ${file} — fils is invalid."
            return 1
        }
        if ! bashmatic.cache.has-file "${file}"; then
            [[ -n ${DEBUG} ]] && printf "${txtcyn}[source] ${bldylw}${file}${clr}...\n" 1>&2
            set +e
            source "${file}"
            bashmatic.cache.add-file "${file}"
        else
            [[ -n ${DEBUG} ]] && printf "${txtgrn}[cached] ${bldblu}${file}${clr} \n" 1>&2
        fi
    done
    return 0
}

----

==== `bashmatic.source-dir`

[source,bash]
----
bashmatic.source-dir () 
{ 
    local folder="${1}"
    local loaded=false
    local file
    unset files
    declare -a files
    eval "$(files.map.shell-scripts "${folder}" files)"
    if [[ ${#files[@]} -eq 0 ]]; then
        .err "No files were returned from files.map in " "\n  ${bldylw}${folder}"
        return 1
    fi
    for file in "${files[@]}"
    do
        bashmatic.source "${file}" && loaded=true
    done
    unset files
    ${loaded} || { 
        .err "Unable to find BashMatic library folder with files:" "${BASHMATIC_LIBDIR}"
        return 1
    }
    if [[ ${LoadedShown} -eq 0 ]]; then
        hr
        success "BashMatic was loaded! Happy Bashing :) "
        hr
        export LoadedShown=1
    fi
}

----

==== `bashmatic.version`

[source,bash]
----
bashmatic.version () 
{ 
    cat $(dirname "${BASHMATIC_INIT}")/.version
}

----


=== Module `brew`

==== `brew.cache-reset`

[source,bash]
----
brew.cache-reset () 
{ 
    rm -f "${LibBrew__PackageCacheList}" "${LibBrew__CaskCacheList}"
}

----

==== `brew.cache-reset.delayed`

[source,bash]
----
brew.cache-reset.delayed () 
{ 
    ( "${BASH_IN_SUBSHELL}" ) || brew.cache-reset
}

----

==== `brew.cask.is-installed`

[source,bash]
----
brew.cask.is-installed () 
{ 
    local cask="${1}"
    local -a installed_casks=($(brew.cask.list))
    array.has-element ${cask} "${installed_casks[@]}"
}

----

==== `brew.cask.list`

[source,bash]
----
brew.cask.list () 
{ 
    cache-or-command ${LibBrew__CaskCacheList} 30 brew cask ls -1
}

----

==== `brew.cask.tap`

[source,bash]
----
brew.cask.tap () 
{ 
    run "brew tap homebrew/cask-cask"
}

----

==== `brew.install`

[source,bash]
----
brew.install () 
{ 
    local brew=$(which brew 2>/dev/null)
    if [[ -z "${brew}" ]]; then
        info "Installing Homebrew, please wait..."
        /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
    else
        info "Detected Homebrew Version: ${bldylw}$(brew --version 2>/dev/null | head -1)"
    fi
}

----

==== `brew.install.cask`

[source,bash]
----
brew.install.cask () 
{ 
    local cask=$1
    local force=
    local verbose=
    [[ -n "${opts_force}" ]] && force="--force"
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    inf "verifying brew cask ${bldylw}{cask}"
    if [[ -n "$(ls -al /Applications/*.app | grep -i ${cask})" && -z "${opts_force}" ]]; then
        ui.closer.ok:
    else
        if [[ $(brew.cask.is-installed ${cask}) == "true" ]]; then
            ui.closer.ok:
            return 0
        else
            ui.closer.kind-of-ok:
            run "brew cask install"${cask}"${force} ${verbose}"
        fi
    fi
    brew.cache-reset.delayed
}

----

==== `brew.install.package`

[source,bash]
----
brew.install.package () 
{ 
    local package="$1"
    local force=
    local verbose=
    [[ -n "${opts_force}" ]] && force="--force"
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    [[ -z "${opt_terse}" ]] && inf "checking for 🍻 ${bldylw}${package}..."
    local code
    if [[ "$(brew.package.is-installed "${package}")" == "true" ]]; then
        [[ -z "${opt_terse}" ]] && ok:
        [[ -z "${opt_terse}" ]] || printf "${bldgrn}○ "
        export LibRun__LastExitCode=0
    else
        if [[ -z "${opt_terse}" ]]; then
            hl.subtle "Brew is installing package: ${package}"
            run "brew install ${package} ${force} ${verbose}"
            code=${LibRun__LastExitCode}
        else
            brew install "${package}" ${force} ${verbose} > /dev/null 2>&1
            code=$?
        fi
        run "brew link ${package} --overwrite ${force} ${verbose}"
        run "hash -r"
        [[ "${code}" -eq 0 ]] || { 
            warning "Reinstalling ${package} as I couldn't find it after instal..."
            brew.reinstall.package "${package}"
        }
        export LibRun__LastExitCode=0
        if [[ "$(brew.package.is-installed ${package})" == "true" ]]; then
            [[ -n "${opt_terse}" ]] && printf "\n 🟢 "
        else
            [[ -n "${opt_terse}" ]] && printf "\n 🔴 "
            export LibRun__LastExitCode=1
        fi
    fi
    set +x
    return ${LibRun__LastExitCode}
}

----

==== `brew.install.packages`

[source,bash]
----
brew.install.packages () 
{ 
    local force=
    [[ -n "${opts_force}" ]] && force="--force"
    for package in "$@"
    do
        brew.install.package "${package}"
    done
}

----

==== `brew.package.available-versions`

[source,bash]
----
brew.package.available-versions () 
{ 
    local package="$1"
    brew search "${package}@" | tr -d 'a-z@A-Z =>-+' | sed '/^$/d' | sort -nr | tr '\n' ' '
}

----

==== `brew.package.is-installed`

[source,bash]
----
brew.package.is-installed () 
{ 
    local package="${1}"
    local -a installed_packages=($(brew.package.list))
    array.has-element "${package}" "${installed_packages[@]}"
}

----

==== `brew.package.link`

[source,bash]
----
brew.package.link () 
{ 
    local package="${1}"
    shift
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    run "brew link"${verbose}"${package} $*"
}

----

==== `brew.package.list`

[source,bash]
----
brew.package.list () 
{ 
    cache-or-command ${LibBrew__PackageCacheList} 30 brew ls -1
}

----

==== `brew.reinstall.package`

[source,bash]
----
brew.reinstall.package () 
{ 
    local package="${1}"
    local force=
    local verbose=
    [[ -n "${opts_force}" ]] && force="--force"
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    run "brew unlink    ${package} ${force} ${verbose}"
    run "brew uninstall ${package} ${force} ${verbose}"
    brew.install.package "${package}"
}

----

==== `brew.reinstall.packages`

[source,bash]
----
brew.reinstall.packages () 
{ 
    local force=
    local result=0
    [[ -n "${opts_force}" ]] && force="--force"
    for package in "$@"
    do
        brew.uninstall.package "${package}"
        brew.install.package "${package}"
        local result=$?
    done
    return ${result}
}

----

==== `brew.relink`

[source,bash]
----
brew.relink () 
{ 
    local package"${1}"
    local verbose=
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    run "brew link ${verbose} ${package} --overwrite"
}

----

==== `brew.service.down`

[source,bash]
----
brew.service.down () 
{ 
    local svc="$1"
    run "brew services stop ${svc}"
}

----

==== `brew.service.restart`

[source,bash]
----
brew.service.restart () 
{ 
    local svc="$1"
    run "brew services restart ${svc}"
}

----

==== `brew.service.up`

[source,bash]
----
brew.service.up () 
{ 
    local svc="$1"
    run "brew services start ${svc}"
}

----

==== `brew.setup`

[source,bash]
----
brew.setup () 
{ 
    brew.upgrade
}

----

==== `brew.uninstall.package`

[source,bash]
----
brew.uninstall.package () 
{ 
    local package=$1
    local force=
    local verbose=
    [[ -n "${opts_force}" ]] && force="--force"
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    run.set-next continue-on-error
    run "brew unlink ${package} ${force} ${verbose}"
    run.set-next continue-on-error
    run "brew uninstall ${package} ${force} ${verbose}"
    brew.cache-reset.delayed
}

----

==== `brew.uninstall.packages`

[source,bash]
----
brew.uninstall.packages () 
{ 
    local force=
    [[ -n "${opts_force}" ]] && force="--force"
    for package in $@
    do
        brew.uninstall.package "${package}"
    done
}

----

==== `brew.upgrade`

[source,bash]
----
brew.upgrade () 
{ 
    brew.install
    if [[ -z "$(which brew)" ]]; then
        warn "brew is not installed...."
        return 1
    fi
    run "brew update --force"
    run "brew upgrade"
    run "brew cleanup -s"
}

----

==== `brew.upgrade.packages`

[source,bash]
----
brew.upgrade.packages () 
{ 
    [[ -z "$(which brew)" ]] || brew.install
    [[ -z $1 ]] && { 
        error "usage: brew.upgrade.packages package1 package2 ..."
        return 1
    }
    run "brew upgrade $@"
}

----

==== `cache-or-command`

[source,bash]
----
cache-or-command () 
{ 
    local file="$1"
    shift
    local stale_minutes="$1"
    shift
    local command="$*"
    file.exists-and-newer-than "${file}""${stale_minutes}" && { 
        cat "${file}"
        return 0
    }
    cp /dev/null ${file} > /dev/null
    eval "${command}" | tee -a "${file}"
}

----


=== Module `caller`

==== `caller.stack`

[source,bash]
----
caller.stack () 
{ 
    local index=${1:-"-1"}
    while true; do
        index=$((index + 1))
        caller ${index} 2>&1 > /dev/null || break
        local -a frame=($(caller ${index} | tr ' ' '\n'))
        printf "%3d [ %-40.40s ]: %s\n" ${index} "${frame[2]}:${frame[0]}" "${frame[1]}"
    done
}

----

==== `stack.frame`

[source,bash]
----
stack.frame () 
{ 
    caller.stack 0
}

----


=== Module `color`

==== `ansi`

[source,bash]
----
ansi () 
{ 
    echo -e "\e[${1}m${*:2}\e[0m"
}

----

==== `bold`

[source,bash]
----
bold () 
{ 
    ansi 1 "$@"
}

----

==== `color.disable`

[source,bash]
----
color.disable () 
{ 
    export clr='\e[0m'
    unset txtblk
    unset txtred
    unset txtgrn
    unset txtylw
    unset txtblu
    unset txtpur
    unset txtcyn
    unset txtwht
    unset bldblk
    unset bldred
    unset bldgrn
    unset bldylw
    unset bldblu
    unset bldpur
    unset bldcyn
    unset bldwht
    unset unkblk
    unset undred
    unset undgrn
    unset undylw
    unset undblu
    unset undpur
    unset undcyn
    unset undwht
    unset bakblk
    unset bakred
    unset bakgrn
    unset bakylw
    unset bakblu
    unset bakpur
    unset bakcyn
    unset bakwht
    unset txtrst
    unset italic
    unset bold
    unset strikethrough
    unset underlined
    unset white_on_orange
    unset white_on_yellow
    unset white_on_red
    unset white_on_pink
    unset white_on_salmon
    unset yellow_on_gray
    export AppColorsLoaded=0
}

----

==== `color.enable`

[source,bash]
----
color.enable () 
{ 
    if [[ -n "${AppColorsLoaded}" && ${AppColorsLoaded} -ne 1 ]]; then
        export txtblk='\e[0;30m'
        export txtred='\e[0;31m'
        export txtgrn='\e[0;32m'
        export txtylw='\e[0;33m'
        export txtblu='\e[0;34m'
        export txtpur='\e[0;35m'
        export txtcyn='\e[0;36m'
        export txtwht='\e[0;37m'
        export bldblk='\e[1;30m'
        export bldred='\e[1;31m'
        export bldgrn='\e[1;32m'
        export bldylw='\e[1;33m'
        export bldblu='\e[1;34m'
        export bldpur='\e[1;35m'
        export bldcyn='\e[1;36m'
        export bldwht='\e[1;37m'
        export unkblk='\e[4;30m'
        export undred='\e[4;31m'
        export undgrn='\e[4;32m'
        export undylw='\e[4;33m'
        export undblu='\e[4;34m'
        export undpur='\e[4;35m'
        export undcyn='\e[4;36m'
        export undwht='\e[4;37m'
        export bakblk='\e[40m'
        export bakred='\e[41m'
        export bakgrn='\e[42m'
        export bakylw='\e[43m'
        export bakblu='\e[44m'
        export bakpur='\e[45m'
        export bakcyn='\e[46m'
        export bakwht='\e[47m'
        export txtrst='\e[0m'
        export rst='\e[0m'
        export clr='\e[0m'
        export bold='\e[1m'
        export italic='\e[3m'
        export underlined='\e[4m'
        export strikethrough='\e[9m'
        export white_on_orange="\e[48;5;208m"
        export white_on_yellow="\e[48;5;214m"
        export white_on_red="\e[48;5;9m"
        export white_on_pink="\e[48;5;199m"
        export white_on_salmon="\e[48;5;196m"
        export yellow_on_gray="\e[38;5;220m\e[48;5;242m"
        export AppColorsLoaded=1
    else
        [[ -n ${DEBUG} ]] && echo "colors already loaded..."
    fi
}

----

==== `error-text`

[source,bash]
----
error-text () 
{ 
    printf "${txtred}"
}

----

==== `italic`

[source,bash]
----
italic () 
{ 
    ansi 3 "$@"
}

----

==== `red`

[source,bash]
----
red () 
{ 
    ansi 31 "$@"
}

----

==== `reset-color`

[source,bash]
----
reset-color () 
{ 
    printf "${clr}\n"
}

----

==== `strikethrough`

[source,bash]
----
strikethrough () 
{ 
    ansi 9 "$@"
}

----

==== `txt-err`

[source,bash]
----
txt-err () 
{ 
    printf "${clr}${bldylw}${bakred}"
}

----

==== `txt-info`

[source,bash]
----
txt-info () 
{ 
    printf "${clr}${txtblu}"
}

----

==== `txt-warn`

[source,bash]
----
txt-warn () 
{ 
    printf "${clr}${bldylw}"
}

----

==== `underline`

[source,bash]
----
underline () 
{ 
    ansi 4 "$@"
}

----


=== Module `db`

==== `db.config.connections`

[source,bash]
----
db.config.connections () 
{ 
    [[ -f ${bashmatic_db_config} ]] || return 2
    cat "${bashmatic_db_config}" | ruby -e "require 'yaml'; h = YAML.load(STDIN); puts h.keys.join(\"\n\")"
}

----

==== `db.config.get-file`

[source,bash]
----
db.config.get-file () 
{ 
    echo "${bashmatic_db_config}"
}

----

==== `db.config.init`

[source,bash]
----
db.config.init () 
{ 
    export bashmatic_db_connection=(host database username password)
}

----

==== `db.config.parse`

[source,bash]
----
db.config.parse () 
{ 
    local db="$1"
    [[ -z ${db} ]] && return 1
    [[ -f ${bashmatic_db_config} ]] || return 2
    db.config.init
    local -a script=("require 'yaml'; h = YAML.load(STDIN); ")
    for field in "${bashmatic_db_connection[@]}"
    do
        script+=("h.key?('${db}') && h['${db}'].key?('${field}') ? print(h['${db}']['${field}']) : print('null'); print ' '; ")
    done
    cat "${bashmatic_db_config}" | ruby -e "${script[*]}"
}

----

==== `db.config.set-file`

[source,bash]
----
db.config.set-file () 
{ 
    [[ -s "$1" ]] || return 1
    export bashmatic_db_config="$1"
}

----

==== `db.connect`

[source,bash]
----
db.connect () 
{ 
    db.psql.connect "$@"
}

----

==== `db.datetime`

[source,bash]
----
db.datetime () 
{ 
    date '+%Y%m%d-%H%M%S'
}

----

==== `db.pg.local.num-procs`

[source,bash]
----
db.pg.local.num-procs () 
{ 
    /bin/ps -ef | /bin/grep "[p]ostgres" | wc -l | awk '{print $1}'
}

----

==== `db.psql.args`

[source,bash]
----
db.psql.args () 
{ 
    if [[ -z "${bashmatic_db_database}" || -z "${bashmatic_db_host}" ]]; then
        if [[ -n "$1" ]]; then
            db.psql.args.config "$1"
        else
            error "Unable to determine DB connection parameters"
            return 1
        fi
    else
        export PGPASSWORD="${bashmatic_db_password}"
        printf -- "-U ${bashmatic_db_username} -h ${bashmatic_db_host} ${bashmatic_db_database}"
    fi
}

----

==== `db.psql.args.config`

[source,bash]
----
db.psql.args.config () 
{ 
    local output="$(db.config.parse "$1")"
    local -a params
    [[ -z ${output} || "${output}" =~ "null" ]] && { 
        error "Database $1 is not defined." 1>&2
        return 1
    }
    params=($(db.config.parse "$1"))
    local dbhost
    local dbname
    local dbuser
    local dbpass
    dbhost=${params[0]}
    dbname=${params[1]}
    dbuser=${params[2]}
    dbpass=${params[3]}
    export PGPASSWORD="${dbpass}"
    printf -- "-U ${dbuser} -h ${dbhost} ${dbname}"
}

----

==== `db.psql.args.localhost`

[source,bash]
----
db.psql.args.localhost () 
{ 
    printf -- "-U postgres -h localhost $*"
}

----

==== `db.psql.args.maintenance`

[source,bash]
----
db.psql.args.maintenance () 
{ 
    db.psql.args.localhost "--maintenance-db=postgres $*"
}

----

==== `db.psql.connect`

[source,bash]
----
db.psql.connect () 
{ 
    local dbname="$1"
    if [[ -z ${dbname} ]]; then
        h1 "USAGE: db.connect connection-name" "WHERE: connection-name is defined by your ${bldylw}${bashmatic_db_config}${clr} file."
        return 0
    fi
    local tempfile=$(mktemp /tmp/.bashmatic.db.${RANDOM} || exit 1)
    db.psql.args.config "${dbname}" > "${tempfile}"
    local -a args=($(cat "${tempfile}"))
    rm -f "${tempfile}" > /dev/null
    printf "${txtpur}export PGPASSWORD=[reducted]${clr}\n"
    printf "${txtylw}$(which psql) ${args[*]}${clr}\n"
    hr
    psql "${args[@]}"
}

----

==== `db.psql.db-settings`

[source,bash]
----
db.psql.db-settings () 
{ 
    psql "$*" -X -q -c 'show all' | sort | awk '{ printf("%s=%s\n", $1, $3) }' | sed -E 's/[()\-]//g;/name=setting/d;/^[-+=]*$/d;/^[0-9]*=$/d'
}

----

==== `db.wait-until-db-online`

[source,bash]
----
db.wait-until-db-online () 
{ 
    local db="${1}"
    inf 'waiting for the database to come up...'
    while true; do
        out=$(psql -c "select count(*) from pg_stat_user_tables" "$(db.psql.args "${db}")" 2>&1)
        code=$?
        [[ ${code} == 0 ]] && break
        [[ ${code} == 1 ]] && break
        sleep 1
        [[ ${out} =~ 'does not exist' ]] && break
    done
    ui.closer.ok:
    return 0
}

----


=== Module `db_rails`

==== `db.rails.schema.checksum`

[source,bash]
----
db.rails.schema.checksum () 
{ 
    if [[ -d db/migrate ]]; then
        find db/migrate -type f -ls | awk '{printf("%10d-%s\n",$7,$11)}' | sort | shasum | awk '{print $1}'
    else
        local schema=$(db.rails.schema.file)
        [[ -s ${schema} ]] || error "can not find Rails schema in either ${RAILS_SCHEMA_RB} or ${RAILS_SCHEMA_SQL}"
        [[ -s ${schema} ]] && util.checksum.files "${schema}"
    fi
}

----

==== `db.rails.schema.file`

[source,bash]
----
db.rails.schema.file () 
{ 
    if [[ -f "${RAILS_SCHEMA_RB}" && -f "${RAILS_SCHEMA_SQL}" ]]; then
        if [[ "${RAILS_SCHEMA_RB}" -nt "${RAILS_SCHEMA_SQL}" ]]; then
            printf "${RAILS_SCHEMA_RB}"
        else
            printf "${RAILS_SCHEMA_SQL}"
        fi
    else
        if [[ -f "${RAILS_SCHEMA_RB}" ]]; then
            printf "${RAILS_SCHEMA_RB}"
        else
            if [[ -f "${RAILS_SCHEMA_SQL}" ]]; then
                printf "${RAILS_SCHEMA_SQL}"
            fi
        fi
    fi
}

----


=== Module `db_top`

==== `db.top`

[source,bash]
----
db.top () 
{ 
    local dbname
    local width_min=90
    local height_min=30
    local width=$(screen.width)
    local height=$(screen.height)
    if [[ ${width} -lt ${width_min} || ${height} -lt ${height_min} ]]; then
        error "Your screen is too small for db.top."
        info "Minimum required screen dimensions are ${width_min} columns, ${height_min} rows."
        info "Your screen is ${bldred}${width}x${height}."
        return
    fi
    local -a connections_arguments
    local -a connections_names
    local -a connections_passwords
    local code=0
    local i=0
    local arguments
    local tof="$(mktemp -d "${TMPDIR:-/tmp/}.XXXXXXXXXXXX")/.db.top.$$"
    cp /dev/null "${tof}" > /dev/null
    for connection in "$@"
    do
        db.psql.args.config "${connection}" 2>&1 > /dev/null || { 
            return 1
        }
        db.psql.args "${connection}" > "${tof}"
        arguments="$(cat "${tof}" | tr -d '\n')"
        connections_arguments+=("${arguments}")
        connections_names+=("${connection}")
        connections_passwords+=("${PGPASSWORD}")
        i=$((i + 1))
    done
    if [[ ${#connections_names[@]} -eq 0 ]]; then
        h1 "${bldgrn}USAGE: db.top db1 db2 ... " "   EG: db.top prod-master prod-replica1 prod-replica2"
        return 1
    fi
    ((BASH_IN_SUBSHELL)) && { 
        trap "clear" TERM
        trap "clear" EXIT
    }
    local interval=${bashmatic_db_top_refresh:-1}
    local num_dbs=${#connections_names[@]}
    h1 "Refreshing activity for ${num_dbs} databases..."
    while true; do
        local index=0
        rm -f "${tof}.errors"
        cp /dev/null "${tof}"
        local screen_height=$(screen.height)
        for dbname in "${connections_names[@]}"
        do
            local percent_total_height
            local percent_total_height_next
            percent_total_height=$(.db.top.vertical-offset "${num_dbs}" ${index})
            percent_total_height_next=$(.db.top.vertical-offset "${num_dbs}" $((index + 1)))
            local vertical_shift=$((percent_total_height * screen_height / 100))
            local vertical_shift_next=$((percent_total_height_next * screen_height / 100))
            local height=$((vertical_shift_next - vertical_shift - 7))
            cursor.at.y ${vertical_shift} >> "${tof}"
            [[ -n ${DEBUG} ]] && { 
                .output.set-indent 0
                info "CURRENT ❯${bldylw} % = ${percent_total_height}, %++ = ${percent_total_height_next}" >> "${tof}"
                h1 -- "Database: ${dbname}" "PSQL arguments:" "${connections_arguments[${index}]}" >> "${tof}"
            }
            .db.top.connection "${tof}" "${dbname}" "${connections_passwords[${index}]}" "${height}" "${connections_arguments[${index}]}"
            index=$((index + 1))
        done
        clear
        if [[ -s "${tof}.errors" ]]; then
            error "ERROR running psql with args: ${bldylw}${connections_arguments[${index}]}"
            printf "${bldred}"
            cat "${tof}.errors"
            printf "${clr}\n"
            h3 "Output:"
            cat "${tof}"
            code=111
            break
        else
            .output.set-indent 0
            hl.green "DbTop© v1.1.0 © 2016-2020 Konstantin Gredeskoul • © All Rights Reserved • MIT License —— "
            cat "${tof}"
            cursor.at.y $(($(.output.screen-height) + 1))
            printf "${bldwht}Press Ctrl-C to quit.${clr}"
            code=0
        fi
        sleep "${interval}"
    done
    return ${code}
}

----

==== `db.top.set-refresh`

[source,bash]
----
db.top.set-refresh () 
{ 
    export bashmatic_db_top_refresh="$1"
}

----


=== Module `deploy`

==== `deploy.slack`

[source,bash]
----
deploy.slack () 
{ 
    local original_text="$*"
    [[ -z ${LibDeploy__SlackHookUrl} ]] && return 1
    local text=$(echo "${original_text}" | sed -E 's/"/\"/g' | sed -E "s/'/\'/g")
    local json="{\"text\": \"$text\"}"
    local slack_url="${LibDeploy__SlackHookUrl}"
    [[ ${LibRun__DryRun} -eq ${False} ]] && { 
        if ${LibDeploy__NoSlack}; then
            hl.green "${original_text}"
        else
            curl -s -d "payload=$json" "${slack_url}" > /dev/null
            if [[ $? -eq 0 ]]; then
                info: "sent to Slack: [${text}]"
            else
                warning: "error sending to Slack, is your SLACK_URL set?"
            fi
        fi
    }
    [[ ${LibRun__DryRun} -eq ${True} ]] && run "send to slack [${text}]"
}

----

==== `deploy.slack-ding`

[source,bash]
----
deploy.slack-ding () 
{ 
    deploy.slack "<!here> $@"
}

----

==== `deploy.validate-vpn`

[source,bash]
----
deploy.validate-vpn () 
{ 
    .deploy.check-vpn "$@" || .deploy.vpn-error "$@"
}

----


=== Module `dir`

==== `dir.count-slashes`

[source,bash]
----
dir.count-slashes () 
{ 
    local dir="${1}"
    echo "${dir}" | sed 's/[^/]//g' | tr -d '\n' | wc -c | tr -d ' '
}

----

==== `dir.expand-dir`

[source,bash]
----
dir.expand-dir () 
{ 
    local dir="${1}"
    if [[ "${dir:0:1}" != "/" && "${dir:0:1}" != "~" ]]; then
        dir="$(pwd)/${dir}"
    else
        if [[ "${dir:0:1}" == "~" ]]; then
            dir="${HOME}/${dir:1:1000}"
        fi
    fi
    printf "${dir}"
}

----

==== `dir.is-a-dir`

[source,bash]
----
dir.is-a-dir () 
{ 
    local dir="${1}"
    [[ -d "${dir}" ]]
}

----


=== Module `docker`

==== `docker.abort-if-down`

[source,bash]
----
docker.abort-if-down () 
{ 
    local should_exit="${1:-true}"
    inf 'Checking if Docker is running...'
    docker ps 2> /dev/null > /dev/null
    code=$?
    if [[ ${code} == 0 ]]; then
        ui.closer.ok:
    else
        ui.closer.not-ok:
        error "docker ps returned ${code}, is Docker running?"
        [[ "${should_exit}" == "true" ]] && exit 127
        return 127
    fi
}

----

==== `docker.actions.build`

[source,bash]
----
docker.actions.build () 
{ 
    docker.build.container "$@"
}

----

==== `docker.actions.clean`

[source,bash]
----
docker.actions.clean () 
{ 
    .docker.exec "docker-compose rm"
}

----

==== `docker.actions.pull`

[source,bash]
----
docker.actions.pull () 
{ 
    local tag=${1:-'latest'}
    .docker.check-repo "${2}" || return 1
    .docker.exec "docker pull ${AppDockerRepo}:${tag}"
}

----

==== `docker.actions.push`

[source,bash]
----
docker.actions.push () 
{ 
    local tag=${1:-$(.docker.next-version)}
    .docker.check-repo "${2}" || return 1
    docker.actions.tag latest
    [[ -n ${tag} ]] && docker.actions.tag "${tag}"
    .docker.check-repo || return 1
    .docker.exec docker push "${AppDockerRepo}:${tag}"
    [[ ${tag} != 'latest' ]] && .docker.exec docker push "${AppDockerRepo}:latest"
}

----

==== `docker.actions.setup`

[source,bash]
----
docker.actions.setup () 
{ 
    setup.docker
    docker.pull
    docker.build
}

----

==== `docker.actions.start`

[source,bash]
----
docker.actions.start () 
{ 
    .docker.exec "docker-compose start"
}

----

==== `docker.actions.stop`

[source,bash]
----
docker.actions.stop () 
{ 
    .docker.exec "docker-compose stop"
}

----

==== `docker.actions.tag`

[source,bash]
----
docker.actions.tag () 
{ 
    local tag=${1}
    [[ -z ${tag} ]] && return 1
    .docker.check-repo "${2}" || return 1
    .docker.exec docker tag "${AppDockerRepo}" "${AppDockerRepo}:${tag}"
}

----

==== `docker.actions.up`

[source,bash]
----
docker.actions.up () 
{ 
    .docker.exec "docker-compose up"
}

----

==== `docker.actions.update`

[source,bash]
----
docker.actions.update () 
{ 
    docker.build
    docker.push
}

----

==== `docker.build.container`

[source,bash]
----
docker.build.container () 
{ 
    .docker.check-repo "${1}" || return 1
    local tag=${AppDockerRepo}
    .docker.exec "docker build -m 3G -c 4 --pull -t ${tag} . $*"
}

----

==== `docker.containers.clean`

[source,bash]
----
docker.containers.clean () 
{ 
    local -a args=("$@")
    run "docker rm $(docker ps -q -a) ${args[*]}"
}

----

==== `docker.image.inspect`

[source,bash]
----
docker.image.inspect () 
{ 
    run.set-next show-output-on
    local jq=" | jq"
    [[ -z $(command -v jq) ]] && jq=
    run "docker image inspect ${*} $jq"
}

----

==== `docker.image.rm`

[source,bash]
----
docker.image.rm () 
{ 
    run "docker image rm ${*}"
}

----

==== `docker.images-named`

[source,bash]
----
docker.images-named () 
{ 
    local name="${1}"
    local func="${2}"
    docker.abort-if-down false || return 127
    hl.subtle "Processing Docker images matching ${name} with function ${func}..."
    local images="$(docker images | grep "^${name}" | sed 's/  */ /g' | cut -d ' ' -f 3 | tr '\n' ' ')"
    ${func} ${images}
}

----

==== `docker.images.clean`

[source,bash]
----
docker.images.clean () 
{ 
    local name=${1:-"<none>"}
    docker.images-named "${name}" "docker.image.rm"
}

----

==== `docker.images.inspect`

[source,bash]
----
docker.images.inspect () 
{ 
    local name=${1:-"<none>"}
    docker.images-named "${name}" "docker.image.inspect"
}

----

==== `docker.last-version`

[source,bash]
----
docker.last-version () 
{ 
    .docker.check-repo "${1}" || return 1
    [[ -z ${AppDockerRepo} ]] && { 
        error "usage: docker.last-version organization/reponame:version"
        return 1
    }
    .docker.last-version "$@"
}

----

==== `docker.next-version`

[source,bash]
----
docker.next-version () 
{ 
    .docker.check-repo "${1}" || return 1
    [[ -z ${AppDockerRepo} ]] && { 
        error "usage: docker.next-version [ organization/repo-name:version ]"
        return 1
    }
    .docker.next-version "$@"
}

----

==== `docker.set-repo`

[source,bash]
----
docker.set-repo () 
{ 
    [[ -n "$1" ]] && export AppDockerRepo="$1"
}

----


=== Module `file`

==== `dir.find`

[source,bash]
----
dir.find () 
{ 
    find . -name "*$1*" -type d -print
}

----

==== `ff`

[source,bash]
----
ff () 
{ 
    file.find "$@"
}

----

==== `file.ask.if-exists`

[source,bash]
----
file.ask.if-exists () 
{ 
    local file="$1"
    shift
    local message="$*"
    [[ -z "${message}" ]] && message="File ${file} exists. Overwrite?"
    if [[ -f ${file} ]]; then
        run.set-next on-decline-return
        run.ui.ask "${message}" || return 1
    fi
    return 0
}

----

==== `file.exists-and-newer-than`

[source,bash]
----
file.exists-and-newer-than () 
{ 
    local file="${1}"
    shift
    local minutes="${1}"
    shift
    if [[ -n "$(find ${file} -mmin -${minutes} -print 2>/dev/null)" ]]; then
        return 0
    else
        return 1
    fi
}

----

==== `file.extension`

[source,bash]
----
file.extension () 
{ 
    local filename="$1"
    printf "${filename##*.}"
}

----

==== `file.extension.remove`

[source,bash]
----
file.extension.remove () 
{ 
    local filename="$1"
    printf "${filename%.*}"
}

----

==== `file.extension.replace`

[source,bash]
----
file.extension.replace () 
{ 
    local ext="$1"
    shift
    [[ -z "$1" ]] && { 
        info "USAGE: file.extension.replace <new-extension> file1 file2 ... "
        return 1
    }
    ext=".$(echo ${ext} | tr -d '.')"
    local first=true
    for file in "$@"
    do
        ${first} || printf " "
        printf "%s%s" "$(file.strip.extension "${file}")" "${ext}"
        first=false
    done
}

----

==== `file.find`

[source,bash]
----
file.find () 
{ 
    find . -name "*$1*" -type f -print
}

----

==== `file.gsub`

[source,bash]
----
file.gsub () 
{ 
    local file="$1"
    shift
    local find="$1"
    shift
    local replace="$1"
    shift
    local runtime_options="$*"
    [[ ! -s "${file}" || -z "${find}" || -z "${replace}" ]] && { 
        error "Invalid usage of file.sub — " "USAGE: file.gsub <file>    <find-regex>        <replace-regex>" "EG:    file.gsub ~/.bashrc '^export EDITOR=vi' 'export EDITOR=gvim'"
        return 1
    }
    ${GrepCommand} -q "${find}" "${file}" || return 0
    [[ -z "${runtime_options}" ]] || run.set-next ${runtime_options}
    run "sed -i'' -E -e 's/${find}/${replace}/g' \"${file}\""
}

----

==== `file.install-with-backup`

[source,bash]
----
file.install-with-backup () 
{ 
    local source="$1"
    local dest="$2"
    if [[ ! -f "${source}" ]]; then
        error "file ${source} can not be found"
        return 4
    fi
    if [[ -f "${dest}" ]]; then
        if [[ -z $(diff ${dest} ${source} 2>/dev/null) ]]; then
            info: "${dest} is up to date"
            return 0
        else
            ((${LibFile__ForceOverwrite})) || { 
                info "file ${dest} already exists, skipping (use -f to overwrite)"
                return 0
            }
            inf "making a backup of ${dest} (${dest}.bak)"
            cp "${dest}" "${dest}.bak" > /dev/null
            ui.closer.ok:
        fi
    fi
    run "mkdir -p $(dirname ${dest}) && cp ${source} ${dest}"
}

----

==== `file.last-modified-date`

[source,bash]
----
file.last-modified-date () 
{ 
    stat -f "%Sm" -t "%Y-%m-%d" "$1"
}

----

==== `file.last-modified-year`

[source,bash]
----
file.last-modified-year () 
{ 
    stat -f "%Sm" -t "%Y" "$1"
}

----

==== `file.list.filter-existing`

[source,bash]
----
file.list.filter-existing () 
{ 
    for file in "$@"
    do
        [[ -f "${file}" ]] && echo "${file}"
    done
}

----

==== `file.list.filter-non-empty`

[source,bash]
----
file.list.filter-non-empty () 
{ 
    for file in "$@"
    do
        [[ -s "${file}" ]] && echo "${file}"
    done
}

----

==== `file.size`

[source,bash]
----
file.size () 
{ 
    AppCurrentOS=${AppCurrentOS:-$(uname -s)}
    if [[ "Linux" == ${AppCurrentOS} ]]; then
        stat -c %s "$1"
    else
        file.stat "$1" st_size
    fi
}

----

==== `file.size.mb`

[source,bash]
----
file.size.mb () 
{ 
    local file="$1"
    shift
    local s=$(file.size "${file}")
    local mb=$(echo $((s / 10000)) | sedx 's/([0-9][0-9])$/.\1/g')
    printf "%.2f MB" ${mb}
}

----

==== `file.source-if-exists`

[source,bash]
----
file.source-if-exists () 
{ 
    local file
    for file in "$@"
    do
        [[ -f "${file}" ]] && source "${file}"
    done
}

----

==== `file.stat`

[source,bash]
----
file.stat () 
{ 
    local file="$1"
    local field="$2"
    [[ -f ${file} ]] || { 
        error "file ${file} is not found. Usage: file.stat <filename> <stat-field-name>"
        info "eg: ${bldylw}file.stat README.md st_size"
        return 1
    }
    [[ -n ${field} ]] || { 
        error "Second argument field is required."
        info "eg: ${bldylw}file.stat README.md st_size"
        return 2
    }
    eval $(stat -s "${file}" | tr ' ' '\n' | sed 's/^/local /g')
    echo ${!field}
}

----

==== `file.strip.extension`

[source,bash]
----
file.strip.extension () 
{ 
    file.extension.remove "$@"
}

----

==== `files.find`

[source,bash]
----
files.find () 
{ 
    local folder="$1"
    local pattern="${2}"
    [[ -z ${folder} || -z ${pattern} ]] && { 
        echo "usage: files.find <folder> <pattern>" 1>&2
        return 1
    }
    find "$1" -name "${pattern}"
}

----

==== `files.map`

[source,bash]
----
files.map () 
{ 
    local folder="${1}"
    local pattern="${2}"
    local array="${3}"
    local -a files
    if bashmatic.bash.version-four-or-later; then
        mapfile -t files < <(files.find "${folder}" "${pattern}")
    else
        files=()
        while IFS='' read -r line; do
            files+=("$line")
        done < <(files.find "${folder}" "${pattern}")
    fi
    if [[ -n ${array} ]]; then
        printf "%s" "unset ${array}; declare -a ${array}; ${array}=(${files[*]}); export ${array}"
    else
        printf "%s" "${files[*]}"
    fi
}

----

==== `files.map.shell-scripts`

[source,bash]
----
files.map.shell-scripts () 
{ 
    files.map "$1" '*.sh' "$2"
}

----


=== Module `ftrace`

==== `ftrace-in`

[source,bash]
----
ftrace-in () 
{ 
    local func=$1
    shift
    local args="$*"
    [[ -z ${TraceON} ]] && return
    export __LibTrace__StackLevel=$(( ${__LibTrace__StackLevel} + 1 ))
    printf "    %*s ${bldylw}%s${bldblu}(%s)${clr}\n" ${__LibTrace__StackLevel} ' ' ${func} "${args}" 1>&2
}

----

==== `ftrace-off`

[source,bash]
----
ftrace-off () 
{ 
    unset TraceON
}

----

==== `ftrace-on`

[source,bash]
----
ftrace-on () 
{ 
    export TraceON=true
}

----

==== `ftrace-out`

[source,bash]
----
ftrace-out () 
{ 
    local func=$1
    shift
    local code=$1
    shift
    local msg="$*"
    [[ -z ${TraceON} ]] && return
    local color="${bldgrn}"
    [[ ${code} -ne 0 ]] && color="${bldred}"
    printf "    %*s ${bldylw}%s() ${color} ➜  %d %s\n\n" ${__LibTrace__StackLevel} ' ' ${func} ${code} "${msg}" 1>&2
    export __LibTrace__StackLevel=$(( ${__LibTrace__StackLevel} - 1 ))
}

----


=== Module `gem`

==== `g-i`

[source,bash]
----
g-i () 
{ 
    gem.install "$@"
}

----

==== `g-u`

[source,bash]
----
g-u () 
{ 
    gem.uninstall "$@"
}

----

==== `gem.cache-installed`

[source,bash]
----
gem.cache-installed () 
{ 
    gem.configure-cache
    if [[ ! -s "${LibGem__GemListCache}" || -z $(find "${LibGem__GemListCache}" -mmin -30 2>/dev/null) ]]; then
        run "gem list > ${LibGem__GemListCache}" > /dev/null
    fi
}

----

==== `gem.cache-refresh`

[source,bash]
----
gem.cache-refresh () 
{ 
    ( gem.configure-cache
    gem.clear-cache
    gem.cache-installed ) > /dev/null
}

----

==== `gem.cache-reset`

[source,bash]
----
gem.cache-reset () 
{ 
    gem.cache-refresh
}

----

==== `gem.clear-cache`

[source,bash]
----
gem.clear-cache () 
{ 
    rm -f "${LibGem__GemListCache}" > /dev/null
}

----

==== `gem.configure-cache`

[source,bash]
----
gem.configure-cache () 
{ 
    export LibGem__GemListCacheBase=/tmp/.bashmatic/.gem/gem.list
    export LibGem__GemListCache=
    export LibGem__GemInstallFlags=" -N --force --quiet "
    local ruby_version=$(ruby.numeric-version)
    export LibGem__GemListCache="${LibGem__GemListCacheBase}.${ruby_version}"
    local dir=$(dirname ${LibGem__GemListCache})
    [[ -d ${dir} ]] || run "mkdir -p ${dir}" > /dev/null
}

----

==== `gem.ensure-gem-version`

[source,bash]
----
gem.ensure-gem-version () 
{ 
    local gem=$1
    local gem_version=$2
    [[ -z ${gem} || -z ${gem_version} ]] && return
    gem.cache-installed
    if [[ -z $(cat ${LibGem__GemListCache} | grep "${gem} (${gem_version})") ]]; then
        gem.uninstall ${gem}
        gem.install ${gem} ${gem_version}
    else
        info "gem ${gem} version ${gem_version} is already installed."
    fi
}

----

==== `gem.gemfile.bundler-version`

[source,bash]
----
gem.gemfile.bundler-version () 
{ 
    [[ -f Gemfile.lock ]] && grep -A2 BUNDLED Gemfile.lock | tail -1 | tr -d ' '
}

----

==== `gem.gemfile.version`

[source,bash]
----
gem.gemfile.version () 
{ 
    local gem=$1
    [[ -z ${gem} ]] && return
    if [[ -f Gemfile.lock ]]; then
        grep -E -e "^    ${gem} \([0-9]+\.[0-9]+\.[0-9](\.[a-zA-Z0-9]+)?\)" Gemfile.lock | awk '{print $2}' | sed 's/[()]//g'
    fi
}

----

==== `gem.global.latest-version`

[source,bash]
----
gem.global.latest-version () 
{ 
    local gem="$1"
    [[ -z ${gem} ]] && return
    declare -a versions=($(gem.global.versions ${gem}))
    local max=0
    local max_version=${versions[0]}
    for v in "${versions[@]}"
    do
        vi=$(util.ver-to-i "${v}")
        if [[ ${vi} -gt ${max} ]]; then
            max=${vi}
            max_version="${v}"
        fi
    done
    printf "%s" "${max_version}"
}

----

==== `gem.global.versions`

[source,bash]
----
gem.global.versions () 
{ 
    local gem=$1
    [[ -z ${gem} ]] && return
    gem.cache-installed
    cat "${LibGem__GemListCache}" | grep -E -e "^${gem} " | sedx "s/^${gem} //g;s/[(),]//g"
}

----

==== `gem.install`

[source,bash]
----
gem.install () 
{ 
    .gem.verify-name "$@" || return 1
    local gem_name="$1"
    local gem_version="$2"
    local gem_version_flags=
    local gem_version_name=
    gem_version=${gem_version:-$(gem.version ${gem_name})}
    if [[ -z ${gem_version} ]]; then
        gem_version_name=latest
        gem_version_flags=
    else
        gem_version_name="${gem_version}"
        gem_version_flags="--version ${gem_version}"
    fi
    if gem.is-installed ${gem_name} ${gem_version}; then
        info: "gem ${bldylw}${gem_name} (${bldgrn}${gem_version_name}${bldylw})${txtblu} is already installed"
    else
        info "installing ${bldylw}${gem_name} ${bldgrn}(${gem_version_name})${txtblu}..."
        run "gem install ${gem_name} ${gem_version_flags} ${LibGem__GemInstallFlags}"
        if [[ ${LibRun__LastExitCode} -eq 0 ]]; then
            rbenv rehash > /dev/null 2> /dev/null
            gem.cache-refresh
        else
            error "Unable to install gem ${bldylw}${gem_name}"
        fi
        return ${LibRun__LastExitCode}
    fi
}

----

==== `gem.is-installed`

[source,bash]
----
gem.is-installed () 
{ 
    local gem=$1
    local version=$2
    gem.cache-installed > /dev/null
    if [[ -z ${version} ]]; then
        grep -q -E -e "^${gem} \(" "${LibGem__GemListCache}"
    else
        grep -E -e "^${gem} \(" "${LibGem__GemListCache}" | grep -E -q -e "${version}"
    fi
}

----

==== `gem.remote.version`

[source,bash]
----
gem.remote.version () 
{ 
    [[ -z "$1" ]] && return
    gem query "$1" --remote -e | sedx "s/^${1} //g; s/[(),]//g"
}

----

==== `gem.uninstall`

[source,bash]
----
gem.uninstall () 
{ 
    .gem.verify-name "$@" || return 1
    local gem_name=$1
    local gem_version=$2
    gem.is-installed "${gem_name}" "${gem_version}" || { 
        info "gem ${bldylw}${gem_name}${txtblu} is not installed"
        return
    }
    local gem_flags="-x -I --force"
    if [[ -z ${gem_version} ]]; then
        gem_flags="${gem_flags} -a"
    else
        gem_flags="${gem_flags} --version ${gem_version}"
    fi
    run "gem uninstall ${gem_name} ${gem_flags}"
    gem.clear-cache
    return ${LibRun__LastExitCode}
}

----

==== `gem.version`

[source,bash]
----
gem.version () 
{ 
    local gem="$1"
    local default="$2"
    [[ -z ${gem} ]] && return
    local version
    [[ -f Gemfile.lock ]] && version=$(gem.gemfile.version "${gem}")
    if [[ -z ${version} ]]; then
        if gem.is-installed "${gem}"; then
            version=$(gem.global.latest-version "${gem}")
        else
            version=$(gem.remote.version "${gem}")
        fi
    fi
    [[ -z ${version} && -n ${default} ]] && version=${default}
    printf "%s" "${version}"
}

----


=== Module `git`

==== `bashmatic.auto-update`

[source,bash]
----
bashmatic.auto-update () 
{ 
    [[ ${Bashmatic__Test} -eq 1 ]] && return 0
    git.configure-auto-updates
    git.repo-is-clean || { 
        output.is-ssh || { 
            h1 "${BASHMATIC_HOME} has locally modified changes." "Will wait with auto-update until it's sync'd up." 1>&2
        }
        return 1
    }
    git.sync
}

----

==== `git.branch.current`

[source,bash]
----
git.branch.current () 
{ 
    git rev-parse --abbrev-ref HEAD
}

----

==== `git.commits.last.message`

[source,bash]
----
git.commits.last.message () 
{ 
    git log --pretty=format:"%s" -1
}

----

==== `git.commits.last.sha`

[source,bash]
----
git.commits.last.sha () 
{ 
    git log --pretty=format:"%H" -1
}

----

==== `git.configure-auto-updates`

[source,bash]
----
git.configure-auto-updates () 
{ 
    export LibGit__StaleAfterThisManyHours="${LibGit__StaleAfterThisManyHours:-"1"}"
    export LibGit__LastUpdateTimestampFile="/tmp/.bashmatic/.config/$(echo ${USER} | util.checksum.stdin)"
    mkdir -p $(dirname ${LibGit__LastUpdateTimestampFile})
}

----

==== `git.last-update-at`

[source,bash]
----
git.last-update-at () 
{ 
    git.configure-auto-updates
    local file="${1:-"${LibGit__LastUpdateTimestampFile}"}"
    local last_update=0
    [[ -f ${file} ]] && last_update="$(cat $file | tr -d '\n')"
    printf "%d" ${last_update}
}

----

==== `git.local-vs-remote`

[source,bash]
----
git.local-vs-remote () 
{ 
    local upstream=${1:-'@{u}'}
    local local_repo=$(git rev-parse @)
    local remote_repo=$(git rev-parse "$upstream")
    local base=$(git merge-base @ "$upstream")
    if [[ -n ${DEBUG} ]]; then
        printf "
      pwd         = $(pwd)
      remote      = $(git.remotes)
      base        = ${base}
      upstream    = ${upstream}
      local_repo  = ${local_repo}
      remote_repo = ${remote_repo}
    "
    fi
    local result=
    if [[ "${local_repo}" == "${remote_repo}" ]]; then
        result="ok"
    else
        if [[ "${local_repo}" == "${base}" ]]; then
            result="behind"
        else
            if [[ "${remote_repo}" == "${base}" ]]; then
                result="ahead"
            else
                result="diverged"
            fi
        fi
    fi
    printf '%s' ${result}
    [[ ${result} == "ok" ]] && return 0
    return 1
}

----

==== `git.open`

[source,bash]
----
git.open () 
{ 
    local remote="${1:-"origin"}"
    local url=$(git remote get-url origin | sed -E 's/git@/https:\/\//g;s/com:/com\//g')
    info "Opening URL ${bldylw}${url}"
    open -a 'Google Chrome' ${url}
}

----

==== `git.quiet`

[source,bash]
----
git.quiet () 
{ 
    [[ -n ${LibGit__QuietUpdate} ]]
}

----

==== `git.remotes`

[source,bash]
----
git.remotes () 
{ 
    git remote -v | awk '{print $2}' | uniq
}

----

==== `git.repo-is-clean`

[source,bash]
----
git.repo-is-clean () 
{ 
    local repo="${1:-${BASHMATIC_HOME}}"
    cd "${repo}" > /dev/null
    if [[ -z $(git status -s) ]]; then
        cd - > /dev/null
        return 0
    else
        cd - > /dev/null
        return 1
    fi
}

----

==== `git.save-last-update-at`

[source,bash]
----
git.save-last-update-at () 
{ 
    echo $(epoch) > ${LibGit__LastUpdateTimestampFile}
}

----

==== `git.seconds-since-last-pull`

[source,bash]
----
git.seconds-since-last-pull () 
{ 
    local last_update="$1"
    local now=$(epoch)
    printf $((now - last_update))
}

----

==== `git.sync`

[source,bash]
----
git.sync () 
{ 
    local dir="$(pwd)"
    cd "${BASHMATIC_HOME}" > /dev/null
    git.repo-is-clean || { 
        output.is-ssh || warning "${bldylw}${BASHMATIC_HOME} has locally modified files." "Please commit or stash them to allow auto-upgrade to function as designed." 1>&2
        cd "${dir}" > /dev/null
        return 1
    }
    git.update-repo-if-needed
    cd "${dir}" > /dev/null
    return 0
}

----

==== `git.sync-dirs`

[source,bash]
----
git.sync-dirs () 
{ 
    local pattern="${1:-'*'}"
    set -e
    run.set-all abort-on-error
    for dir in $(find . -type d -depth 1 -name "${pattern}*")
    do
        hl.yellow-on-gray "syncing [$dir]..."
        cd $dir > /dev/null
        run "git pull --rebase"
        cd - > /dev/null
    done
}

----

==== `git.sync-remote`

[source,bash]
----
git.sync-remote () 
{ 
    if git.quiet; then
        ( git remote update && git fetch ) 2>&1 > /dev/null
    else
        run "git remote update && git fetch"
    fi
    local status=$(git.local-vs-remote)
    if [[ ${status} == "behind" ]]; then
        git.quiet || run "git pull --rebase"
        git.quiet && git pull --rebase 2>&1 > /dev/null
    else
        if [[ ${status} != "ahead" ]]; then
            git.save-last-update-at
        else
            if [[ ${status} != "ok" ]]; then
                error "Report $(pwd) is ${status} compared to the remote." "Please fix manually to continue."
                return 1
            fi
        fi
    fi
    git.save-last-update-at
    return 0
}

----

==== `git.update-repo-if-needed`

[source,bash]
----
git.update-repo-if-needed () 
{ 
    local last_update_at=$(git.last-update-at)
    local second_since_update=$(git.seconds-since-last-pull ${last_update_at})
    local update_period_seconds=$((LibGit__StaleAfterThisManyHours * 60 * 60))
    if [[ ${second_since_update} -gt ${update_period_seconds} ]]; then
        git.sync-remote
    else
        if [[ -n ${DEBUG} ]]; then
            git.quiet || info "${BASHMATIC_HOME} will update in $((update_period_seconds - second_since_update)) seconds..."
        fi
    fi
}

----


=== Module `github`

==== `github.clone`

[source,bash]
----
github.clone () 
{ 
    test -n "$1" && github.validate && run "git clone git@github.com:$(github.org)/$1"
}

----

==== `github.org`

[source,bash]
----
github.org () 
{ 
    local namespace="$1"
    if [[ -z ${namespace} ]]; then
        git config --global --get user.github
    else
        git config --global --unset user.github
        git config --global --add user.github "${namespace}"
    fi
}

----

==== `github.setup`

[source,bash]
----
github.setup () 
{ 
    local namespace="$(github.org)"
    if [[ -z "${namespace}" ]]; then
        unset GITHUB_ORG
        run.ui.ask-user-value GITHUB_ORG "Please enter the name of your Github Organization:" || return 1
        github.org "${GITHUB_ORG}"
        echo
        h2 "Your github organization was saved in your ~/.gitconfig file." "To change it in the future, run: ${bldylw}github.org ${blgrn}new-organization"
        echo
    fi
    github.org > /dev/null
}

----

==== `github.validate`

[source,bash]
----
github.validate () 
{ 
    inf "Validating Github Configuration..."
    if github.org > /dev/null; then
        ok:
        return 0
    else
        not-ok:
        github.setup
        return $?
    fi
}

----


=== Module `jemalloc`

==== `jm.check`

[source,bash]
----
jm.check () 
{ 
    local JM_Quiet=false
    local JM_Ruby=false
    local JM_Stats=false
    while :; do
        case $1 in 
            -q | --quiet)
                shift
                export JM_Quiet=true
            ;
            -r | --ruby)
                shift
                export JM_Ruby=true
            ;
            -s | --stats)
                shift
                export JM_Stats=true
                exit $?
            ;
            -h | -\? | --help)
                shift
                jm.usage
                exit 0
            ;
            --)
                shift
                break
            ;
            *)
                break
            ;
        esac
    done
    ${JM_Ruby} && { 
        jm.ruby.report
        exit 0
    }
    ${JM_Quiet} && { 
        jm.jemalloc.detect-quiet
        code=$?
        exit ${code}
    }
    ${JM_Stats} && { 
        jm.jemalloc.stats
        exit 0
    }
    jm.jemalloc.detect-loud
}

----

==== `jm.jemalloc.detect-loud`

[source,bash]
----
jm.jemalloc.detect-loud () 
{ 
    jm.jemalloc.detect-quiet
    local code=$?
    local local_ruby=$(jm.ruby.detect)
    printf "${ColorBlue}Checking if ruby ${ColorYellow}${local_ruby}${ColorBlue} is linked with jemalloc... \n\n "
    if [[ ${code} -eq 0 ]]; then
        printf " ✅ ${ColorGreen} — jemalloc was detected.\n"
    else
        printf " 🚫 ${ColorRed} — jemalloc was not detected.\n"
    fi
    printf "${ColorReset}\n"
    return ${code}
}

----

==== `jm.jemalloc.detect-quiet`

[source,bash]
----
jm.jemalloc.detect-quiet () 
{ 
    MALLOC_CONF=stats_print:true ruby -e "exit" 2>&1 | grep -q "jemalloc statistics"
    return $?
}

----

==== `jm.jemalloc.stats`

[source,bash]
----
jm.jemalloc.stats () 
{ 
    jm.jemalloc.detect-quiet || { 
        printf "No Jemalloc was found for the curent ruby $(jm.ruby.detect)\n"
        return 1
    }
    MALLOC_CONF=stats_print:true ruby -e "exit" 2>&1 | less -S
}

----

==== `jm.ruby.detect`

[source,bash]
----
jm.ruby.detect () 
{ 
    local ruby_loc
    if [[ -n $(which rbenv) ]]; then
        ruby_loc=$(rbenv versions | grep '*' | awk '{print $2}')
        [[ -n ${ruby_loc} ]] && ruby_loc="(rbenv) ${ruby_loc}"
    else
        ruby_loc="$(which ruby) $(ruby -e 'puts "#{RUBY_VERSION} (#{RUBY_PLATFORM})"')"
    fi
    printf "%s" "${ruby_loc}"
}

----

==== `jm.ruby.report`

[source,bash]
----
jm.ruby.report () 
{ 
    printf "Ruby version being tested:\n  →  ${ColorBlue}$(which ruby) ${ColorYellow}$(jm.ruby.detect)${ColorReset}\n"
}

----

==== `jm.usage`

[source,bash]
----
jm.usage () 
{ 
    printf "
${ColorBlue}USAGE:${ColorReset}
  $(basename $0) [ -q/--quiet ]
                 [ -r/--ruby  ]
                 [ -s/--stats ]
                 [ -h/--help  ]

${ColorBlue}DESCRIPTION:${ColorReset}
  Determines whether the currently defined in the PATH ruby
  interpreter is linked with libjemalloc memory allocator.

${ColorBlue}OPTIONS${ColorReset}
  -q/--quiet        Do not print output, exit with 1 if no jemalloc
  -r/--ruby         Print which ruby is currently in the PATH
  -s/--stats        Print the jemalloc stats
  -h/--help         This page.
%s
" ""
    exit 0
}

----


=== Module `json`

==== `json.begin-array`

[source,bash]
----
json.begin-array () 
{ 
    [[ -n "$1" ]] && json.begin-key "$1"
    echo " ["
}

----

==== `json.begin-hash`

[source,bash]
----
json.begin-hash () 
{ 
    [[ -n "$1" ]] && json.begin-key "$1"
    echo "{"
}

----

==== `json.begin-key`

[source,bash]
----
json.begin-key () 
{ 
    if [[ -n "$1" ]]; then
        printf "\"${1}\": "
    fi
}

----

==== `json.end-array`

[source,bash]
----
json.end-array () 
{ 
    printf "]"
    [[ "$1" == "true" ]] && printf ","
    echo
}

----

==== `json.end-hash`

[source,bash]
----
json.end-hash () 
{ 
    printf "}"
    [[ "$1" == "true" ]] && printf ","
    echo
}

----

==== `json.file-to-array`

[source,bash]
----
json.file-to-array () 
{ 
    json.begin-array "$1"
    cat $2 | tr -d '\r' | tr -d '\015' | sed 's/^/"/g;s/$/",/g' | tail -r | awk -F, '{if (FNR!=1) print; else print $1} ' | tail -r
    json.end-array $3
}

----


=== Module `maths`

==== `maths.eval`

[source,bash]
----
maths.eval () 
{ 
    local __math_chars=(!²³¹¼½¾×÷ΠΣ⁰ⁱ⁴⁵⁶⁷⁸⁹ⁿ⅓⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞∅∈∉√∛∜∞∩∪∿⊂⊃⟌τ𝛕𝜏𝝉𝞃𝞽०१२३४५६७८९ℯ𝐞𝑒𝒆𝖾𝗲𝘦𝙚𝚎ｅπϖ𝛑𝛡𝜋𝜛𝝅𝝕𝝿𝞏𝞹𝟉𝐢𝑖𝒊𝒾𝓲𝔦𝕚𝖎𝗂𝗶𝘪𝙞𝚒)
    local -a __math_chars_array=($(echo "${__math_chars}" | sedx 's/(.)/\1 /g'))
    local __math_chars_array
    [[ -z "$1" ]] && { 
        output.set-max-width 100
        output.set-min-width 40
        usage-box "maths.eval 'expression' [ floating precitions [ total width ] © Computes a mathematical expression with UTF support" "Example 1." "maths.eval '√(57)*⅓×(sin(π÷(1.3)))' => 1.66882" "Example 2." "maths.eval '5!×(ｅ)' => 326.19382" "Special Characters:" "" " 0 through 23" "${__math_chars_array[*]:0:24}" "24 through 48" "${__math_chars_array[*]:24:24}" "48 through 72" "${__math_chars_array[*]:48:24}" "72 through 96" "${__math_chars_array[*]:72:24}"
        info "NOTE: ensure to use () brackets to group items you want to compute."
        info "NOTE: if in doubt, add more brackets :) "
        output.reset-min-max-width
        return 0
    }
    gem.install unicode_math > /dev/null
    local expression="$1"
    shift
    local output_precision="${1:-"5"}"
    shift
    local output_width="${1}"
    local ruby_script="require 'unicode_math'; printf('%${output_width}.${output_precision}f', (Math.module_eval { ${expression} }))"
    ruby_script="$(echo "${ruby_script}" | sedx 's/ ?(×|÷|!)/\.\1/g')"
    local temp_file
    temp_file="$(mktemp)"
    ruby -r 'unicode_math' -e "${ruby_script}" 2> "${temp_file}"
    local code="$?"
    [[ ${code} -ne 0 ]] && { 
        error "Unable to perform an arithmetic expression:" "${bldylw}${ruby_script}" 1>&2
        info "Error: \n${bldylw}$(cat "${temp_file}")"
        return 1
    }
    rm -f "${temp_file}"
    return 0
}

----


=== Module `net`

==== `net.fast-scan`

[source,bash]
----
net.fast-scan () 
{ 
    local subnet="${1:-"$(net.local-subnet)"}"
    local out=$(mktemp)
    run.set-next show-output-on
    local colored=/tmp/colored.$$
    run "sudo nmap --min-parallelism 15 -O --host-timeout 5 -F ${subnet} > ${out}"
    run "echo 'printf \"' > ${colored}"
    cat ${out} | sed -E "s/Nmap scan report for (.*)$/\n\${bldylw}Nmap scan report for \1\${clr}\n/g" >> ${colored}
    run "echo '\"' >> ${colored}"
    bash ${colored}
}

----

==== `net.local-net`

[source,bash]
----
net.local-net () 
{ 
    ifconfig -a | grep inet | grep broadcast | awk '{print $2}' | awk 'BEGIN{FS="."}{printf "%d.%d.%d.%s", $1, $2, $3, "0/24"}'
}

----

==== `net.local-subnet`

[source,bash]
----
net.local-subnet () 
{ 
    local subnet="$(ifconfig -a |
    grep inet | grep broadcast | 
    grep -v 'inet 169' |
    grep -v 'inet 127' |
    awk '{print $2}' |
    cut -d '.' -f 1,2,3 |
    sort |
    uniq |
    head -1).0/24"
    printf '%s' ${subnet}
}

----


=== Module `osx`

==== `afp.servers`

[source,bash]
----
afp.servers () 
{ 
    osx.local-servers afp
}

----

==== `bashmatic-set-fqdn`

[source,bash]
----
bashmatic-set-fqdn () 
{ 
    osx.set-fqdn "$@"
}

----

==== `bashmatic-term`

[source,bash]
----
bashmatic-term () 
{ 
    open $(bashmatic-term-program)
}

----

==== `bashmatic-term-program`

[source,bash]
----
bashmatic-term-program () 
{ 
    if [[ -d /Applications/iTerm.app ]]; then
        printf '%s' /Applications/iTerm.app
    else
        if [[ -d /Applications/Utilities/Terminal.app ]]; then
            printf '%s' /Applications/Utilities/Terminal.app
        else
            printf '%s' "echo 'No TERMINAL application found'"
        fi
    fi
}

----

==== `change-underscan`

[source,bash]
----
change-underscan () 
{ 
    set +e
    local amount_percentage="$1"
    if [[ -z "${amount_percentage}" ]]; then
        printf "%s\n\n" "USAGE: change-underscan percent"
        printf "%s\n" "   eg: change-underscan   5  # underscan by 5%"
        printf "%s\n" "   eg: change-underscan -10  # overscan by 10%"
        return -1
    fi
    local file="/var/db/.com.apple.iokit.graphics"
    local backup="/var/db/.com.apple.iokit.graphics.bak.$(date '+%F.%X')"
    local new_value=$(ruby -e "puts (10000.0 + 10000.0 * ${amount_percentage}.to_f / 100.0).to_i")
    h1 'This utility allows you to change underscan/overscan' 'on monitors that do not offer that option via GUI.'
    run.ui.ask "Continue?"
    info "Great! First we need to identify your monitor."
    hl.yellow "Please make sure that the external monitor is plugged in."
    run.ui.ask "Is it plugged in?"
    info "Making a backup of your current graphics settings..."
    inf "Please enter your password, if asked: "
    set -e
    bash -c 'set -e; sudo ls -1 > /dev/null; set +e'
    ok
    run "sudo rm -f \"${backup}\""
    export LibRun__AbortOnError=${True}
    run "sudo cp -v \"${file}\" \"${backup}\""
    h2 "Now: please change the resolution ${bldylw}on the problem monitor." "NOTE: it's ${italic}not important what resolution you choose," "as long as it's different than what you had previously..." "Finally: exit Display Preferences once you changed resolution."
    run "open /System/Library/PreferencePanes/Displays.prefPane"
    run.ui.ask "Have you changed the resolution and exited Display Prefs? "
    local line=$(sudo diff "${file}" "${backup}" 2>/dev/null | head -1 | /usr/bin/env ruby -ne 'puts $_.to_i')
    [[ -n $DEBUG ]] && info "diff line is at ${line}"
    value=
    if [[ "${line}" -gt 0 ]]; then
        line_pscn_key=$(($line - 4))
        line_pscn_value=$(($line - 3))
        ( awk "NR==${line_pscn_key}{print;exit}" "${file}" | grep -q pscn ) && { 
            value=$(awk "NR==${line_pscn_value}{print;exit}" "${file}" | awk 'BEGIN{FS="[<>]"}{print $3}')
            [[ -n $DEBUG ]] && info "current value is ${value}"
        }
    else
        error "It does not appear that anything changed, sorry."
        return -1
    fi
    h2 "Now, please unplug the problem monitor temporarily..."
    run.ui.ask "...and press Enter to continue "
    if [[ -n ${value} && ${value} -ne ${new_value} ]]; then
        export LibRun__AbortOnError=${True}
        run "sudo sed -i.backup \"${line_pscn_value}s/${value}/${new_value}/g\" \"${file}\""
        echo
        h2 "Congratulations!" "Your display underscan value has been changed."
        info "Previous Value — ${bldpur}${value}"
        info "New value:     — ${bldgrn}${new_value}"
        hr
        info "${bldylw}IMPORTANT!"
        info "You must restart your computer for the settings to take affect."
        echo
        run.ui.ask "Should I reboot your computer now? "
        info "Very well, rebooting!"
        run "sudo reboot"
    else
        warning "Unable to find the display scan value to change. "
        info "Could it be that you haven't restarted since your last run?"
        echo
        info "Feel free to edit file directly, using:"
        info "eg: ${bldylw}vim ${file} +${line_pscn_value}"
    fi
}

----

==== `cookie-dump`

[source,bash]
----
cookie-dump () 
{ 
    osx.cookie-dump "$@"
}

----

==== `http.servers`

[source,bash]
----
http.servers () 
{ 
    osx.local-servers http
}

----

==== `https.servers`

[source,bash]
----
https.servers () 
{ 
    osx.local-servers https
}

----

==== `osx.cookie-dump`

[source,bash]
----
osx.cookie-dump () 
{ 
    local file="$1"
    local tmp
    if [[ ! -s ${file} ]]; then
        tmp=$(mktemp)
        file=${tmp}
        pbpaste > ${file}
        local size=$(file.size ${file})
        if [[ ${size} -lt 4 ]]; then
            error "Pasted data is too small to be a valid cookie?"
            info "Here is what we got in your clipboard:\n\n$(cat ${file})\n"
            return 1
        fi
    fi
    if [[ -s ${file} ]]; then
        cat "${file}" | tr '; ' '\n' | sed '/^$/d' | awk 'BEGIN{FS="="}{printf( "%10d = %s\n", length($2), $1) }' | sort -n
    else
        info "File ${file} does not exist or is empty. "
        info "Copy the value of the ${bldylw}Set-Cookie:${txtblu} header into the clipboard,"
        info "and rerun this function."
    fi
    [[ -z ${tmp} ]] || rm -f ${tmp}
}

----

==== `osx.dropbox.exclude`

[source,bash]
----
osx.dropbox.exclude () 
{ 
    local dir="$1"
    if [[ -d "${dir}" ]]; then
        xattr -w com.dropbox.ignored 1 "$1"
    else
        error "Folder '${dir}' does not exist or is blank."
        return 1
    fi
}

----

==== `osx.dropbox.exclude-pwd`

[source,bash]
----
osx.dropbox.exclude-pwd () 
{ 
    xattr -w com.dropbox.ignored 1 $(pwd)
}

----

==== `osx.env-print`

[source,bash]
----
osx.env-print () 
{ 
    local var="$1"
    printf "${bldylw}%20s: ${bldgrn}%s\n" ${var} ${!var}
}

----

==== `osx.local-servers`

[source,bash]
----
osx.local-servers () 
{ 
    local protocol="${1:-"ssh"}"
    run.set-next show-output-on
    run "timeout 20 dns-sd -B _${protocol}._tcp ."
}

----

==== `osx.ramdisk.mount`

[source,bash]
----
osx.ramdisk.mount () 
{ 
    local size="${1:-"8"}"
    local diskname="${2:-"ramdisk"}"
    local total=$((size * 2 * 1024))
    [[ $(uname -s) != "Darwin" ]] && { 
        error "This function only works on OSX"
        return 1
    }
    if [[ "${diskname}" =~ ' ' ]]; then
        error "Disk name can not contain spaces."
        return 1
    fi
    local path="/Volumes/${diskname}"
    if ( mount | ${GrepCommand} -q "/[V]olumes/${diskname}" ); then
        info "Looks like RAM disk already exists at ${path}..."
        return 1
    else
        run.ui.ask "Creating RAM disk sized ${size}Mb at ${path}"
        run.set-next show-output-on
        run "diskutil erasevolume HFS+ '${diskname}' $(hdiutil attach -nomount ram://${total})"
    fi
}

----

==== `osx.ramdisk.unmount`

[source,bash]
----
osx.ramdisk.unmount () 
{ 
    local diskname="${2:-"ramdisk"}"
    [[ $(uname -s) != "Darwin" ]] && { 
        error "This function only works on OSX"
        return 1
    }
    local path="/Volumes/${diskname}"
    if ( mount | ${GrepCommand} -q "/[V]olumes/${diskname}" ); then
        run.ui.ask "Unmount RAM disk at ${path}? "
        run "umount ${path}"
    else
        info "Couldn't find volume ${bldylw}${path}. Does the RAM disk exist?"
        return 1
    fi
}

----

==== `osx.scutil-print`

[source,bash]
----
osx.scutil-print () 
{ 
    local var="$1"
    printf "${bldylw}%20s: ${bldgrn}%s\n" ${var} $(sudo scutil --get ${var} | tr -d '\n')
}

----

==== `osx.set-fqdn`

[source,bash]
----
osx.set-fqdn () 
{ 
    local fqdn="$1"
    local domain=$(echo ${fqdn} | sed -E 's/^[^.]*\.//g')
    local host=$(echo ${fqdn} | sed -E 's/\..*//g')
    h1 "Current HostName: ${bldylw}${HOSTNAME}"
    echo
    info "• You provided the following FQDN : ${bldylw}${fqdn}"
    echo
    info "• Hostname will be set to: ${bldgrn}${host}"
    info "• Domain will also change: ${bldgrn}${domain}"
    echo
    run.ui.ask "Does that look correct to you?"
    echo
    inf "Now, please provide your SUDO password, if asked: "
    sudo printf '' || { 
        ui.closer.not-ok:
        exit 1
    }
    ui.closer.ok:
    run "sudo scutil --set HostName ${fqdn}"
    run "sudo scutil --set LocalHostName ${host}.local 2>/dev/null|| true"
    run "sudo scutil --set ComputerName ${host}"
    run "dscacheutil -flushcache"
    echo
    h2 "Result of the changes:"
    osx.scutil-print HostName
    osx.scutil-print LocalHostName
    osx.scutil-print ComputerName
    osx.env-print HOSTNAME
    echo
    hr
}

----

==== `ssh.servers`

[source,bash]
----
ssh.servers () 
{ 
    osx.local-servers ssh
}

----


=== Module `output`

==== `abort`

[source,bash]
----
abort () 
{ 
    printf -- "${LibOutput__LeftPrefix}${txtblk}${bakred}  « ABORT »  ${clr} ${bldwht} ✔  ${bldgrn}$*${clr}" 1>&2
    echo
}

----

==== `ascii-clean`

[source,bash]
----
ascii-clean () 
{ 
    .output.clean "$@"
}

----

==== `ascii-pipe`

[source,bash]
----
ascii-pipe () 
{ 
    cat | .output.clean.pipe
}

----

==== `ask`

[source,bash]
----
ask () 
{ 
    printf -- "%s${txtylw}$*${clr}\n" "${LibOutput__LeftPrefix}"
    printf -- "%s${txtylw}❯ ${bldwht}" "${LibOutput__LeftPrefix}"
}

----

==== `box.blue-in-green`

[source,bash]
----
box.blue-in-green () 
{ 
    .output.box "${bldblu}" "${bldgrn}" "$@"
}

----

==== `box.blue-in-yellow`

[source,bash]
----
box.blue-in-yellow () 
{ 
    .output.box "${bldylw}" "${bldblu}" "$@"
}

----

==== `box.green-in-cyan`

[source,bash]
----
box.green-in-cyan () 
{ 
    .output.box "${bldgrn}" "${bldcyn}" "$@"
}

----

==== `box.green-in-green`

[source,bash]
----
box.green-in-green () 
{ 
    .output.box "${bldgrn}" "${bldgrn}" "$@"
}

----

==== `box.green-in-magenta`

[source,bash]
----
box.green-in-magenta () 
{ 
    .output.box "${bldgrn}" "${bldpur}" "$@"
}

----

==== `box.green-in-yellow`

[source,bash]
----
box.green-in-yellow () 
{ 
    .output.box "${bldgrn}" "${bldylw}" "$@"
}

----

==== `box.magenta-in-blue`

[source,bash]
----
box.magenta-in-blue () 
{ 
    .output.box "${bldblu}" "${bldpur}" "$@"
}

----

==== `box.magenta-in-green`

[source,bash]
----
box.magenta-in-green () 
{ 
    .output.box "${bldpur}" "${bldgrn}" "$@"
}

----

==== `box.red-in-magenta`

[source,bash]
----
box.red-in-magenta () 
{ 
    .output.box "${bldred}" "${bldpur}" "$@"
}

----

==== `box.red-in-red`

[source,bash]
----
box.red-in-red () 
{ 
    .output.box "${txtred}" "${txtred}" "$@"
}

----

==== `box.red-in-yellow`

[source,bash]
----
box.red-in-yellow () 
{ 
    .output.box "${bldred}" "${bldylw}" "$@"
}

----

==== `box.white-on-blue`

[source,bash]
----
box.white-on-blue () 
{ 
    .output.box "${bakblu}" "${bldwht}" "$@"
}

----

==== `box.white-on-green`

[source,bash]
----
box.white-on-green () 
{ 
    .output.box "${bakgrn}" "${bldwht}" "$@"
}

----

==== `box.yellow-in-blue`

[source,bash]
----
box.yellow-in-blue () 
{ 
    .output.box "${bldylw}" "${bldblu}" "$@"
}

----

==== `box.yellow-in-red`

[source,bash]
----
box.yellow-in-red () 
{ 
    .output.box "${bldred}" "${bldylw}" "$@"
}

----

==== `box.yellow-in-yellow`

[source,bash]
----
box.yellow-in-yellow () 
{ 
    .output.box "${bldylw}" "${txtylw}" "$@"
}

----

==== `box.yellow-on-purple`

[source,bash]
----
box.yellow-on-purple () 
{ 
    .output.box "${bakpur}" "${bldylw}" "$@"
}

----

==== `br`

[source,bash]
----
br () 
{ 
    echo
}

----

==== `center`

[source,bash]
----
center () 
{ 
    .output.center "$@"
}

----

==== `columnize`

[source,bash]
----
columnize () 
{ 
    local columns="${1:-2}"
    local sw=${SCREEN_WIDTH:-120}
    [[ -z ${sw} ]] && sw=$(screen-width)
    pr -l 10000 -${columns} -e4 -w ${sw} | expand -8 | sed -E '/^ *$/d' | grep -v 'Page '
}

----

==== `command-spacer`

[source,bash]
----
command-spacer () 
{ 
    local color="${txtgrn}"
    [[ ${LibRun__LastExitCode} -ne 0 ]] && color="${txtred}"
    [[ -z ${LibRun__AssignedWidth} || -z ${LibRun__CommandLength} ]] && return
    printf "%s${color}" ""
    local __width=$((LibRun__AssignedWidth - LibRun__CommandLength - 10))
    [[ ${__width} -gt 0 ]] && .output.replicate-to "▪" "${__width}"
}

----

==== `cursor.at.x`

[source,bash]
----
cursor.at.x () 
{ 
    .output.cursor-move-to-x "$@"
}

----

==== `cursor.at.y`

[source,bash]
----
cursor.at.y () 
{ 
    .output.cursor-move-to-y "$@"
}

----

==== `cursor.down`

[source,bash]
----
cursor.down () 
{ 
    .output.cursor-down-by "$@"
}

----

==== `cursor.left`

[source,bash]
----
cursor.left () 
{ 
    .output.cursor-left-by "$@"
}

----

==== `cursor.rewind`

[source,bash]
----
cursor.rewind () 
{ 
    local x=${1:-0}
    .output.cursor-move-to-x ${x}
}

----

==== `cursor.right`

[source,bash]
----
cursor.right () 
{ 
    .output.cursor-right-by "$@"
}

----

==== `cursor.shift.x`

[source,bash]
----
cursor.shift.x () 
{ 
    local shift="$1"
    if [[ "${shift:0:1}" == "-" ]]; then
        .output.cursor-left-by "${shift:1}"
    else
        .output.cursor-right-by "${shift}"
    fi
}

----

==== `cursor.up`

[source,bash]
----
cursor.up () 
{ 
    .output.cursor-up-by "$@"
}

----

==== `debug`

[source,bash]
----
debug () 
{ 
    [[ -z ${DEBUG} ]] && return
    printf -- "${LibOutput__LeftPrefix}${bakpur}[ debug ] $*  ${clr}\n"
}

----

==== `duration`

[source,bash]
----
duration () 
{ 
    local millis="$1"
    local exit_code="$2"
    [[ -n $(which bc) ]] || return
    if [[ -n ${millis} && ${millis} -ge 0 ]]; then
        local pattern
        pattern=" %6.6s ms "
        pattern="${txtblu}〔${pattern}〕"
        printf "${txtblu}${pattern}" "${millis}"
    fi
    if [[ -n ${exit_code} ]]; then
        [[ ${exit_code} -eq 0 ]] && printf " ${txtblk}${bakgrn} %3d ${clr}" ${exit_code}
        [[ ${exit_code} -gt 0 ]] && printf " ${bldwht}${bakred} %3d ${clr}" ${exit_code}
    fi
}

----

==== `err`

[source,bash]
----
err () 
{ 
    printf -- "${LibOutput__LeftPrefix}${bldylw}${bakred}  « ERROR! »  ${clr} ${bldred}$*${clr}" 1>&2
}

----

==== `error`

[source,bash]
----
error () 
{ 
    header=$(printf -- "${bldwht}${bakred} « ERROR » ${clr}")
    box.red-in-red "${header} ${bldylw}$@" 1>&2
}

----

==== `error:`

[source,bash]
----
error: () 
{ 
    err $*
    ui.closer.not-ok:
}

----

==== `h.black`

[source,bash]
----
h.black () 
{ 
    center "${bldylw}${bakblk}" "$@"
}

----

==== `h.blue`

[source,bash]
----
h.blue () 
{ 
    center "${txtblk}${bakblu}" "$@"
}

----

==== `h.e`

[source,bash]
----
h.e () 
{ 
    local header="$1"
    shift
    box.red-in-red "${bakred}${bldwht} ${bldylw}${header}" "$@" 1>&2
}

----

==== `h.green`

[source,bash]
----
h.green () 
{ 
    center "${txtblk}${bakgrn}" "$@"
}

----

==== `h.orange`

[source,bash]
----
h.orange () 
{ 
    left "${white_on_orange}" "$@"
}

----

==== `h.orange-center`

[source,bash]
----
h.orange-center () 
{ 
    center "${white_on_orange}" "$@"
}

----

==== `h.red`

[source,bash]
----
h.red () 
{ 
    center "${txtblk}${bakred}" "$@"
}

----

==== `h.salmon`

[source,bash]
----
h.salmon () 
{ 
    left "${white_on_salmon}" "$@"
}

----

==== `h.salmon-center`

[source,bash]
----
h.salmon-center () 
{ 
    center "${white_on_salmon}" "$@"
}

----

==== `h.yellow`

[source,bash]
----
h.yellow () 
{ 
    center "${txtblk}${bakylw}" "$@"
}

----

==== `h1`

[source,bash]
----
h1 () 
{ 
    box.blue-in-yellow "$@"
}

----

==== `h1.blue`

[source,bash]
----
h1.blue () 
{ 
    box.magenta-in-blue "$@"
}

----

==== `h1.green`

[source,bash]
----
h1.green () 
{ 
    box.green-in-magenta "$@"
}

----

==== `h1.purple`

[source,bash]
----
h1.purple () 
{ 
    box.magenta-in-green "$@"
}

----

==== `h1.red`

[source,bash]
----
h1.red () 
{ 
    box.red-in-red "$@"
}

----

==== `h1.yellow`

[source,bash]
----
h1.yellow () 
{ 
    box.yellow-in-red "$@"
}

----

==== `h1bg`

[source,bash]
----
h1bg () 
{ 
    box.white-on-blue "$@"
}

----

==== `h2`

[source,bash]
----
h2 () 
{ 
    box.blue-in-green "$@"
}

----

==== `h2.green`

[source,bash]
----
h2.green () 
{ 
    box.green-in-cyan "$@"
}

----

==== `h2bg`

[source,bash]
----
h2bg () 
{ 
    box.white-on-green "$@"
}

----

==== `h3`

[source,bash]
----
h3 () 
{ 
    box.magenta-in-green "$@"
}

----

==== `h3bg`

[source,bash]
----
h3bg () 
{ 
    box.yellow-on-purple "$@"
}

----

==== `h4`

[source,bash]
----
h4 () 
{ 
    box.magenta-in-green "$@"
}

----

==== `hdr`

[source,bash]
----
hdr () 
{ 
    h1 "$@"
}

----

==== `hl.blue`

[source,bash]
----
hl.blue () 
{ 
    left "${bldwht}${bakpur}" "$@"
}

----

==== `hl.desc`

[source,bash]
----
hl.desc () 
{ 
    left "${bakylw}${txtblk}${bakylw}" "$@"
}

----

==== `hl.green`

[source,bash]
----
hl.green () 
{ 
    left "${txtblk}${bakgrn}" "$@"
}

----

==== `hl.subtle`

[source,bash]
----
hl.subtle () 
{ 
    left "${bldwht}${bakblk}${underlined}" "$@"
}

----

==== `hl.yellow`

[source,bash]
----
hl.yellow () 
{ 
    left "${txtblk}${bakylw}" "$@"
}

----

==== `hl.yellow-on-gray`

[source,bash]
----
hl.yellow-on-gray () 
{ 
    left "${yellow_on_gray}" "$@"
}

----

==== `hr`

[source,bash]
----
hr () 
{ 
    [[ -z "$*" ]] || printf "$*"
    .output.hr
}

----

==== `hr.colored`

[source,bash]
----
hr.colored () 
{ 
    local color="$*"
    [[ -z ${color} ]] && color="${bldred}"
    .output.hr "$(screen-width)" "—" "${*}"
}

----

==== `inf`

[source,bash]
----
inf () 
{ 
    printf -- "${LibOutput__LeftPrefix}${txtblu}${clr}${txtblu}$*${clr}"
}

----

==== `info`

[source,bash]
----
info () 
{ 
    inf $@
    echo
}

----

==== `info:`

[source,bash]
----
info: () 
{ 
    inf $*
    ui.closer.ok:
}

----

==== `left`

[source,bash]
----
left () 
{ 
    .output.left-justify "$@"
}

----

==== `left-prefix`

[source,bash]
----
left-prefix () 
{ 
    [[ -z ${LibOutput__LeftPrefix} ]] && { 
        export LibOutput__LeftPrefix=$(.output.replicate-to " " "${LibOutput__LeftPrefixLen}")
    }
    printf "${LibOutput__LeftPrefix}"
}

----

==== `not-ok`

[source,bash]
----
not-ok () 
{ 
    ui.closer.not-ok "$@"
}

----

==== `not-ok:`

[source,bash]
----
not-ok: () 
{ 
    ui.closer.not-ok: "$@"
}

----

==== `ok`

[source,bash]
----
ok () 
{ 
    ui.closer.ok "$@"
}

----

==== `ok:`

[source,bash]
----
ok: () 
{ 
    ui.closer.ok: "$@"
}

----

==== `okay`

[source,bash]
----
okay () 
{ 
    printf -- " ${bldgrn} ✓ ALL OK 👍  $*${clr}" 1>&2
    echo
}

----

==== `output.color.off`

[source,bash]
----
output.color.off () 
{ 
    reset-color: 1>&2
    reset-color: 1>&1
}

----

==== `output.color.on`

[source,bash]
----
output.color.on () 
{ 
    printf "${bldred}" 1>&2
    printf "${bldblu}" 1>&1
}

----

==== `output.has-stdin`

[source,bash]
----
output.has-stdin () 
{ 
    test -s /dev/stdin
}

----

==== `output.is-pipe`

[source,bash]
----
output.is-pipe () 
{ 
    [[ -p /dev/stdout ]]
}

----

==== `output.is-redirect`

[source,bash]
----
output.is-redirect () 
{ 
    [[ ! -t 1 && ! -p /dev/stdout ]]
}

----

==== `output.is-ssh`

[source,bash]
----
output.is-ssh () 
{ 
    [[ -n "${SSH_CLIENT}" || -n "${SSH_CONNECTION}" ]]
}

----

==== `output.is-terminal`

[source,bash]
----
output.is-terminal () 
{ 
    output.is-tty || output.is-redirect || output.is-pipe || output.is-ssh
}

----

==== `output.is-tty`

[source,bash]
----
output.is-tty () 
{ 
    [[ -t 1 ]]
}

----

==== `output.print-at-x-y`

[source,bash]
----
output.print-at-x-y () 
{ 
    local x=$1
    shift
    local y=$1
    shift
    .output.cursor-move-to-x "${x}"
    cursor.up "${y}"
    printf "%s" "$*"
    cursor.down "${y}"
    .output.cursor-move-to-x 0
}

----

==== `output.reset-min-max-width`

[source,bash]
----
output.reset-min-max-width () 
{ 
    export LibOutput__MinWidth=${LibOutput__MinWidth__Default}
    export LibOutput__MaxWidth=${LibOutput__MaxWidth__Default}
}

----

==== `output.set-max-width`

[source,bash]
----
output.set-max-width () 
{ 
    export LibOutput__MaxWidth="$1"
}

----

==== `output.set-min-width`

[source,bash]
----
output.set-min-width () 
{ 
    export LibOutput__MinWidth="$1"
}

----

==== `puts`

[source,bash]
----
puts () 
{ 
    printf "  ⇨ ${txtwht}$*${clr}"
}

----

==== `reset-color`

[source,bash]
----
reset-color () 
{ 
    printf "${clr}\n"
}

----

==== `reset-color:`

[source,bash]
----
reset-color: () 
{ 
    printf "${clr}"
}

----

==== `screen-width`

[source,bash]
----
screen-width () 
{ 
    .output.screen-width
}

----

==== `screen.height`

[source,bash]
----
screen.height () 
{ 
    .output.screen-height
}

----

==== `screen.width`

[source,bash]
----
screen.width () 
{ 
    .output.screen-width
}

----

==== `shutdown`

[source,bash]
----
shutdown () 
{ 
    local message=${1:-"Shutting down..."}
    echo
    box.red-in-red "${message}"
    echo
    exit 1
}

----

==== `stderr`

[source,bash]
----
stderr () 
{ 
    local file=$1
    hl.subtle STDERR
    printf "${txtred}"
    [[ -s ${file} ]] && cat ${file}
    reset-color
}

----

==== `stdout`

[source,bash]
----
stdout () 
{ 
    local file=$1
    hl.subtle STDOUT
    printf "${clr}"
    [[ -s ${file} ]] && cat ${file}
    reset-color
}

----

==== `success`

[source,bash]
----
success () 
{ 
    echo
    printf -- "${LibOutput__LeftPrefix}${txtblk}${bakgrn}  « SUCCESS »  ${clr} ${bldwht} ✔  ${bldgrn}$*${clr}" 1>&2
    echo
    echo
}

----

==== `test-group`

[source,bash]
----
test-group () 
{ 
    [[ -z ${white_on_salmon} ]] && hr
    h.salmon "$@"
}

----

==== `ui.closer.kind-of-ok`

[source,bash]
----
ui.closer.kind-of-ok () 
{ 
    .output.cursor-left-by 1000
    printf " ${bakylw}${bldwht} ❖ ${clr} "
}

----

==== `ui.closer.kind-of-ok:`

[source,bash]
----
ui.closer.kind-of-ok: () 
{ 
    ui.closer.kind-of-ok $@
    echo
}

----

==== `ui.closer.not-ok`

[source,bash]
----
ui.closer.not-ok () 
{ 
    .output.cursor-left-by 1000
    printf " ${bakred}${bldwht} ✘ ${clr} "
}

----

==== `ui.closer.not-ok:`

[source,bash]
----
ui.closer.not-ok: () 
{ 
    ui.closer.not-ok $@
    echo
}

----

==== `ui.closer.ok`

[source,bash]
----
ui.closer.ok () 
{ 
    .output.cursor-left-by 1000
    printf " ${txtblk}${bakgrn} ✔︎ ${clr} "
}

----

==== `ui.closer.ok:`

[source,bash]
----
ui.closer.ok: () 
{ 
    ui.closer.ok "$@"
    echo
}

----

==== `warn`

[source,bash]
----
warn () 
{ 
    printf -- "${LibOutput__LeftPrefix}${bldwht}${bakylw} « WARNING! » ${clr} ${bldylw}$*${clr}" 1>&2
}

----

==== `warning`

[source,bash]
----
warning () 
{ 
    header=$(printf -- "${txtblk}${bakylw} « WARNING » ${clr}")
    local first="$1"
    shift
    box.yellow-in-yellow "${header} ${bldylw}$first" "$@" 1>&2
}

----

==== `warning:`

[source,bash]
----
warning: () 
{ 
    warn $*
    ui.closer.kind-of-ok:
}

----


=== Module `pdf`

==== `pdf.combine`

[source,bash]
----
pdf.combine () 
{ 
    local merged="${1}"
    shift
    local files=""
    for f in "$@"
    do
        [[ -f "${f}" ]] && { 
            info "Appending file ${bldylw}${f}"
            files="${files} '${f}'"
        }
    done
    [[ -s "${merged}" ]] && { 
        warning "Merged file ${merged} already exists, removing..."
        run "rm -f \"${merged}\""
    }
    unalias gs 2> /dev/null
    [[ -n $(command -V gs) ]] || brew.install.package gs
    run "mkdir -p $(dirname "${merged}")"
    info "Please wait while GhostScript combines your PDFs into"
    info "destination file: ${bldylw}${merged}"
    run "gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=${merged} ${files}"
    return ${LibRun__LastExitCode}
}

----


=== Module `pids`

==== `pall`

[source,bash]
----
pall () 
{ 
    pids.all "$@"
}

----

==== `pid.alive`

[source,bash]
----
pid.alive () 
{ 
    local pid="$1"
    util.is-numeric || { 
        error "First argument to pid.alive must be numeric."
        return 1
    }
    [[ -n "${pid}" && -n $(ps -p "${pid}" | grep -v TTY) ]]
}

----

==== `pid.sig`

[source,bash]
----
pid.sig () 
{ 
    local pid="${1}"
    shift
    local signal="${1}"
    shift
    [[ -z "${pid}" || -z "${signal}" ]] && { 
        printf "
USAGE:
  pid.sig pid signal
"
        return 1
    }
    util.is-numeric ${pid} || { 
        error "First argument to pid.sig must be numeric."
        return 1
    }
    util.is-numeric ${signal} || sig.is-valid ${signal} || { 
        error "First argument to pid.sig must be numeric."
        return 1
    }
    if pid.alive ${pid}; then
        info "sending ${bldred}${signal}$(txt-info) to ${bldylw}${pid}..."
        /bin/kill -s ${signal} ${pid} 2>&1 | cat > /dev/null
    else
        warning "pid ${pid} was dead by the time we tried sending ${sig} to it."
        return 1
    fi
}

----

==== `pid.stop`

[source,bash]
----
pid.stop () 
{ 
    local pid=${1}
    shift
    local delay=${1:-"0.3"}
    shift
    if [[ -z ${pid} ]]; then
        printf "
DESCRIPTION:
  If the given PID is active, first sends kill -TERM, waits a bit,
  then sends kill -9.

USAGE:
  ${bldgrn}pid.stop pid${clr}

EXAMPLES:
  # stop all sidekiqs, waiting half a sec in between
  ${bldgrn}pid.stop sidekiq 0.5${clr}
"
        return 1
    fi
    pid.alive "${pid}" && ( pid.sig "${pid}" "TERM" || true ) && sleep ${delay}
    pid.alive "${pid}" && pid.sig "${pid}" "KILL"
}

----

==== `pid.stop-and-kill`

[source,bash]
----
pid.stop-and-kill () 
{ 
    local pid="$1"
    delta=1
    sig=STOP
    while true; do
        pid.alive $pid || return 0
        kill -${sig} ${pid} 2>&1 > /dev/null
        delta=$((delta * 2))
        [[ ${delta} -gt 16 ]] && sig="KILL"
        sleep "0.${delta}"
    done
    pid.alive $pid && { 
        error "PID ${pid} is miraculously still alive..." 1>&2
        return 1
    }
}

----

==== `pids-with-args`

[source,bash]
----
pids-with-args () 
{ 
    local -a permitted=("%cpu" "%mem" acflag acflg args blocked caught comm command cpu cputime etime f flags gid group ignored inblk inblock jobc ktrace ktracep lim login logname lstart majflt minflt msgrcv msgsnd ni nice nivcsw nsignals nsigs nswap nvcsw nwchan oublk oublock p_ru paddr pagein pcpu pending pgid pid pmem ppid pri pstime putime re rgid rgroup rss ruid ruser sess sig sigmask sl start stat state stime svgid svuid tdev time tpgid tsess tsiz tt tty ucomm uid upr user usrpri utime vsize vsz wchan wq wqb wql wqr xstat)
    local -a additional=()
    local -a matching=()
    for arg in $@
    do
        array.includes "${arg}" "${permitted[@]}" && additional=(${additional[@]} $arg) && continue
        matching=("${matching[@]}" "${arg}")
    done
    local columns="pid,ppid,user,%cpu,%mem,command"
    if [[ ${#additional[@]} -gt 0 ]]; then
        columns="${columns},$(array.join ',' "${additional[@]}")"
    fi
    pids.matching.regexp "${matching[*]}" | xargs /bin/ps -www -o"${columns}" -p
}

----

==== `pids.all`

[source,bash]
----
pids.all () 
{ 
    if [[ -z "${1}" ]]; then
        printf "
DESCRIPTION:
  prints processes matching a given pattern

USAGE:
  ${bldgrn}pids.all pattern${clr}

EXAMPLES:
  ${bldgrn}pids.all puma${clr}
"
        return 0
    fi
    local pattern="$(pids.normalize.search-string "$1")"
    shift
    ps -ef | ${GrepCommand} "${pattern}" | ${GrepCommand} -v grep
}

----

==== `pids.for-each`

[source,bash]
----
pids.for-each () 
{ 
    if [[ -z "${1}" || -z "${2}" ]]; then
        printf "
DESCRIPTION:
  loops over matching PIDs and calls a named BASH function

USAGE:
  ${bldgrn}pids.for-each pattern function${clr}

EXAMPLES:
  ${bldgrn}pids.for-each puma echo
  function hup() { kill -HUP \$1; }; pids.for-each sidekiq hup${clr}
"
        return 0
    fi
    local pattern="$(pids.normalize.search-string "$1")"
    shift
    local func=${1:-"echo"}
    if [[ -z $(which ${func}) && -z $(type ${func} 2>/dev/null) ]]; then
        errror "Function ${func} does not exist."
        return 1
    fi
    while true; do
        local -a pids=($(pids.matching "${pattern}"))
        [[ ${#pids[@]} == 0 ]] && break
        eval "${func} ${pids[0]}"
        sleep 0.1
    done
}

----

==== `pids.matching`

[source,bash]
----
pids.matching () 
{ 
    local pattern="${1}"
    if [[ -z "${pattern}" ]]; then
        printf "
DESCRIPTION:
  Finds process IDs matching a given string.

USAGE:
  ${bldgrn}pids.matching string${clr}

EXAMPLES:
  ${bldgrn}pids.matching sidekiq${clr}
"
        return 0
    fi
    pattern="$(pids.normalize.search-string ${pattern})"
    pids.matching.regexp "${pattern}"
}

----

==== `pids.matching.regexp`

[source,bash]
----
pids.matching.regexp () 
{ 
    local pattern="${1}"
    if [[ -z "${pattern}" ]]; then
        printf "
DESCRIPTION:
  Finds process IDs matching a given regexp.

USAGE:
  ${bldgrn}pids.matching regular-expression${clr}

EXAMPLES:
  ${bldgrn}pids.matching '[s]idekiq\s+' ${clr}
"
        return 0
    fi
    ps -ef | ${GrepCommand} "${pattern}" | ${GrepCommand} -v grep | awk '{print $2}' | sort -n
}

----

==== `pids.normalize.search-string`

[source,bash]
----
pids.normalize.search-string () 
{ 
    local pattern="$*"
    [[ "${pattern:0:1}" == '[' ]] || pattern="[${pattern:0:1}]${pattern:1}"
    printf "${pattern}"
}

----

==== `pids.stop`

[source,bash]
----
pids.stop () 
{ 
    if [[ -z "${1}" ]]; then
        printf "
DESCRIPTION:
  finds and stops IDs matching a given pattern

USAGE:
  ${bldgrn}pids.stop <pattern>${clr}

EXAMPLES:
  ${bldgrn}pids.stop puma${clr}
"
        return 0
    fi
    pids.for-each "${1}" "pid.stop"
}

----

==== `pstop`

[source,bash]
----
pstop () 
{ 
    pids.stop "$@"
}

----

==== `sig.is-valid`

[source,bash]
----
sig.is-valid () 
{ 
    [[ -n $(kill -l ${1} 2>/dev/null) ]]
}

----

==== `sig.list`

[source,bash]
----
sig.list () 
{ 
    /bin/kill -l | sed -E 's/([ 0-9][0-9]\) SIG)//g; s/\s+/\n/g' | tr 'a-z' 'A-Z' | sort
}

----


=== Module `pipe`

==== `pipe.extract-variables`

[source,bash]
----
pipe.extract-variables () 
{ 
    sedx '/^\(\s*\)#.*$/D; /^\s*$/D; /^[^A-Z].*$/D' | sedx 's/export //ig' | cut -d '=' -f 1
}

----

==== `pipe.remove-blank-lines`

[source,bash]
----
pipe.remove-blank-lines () 
{ 
    sedx '/^$/D'
}

----

==== `pipe.remove-hash-comments`

[source,bash]
----
pipe.remove-hash-comments () 
{ 
    sedx '/^\(\s*\)?#.*$/D; s/#.*$//g;'
}

----


=== Module `progress-bar`

==== `progress.bar.auto-run`

[source,bash]
----
progress.bar.auto-run () 
{ 
    .progress.reset
    .progress.bar "$@"
    code=$?
    if [[ ${code} -ne 0 ]]; then
        .progress.reset
        return 1
    fi
    return 0
}

----

==== `progress.bar.config`

[source,bash]
----
progress.bar.config () 
{ 
    while true; do
        local setting="$1"
        shift
        [[ -z ${setting} ]] && break
        local key=${setting/=*/}
        local value=${setting/*=/}
        eval "export LibProgress__${key}=\"${value}\""
    done
}

----

==== `progress.bar.configure.color-green`

[source,bash]
----
progress.bar.configure.color-green () 
{ 
    progress.bar.config BarColor=${bldgrn}
}

----

==== `progress.bar.configure.color-red`

[source,bash]
----
progress.bar.configure.color-red () 
{ 
    progress.bar.config BarColor=${bldred}
}

----

==== `progress.bar.configure.color-yellow`

[source,bash]
----
progress.bar.configure.color-yellow () 
{ 
    progress.bar.config BarColor=${bldylw}
}

----

==== `progress.bar.configure.symbol-arrow`

[source,bash]
----
progress.bar.configure.symbol-arrow () 
{ 
    progress.bar.config BarChar="❯"
}

----

==== `progress.bar.configure.symbol-bar`

[source,bash]
----
progress.bar.configure.symbol-bar () 
{ 
    progress.bar.config BarChar="█"
}

----

==== `progress.bar.configure.symbol-block`

[source,bash]
----
progress.bar.configure.symbol-block () 
{ 
    progress.bar.config BarChar="${LibProgress__BarChar__Default}"
}

----

==== `progress.bar.configure.symbol-square`

[source,bash]
----
progress.bar.configure.symbol-square () 
{ 
    progress.bar.config BarChar="◼︎"
}

----

==== `progress.bar.launch-and-wait`

[source,bash]
----
progress.bar.launch-and-wait () 
{ 
    local command="$*"
    run.print-command "${command}\n"
    ${command} > /dev/null 2>&1 & local pid=$!
    info "Waiting for background process to finish; PID=${bldylw}${pid}"
    set -e
    while .progress.bar.check-pid-alive $pid; do
        progress.bar.auto-run 0.5 10
    done
    set +e
    return 0
}

----


=== Module `repositories`

==== `repo.rebase`

[source,bash]
----
repo.rebase () 
{ 
    run "git pull origin master --rebase"
}

----

==== `repo.stash-and-rebase`

[source,bash]
----
repo.stash-and-rebase () 
{ 
    run "git stash >/dev/null"
    run "git reset --hard"
    repo.rebase
}

----

==== `repo.update`

[source,bash]
----
repo.update () 
{ 
    local folder="$1"
    h2 "Entering repo ► ${bldgren}${folder}"
    [[ -d "${folder}" ]] || return 1
    [[ -d "${folder}/.git" ]] || return 1
    [[ "$(pwd)" != "${folder}" ]] && { 
        cd "${folder}" || return 2
    }
    if [[ -z "$(git status -s)" ]]; then
        repo.rebase
    else
        repo.stash-and-rebase
    fi
}

----

==== `repos.catch-interrupt`

[source,bash]
----
repos.catch-interrupt () 
{ 
    export LibRepo__Interrupted=true
}

----

==== `repos.init-interrupt`

[source,bash]
----
repos.init-interrupt () 
{ 
    export LibRepo__Interrupted=false
    trap 'repos.catch-interrupt' SIGINT
}

----

==== `repos.recursive-update`

[source,bash]
----
repos.recursive-update () 
{ 
    local repo="${1}"
    run.set-all show-output-off
    if [[ ${LibRepo__Interrupted} == true ]]; then
        warn "Detected SINGINT, exiting..."
        return 2
    fi
    if [[ -n "$repo" ]]; then
        repo.update "$repo"
    else
        for dir in $(find . -type d -name '.git')
        do
            local subdir=$(dirname "$dir")
            [[ -n "${DEBUG}" ]] && info "checking out sub-folder ${bldcyn}${subdir}..."
            repos.recursive-update "${subdir}"
            if [[ $? -eq 2 ]]; then
                error "folder ${bldylw}${subdir}${bldred} return error!"
                return 2
            fi
        done
    fi
    if [[ -n ${repo} ]]; then
        info "returning to the root dir ${bldylw}${root_folder}..."
        cd "${root_folder}" > /dev/null || return 2
    fi
}

----

==== `repos.update`

[source,bash]
----
repos.update () 
{ 
    export root_folder="$(pwd)"
    bash -c "
    [[ -d ~/.bashmatic ]] || {
      echo 'Can not find bashmatic installation sorry'
      return
    }
    source ~/.bashmatic/init.sh
    repos.init-interrupt
    repos.recursive-update '$*'
  "
}

----

==== `repos.was-interrupted`

[source,bash]
----
repos.was-interrupted () 
{ 
    [[ ${LibRepo__Interrupted} == true ]]
}

----


=== Module `ruby`

==== `bundle.gems-with-c-extensions`

[source,bash]
----
bundle.gems-with-c-extensions () 
{ 
    run.set-next show-output-on
    run "bundle show --paths | ruby -e \"STDIN.each_line {|dep| puts dep.split('/').last if File.directory?(File.join(dep.chomp, 'ext')) }\""
}

----

==== `interrupted`

[source,bash]
----
interrupted () 
{ 
    export BashMatic__Interrupted=true
}

----

==== `ruby.bundle-install`

[source,bash]
----
ruby.bundle-install () 
{ 
    if [[ -f Gemfile.lock ]]; then
        run "bundle install"
    fi
}

----

==== `ruby.bundler-version`

[source,bash]
----
ruby.bundler-version () 
{ 
    if [[ ! -f Gemfile.lock ]]; then
        error "Can not find Gemfile.lock"
        return 1
    fi
    tail -1 Gemfile.lock | sedx 's/ //g'
}

----

==== `ruby.compiled-with`

[source,bash]
----
ruby.compiled-with () 
{ 
    if [[ -z "$*" ]]; then
        error "usage: ruby.compiled-with <library>"
        return 1
    fi
    ruby -r rbconfig -e "puts RbConfig.CONFIG['LIBS']" | grep -q "$*"
}

----

==== `ruby.default-gems`

[source,bash]
----
ruby.default-gems () 
{ 
    declare -a DEFAULT_RUBY_GEMS=(bundler rubocop relaxed-rubocop rubocop-performance warp-dir colored2 sym pry pry-doc pry-byebug rspec rspec-its awesome_print activesupport pivotal_git_scripts git-smart travis awscli irbtools kramdown-asciidoc asciidoctor kramdown gemsmith rspec rspec-its)
    export DEFAULT_RUBY_GEMS
    printf "${DEFAULT_RUBY_GEMS[*]}"
}

----

==== `ruby.ensure-rbenv`

[source,bash]
----
ruby.ensure-rbenv () 
{ 
    [[ -n $(command -v rbenv) ]] && return 0
    brew.install
    brew.install.package rbenv ruby-build
    grep -q "rbenv init" ~/.bash_profile && echo 'eval "$(rbenv init -)"' >> ~/.bash_profile
    [[ -n $(command -V rbenv) ]] && return 0
    return 1
}

----

==== `ruby.ensure-rbenv-or-complain`

[source,bash]
----
ruby.ensure-rbenv-or-complain () 
{ 
    ruby.ensure-rbenv || { 
        error "Can't install rbenv via HomeBrew, please try manually."
        return 1
    }
    return 0
}

----

==== `ruby.full-version`

[source,bash]
----
ruby.full-version () 
{ 
    /usr/bin/env ruby --version
}

----

==== `ruby.gemfile-lock-version`

[source,bash]
----
ruby.gemfile-lock-version () 
{ 
    local gem=${1}
    if [[ ! -f Gemfile.lock ]]; then
        error "Can not find Gemfile.lock"
        return 1
    fi
    ${GrepCommand} " ${gem} \([0-9]" Gemfile.lock | sed -e 's/[\(\)]//g' | awk '{print $2}'
}

----

==== `ruby.gems`

[source,bash]
----
ruby.gems () 
{ 
    ruby.gems.install "$@"
}

----

==== `ruby.gems.install`

[source,bash]
----
ruby.gems.install () 
{ 
    local -a gems=($@)
    gem.clear-cache
    [[ ${#gems[@]} -eq 0 ]] && gems=($(ruby.default-gems))
    local -a existing=($(ruby.installed-gems))
    [[ ${#gems[@]} -eq 0 ]] && { 
        error 'Unable to determine what gems to install. ' "Argument is empty, so is ${DEFAULT_RUBY_GEMS[@]}" "USAGE: ${bldgrn}ruby.gems ${bldred} rails rubocop puma pry"
        return 1
    }
    h2 "There are a total of ${#existing[@]} of globally installed Gems." "Total of ${#gems[@]} need to be installed unless they already exist. " "${bldylw}Checking for gems that still missing..."
    local -a gems_to_be_installed=()
    for gem in "${gems[@]}"
    do
        local gem_info=
        if [[ $(array.has-element "${gem}" "${existing[@]}") == "true" ]]; then
            gem_info="${bldgrn} ✔  ${gem}${clr}\n"
        else
            gem_info="${bldred} x  ${gem}${clr}\n"
            gems_to_be_installed=(${gems_to_be_installed[@]} ${gem})
        fi
        printf "   ${gem_info}"
    done
    if [[ ${#gems_to_be_installed[@]} -eq 0 ]]; then
        info "All gems are already installed. 👍🏼"
        return 0
    fi
    info "Looks like ${#gems_to_be_installed[@]} gems are left to install..."
    local -a gems_installed=()
    for gem in ${gems_to_be_installed[@]}
    do
        run "gem install -q --force --no-document $gem"
        if [[ ${LibRun__LastExitCode} -ne 0 ]]; then
            error "Gem ${gem} refuses to install." "Perhaps try installing it manually?" "${bldgrn}Action: Skip and Continuing..."
            break
        else
            gem_installed=(${gem_installed[@]} ${gem})
            continue
        fi
    done
    gem.clear-cache
    info "Total of ${#gem_installed[@]} gems were installed."
    echo
}

----

==== `ruby.gems.uninstall`

[source,bash]
----
ruby.gems.uninstall () 
{ 
    local -a gems=($@)
    gem.clear-cache
    [[ ${#gems[@]} -eq 0 ]] && declare -a gems=($(ruby.default-gems))
    local -a existing=($(ruby.installed-gems))
    [[ ${#gems[@]} -eq 0 ]] && { 
        error "Unable to determine what gems to remove. Argument is empty, so is ${DEFAULT_RUBY_GEMS[@]}" "USAGE: ${bldgrn}ruby.gems.uninstall ${bldred} rails rubocop puma pry"
        return 1
    }
    h1.blue "There are a total of ${#existing[@]} of gems installed in a global namespace." "Total of ${#gems[@]} need to be removed."
    local deleted=0
    for gem in ${gems[@]}
    do
        local gem_info=
        if [[ $(array.has-element "${gem}" "${existing[@]}") == "true" ]]; then
            run "gem uninstall -a -x -I -D --force ${gem}"
            deleted=$(($deleted + 1))
        else
            gem_info="${bldred} x [not found] ${bldylw}${gem}${clr}\n"
        fi
        printf "   ${gem_info}"
    done
    gem.clear-cache
    echo
    success "Total of ${deleted} gems were successfully obliterated."
    echo
}

----

==== `ruby.init`

[source,bash]
----
ruby.init () 
{ 
    h1 "Installing Critical Gems for Your Glove, Thanos..."
    ruby.rubygems-update
    ruby.install-upgrade-bundler
    ruby.gems.install
    ruby.kigs-gems
}

----

==== `ruby.install`

[source,bash]
----
ruby.install () 
{ 
    ruby.install-ruby "$@"
}

----

==== `ruby.install-ruby`

[source,bash]
----
ruby.install-ruby () 
{ 
    local version="$1"
    shift
    local version_source="provided as an argument"
    if [[ -z ${version} && -f .ruby-version ]]; then
        version="$(cat .ruby-version | tr -d '\n')"
        version_source="auto-detected from .ruby-version file"
    fi
    [[ -z ${version} ]] && { 
        error "USAGE: ruby.install-ruby VERSION" "Or, you can create a local .ruby-version file"
        return 1
    }
    local -a required_packages
    required_packages=(rbenv ruby-build)
    h3 "Installing Ruby Version ${bldpur}${version} ${bldblu}${version_source}."
    ruby.validate-version "${version}" || return 1
    brew.install.packages "${required_packages[@]}"
    brew.upgrade.packages "${required_packages[@]}"
    if [[ -n "$*" ]]; then
        info "Attemping to install additional packages via Brew:"
        for package in "$@"
        do
            run.set-next abort-on-error
            brew.install.package "${package}"
            local func=".ruby.configure-with.${package}"
            util.is-a-function "${func}" && ${func}
        done
    fi
    eval "$(rbenv init -)"
    h2 "RUBY_CONFIGURE_OPTS: ${bldgrn}${RUBY_CONFIGURE_OPTS}"
    run "RUBY_CONFIGURE_OPTS=\"${RUBY_CONFIGURE_OPTS}\" rbenv install -s ${version}"
    return "${LibRun__LastExitCode:-"0"}"
}

----

==== `ruby.install-ruby-with-deps`

[source,bash]
----
ruby.install-ruby-with-deps () 
{ 
    local version="$1"
    declare -a packages=(cask bash bash-completion git go haproxy htop jemalloc libxslt jq libiconv libzip netcat nginx openssl pcre pstree p7zip rbenv redis ruby_build readline tree vim watch wget zlib)
    run.set-next show-output-on
    run "brew install --display-times ${packages[*]}"
}

----

==== `ruby.install-ruby-with-readline-and-openssl`

[source,bash]
----
ruby.install-ruby-with-readline-and-openssl () 
{ 
    local version="$1"
    [[ -z ${version} ]] && { 
        error "usage: ruby.install-ruby-with-readline-and-openssl ruby-version"
        return 1
    }
    shift
    ruby.install-ruby ${version} openssl readline "$@"
}

----

==== `ruby.install-upgrade-bundler`

[source,bash]
----
ruby.install-upgrade-bundler () 
{ 
    gem.install bundler
    run "bundle --update bundler || true"
}

----

==== `ruby.installed-gems`

[source,bash]
----
ruby.installed-gems () 
{ 
    gem list | cut -d ' ' -f 1 | uniq
}

----

==== `ruby.kigs-gems`

[source,bash]
----
ruby.kigs-gems () 
{ 
    if [[ -z $(type wd 2>/dev/null) && -n $(command -v warp-dir) ]]; then
        [[ -f ~/.bash_wd ]] || { 
            warp-dir install --dotfile ~/.bashrc > /dev/null
            source ~/.bash_wd
        }
    fi
    [[ -n $(command -v sym) ]] && { 
        [[ -f ~/.sym.completion.bash ]] || { 
            sym -B ~/.bashrc
        }
    }
}

----

==== `ruby.linked-libs`

[source,bash]
----
ruby.linked-libs () 
{ 
    ruby -r rbconfig -e "puts RbConfig.CONFIG['LIBS']"
}

----

==== `ruby.numeric-version`

[source,bash]
----
ruby.numeric-version () 
{ 
    /usr/bin/env ruby --version | sed 's/^ruby //g; s/ (.*//g'
}

----

==== `ruby.rbenv`

[source,bash]
----
ruby.rbenv () 
{ 
    ruby.ensure-rbenv-or-complain || return 1
    if [[ -n "$*" ]]; then
        rbenv $*
    else
        eval "$(rbenv init -)"
    fi
    run "rbenv rehash"
}

----

==== `ruby.rubygems-update`

[source,bash]
----
ruby.rubygems-update () 
{ 
    info "Updating RubyGems..."
    run.set-next show-output-on
    run "gem update --system"
    gem.clear-cache
}

----

==== `ruby.stop`

[source,bash]
----
ruby.stop () 
{ 
    local regex='/[r]uby| [p]uma| [i]rb| [r]ails | [b]undle| [u]nicorn| [r]ake'
    local procs=$(ps -ef | ${GrepCommand} "${regex}" | ${GrepCommand} -v grep | awk '{print $2}' | sort | uniq | wc -l)
    [[ ${procs} -eq 0 ]] && { 
        info: "No ruby processes were found."
        return 0
    }
    local -a pids=$(ps -ef | ${GrepCommand} "${regex}" | ${GrepCommand} -v grep | awk '{print $2}' | sort | uniq | tr '\n' ' -p ')
    h2 "Detected ${#pids[@]} Ruby Processes..., here is the tree:"
    printf "${txtcyn}"
    pstree ${pids[*]}
    printf "${clr}"
    hr
    printf "To abort, press Ctrl-C. To kill them all press any key.."
    run.ui.press-any-key
    ps -ef | ${GrepCommand} "${regex}" | ${GrepCommand} -v grep | awk '{print $2}' | sort | uniq | xargs kill -9
}

----

==== `ruby.top-versions`

[source,bash]
----
ruby.top-versions () 
{ 
    local platform="${1:-"2\."}"
    local arg="$(.ruby.ruby-build.list-argument)"
    rbenv install ${arg} | ${GrepCommand} "^${platform}" | ruby -e '
      last_v = nil
      last_m = nil
      ARGF.each do |line|
        v = line.split(".")[0..1].join(".")
        if last_v != v
          puts last_m if last_m
          last_v = v
        end
        last_m = line
      end
      puts last_m if last_m'
}

----

==== `ruby.top-versions-as-yaml`

[source,bash]
----
ruby.top-versions-as-yaml () 
{ 
    ruby.top-versions | sed 's/^/ - /g'
}

----

==== `ruby.validate-version`

[source,bash]
----
ruby.validate-version () 
{ 
    local version="$1"
    local -a ruby_versions=()
    run "brew upgrade ruby-build || true"
    [[ -d ~/.rbenv/plugins/ruby-build ]] && { 
        run "cd ~/.rbenv/plugins/ruby-build && git reset --hard && git pull --rebase"
    }
    local arg="$(.ruby.ruby-build.list-argument)"
    array.from.stdin ruby_versions "rbenv install ${arg} | sed -E \"s/\s+//g\""
    inf "Validating ruby version: ${version}"
    array.includes "${version}" "${ruby_versions[@]}" || { 
        not-ok:
        error "Ruby Version provided was NOT found by rbenv: ${bldylw}${version}" "Found a total of ${bldgrn}${#ruby_versions[*]} ruby versions."
        return 1
    }
    ok:
    return 0
}

----


=== Module `run`

==== `run`

[source,bash]
----
run () 
{ 
    .run "$@"
    return ${LibRun__LastExitCode}
}

----

==== `run.ui.ask`

[source,bash]
----
run.ui.ask () 
{ 
    local question=$*
    local func="${LibRun__AskDeclineFunction}"
    export LibRun__AskDeclineFunction="${LibRun__AskDeclineFunction__Default}"
    echo
    inf "${bldcyn}${question}${clr} [Y/n] ${bldylw}"
    read a 2> /dev/null
    code=$?
    if [[ ${code} != 0 ]]; then
        error "Unable to read from STDIN."
        eval "${func} 12"
    fi
    echo
    if [[ ${a} == 'y' || ${a} == 'Y' || ${a} == '' ]]; then
        info "${bldblu}Roger that."
        info "Let's just hope it won't go nuclear on us :) 💥"
        hr
        echo
    else
        info "${bldred}(Great idea!) Abort! Abandon ship!  🛳   "
        hr
        echo
        eval "${func} 1"
    fi
}

----

==== `run.ui.ask-user-value`

[source,bash]
----
run.ui.ask-user-value () 
{ 
    local variable="$1"
    shift
    local text="$*"
    local user_input
    trap 'echo; echo Aborting at user request... ; echo; abort; return' int
    ask "${text}"
    read user_input
    if [[ -z "${user_input}" ]]; then
        error "Sorry, I didn't get that. Please try again or press Ctrl-C to abort."
        return 1
    else
        eval "export ${variable}=\"${user_input}\""
        return 0
    fi
}

----

==== `run.ui.get-user-value`

[source,bash]
----
run.ui.get-user-value () 
{ 
    run.ui.retry-command run.ui.ask-user-value "${@}"
}

----

==== `run.ui.press-any-key`

[source,bash]
----
run.ui.press-any-key () 
{ 
    local prompt="$*"
    [[ -z ${prompt} ]] && prompt="Press any key to continue..."
    br
    printf "    ${txtgrn}${italic}${prompt} ${clr}  "
    read -r -s -n1 key
    cursor.rewind
    printf "                                                           "
    cursor.up 2
    cursor.rewind
    echo
}

----

==== `run.ui.retry-command`

[source,bash]
----
run.ui.retry-command () 
{ 
    local command="$*"
    local retries=5
    n=0
    until [ $n -ge ${retries} ]; do
        [[ ${n} -gt 0 ]] && info "Retry number ${n}..."
        command && break
        n=$(($n + 1))
        sleep 1
    done
}

----


=== Module `runtime`

==== `run`

[source,bash]
----
run () 
{ 
    .run "$@"
    return ${LibRun__LastExitCode}
}

----

==== `run.config.detail-is-enabled`

[source,bash]
----
run.config.detail-is-enabled () 
{ 
    [[ ${LibRun__Detail} -eq ${True} ]]
}

----

==== `run.config.is-dry-run`

[source,bash]
----
run.config.is-dry-run () 
{ 
    [[ ${LibRun__DryRun} -eq ${True} ]]
}

----

==== `run.config.verbose-is-enabled`

[source,bash]
----
run.config.verbose-is-enabled () 
{ 
    [[ ${LibRun__Verbose} -eq ${True} ]]
}

----

==== `run.dry-run-prefix`

[source,bash]
----
run.dry-run-prefix () 
{ 
    if [[ ${LibRun__DryRun} == ${True} ]]; then
        printf "${txtcyn}${italic}« dry run »${clr} "
    fi
}

----

==== `run.inspect`

[source,bash]
----
run.inspect () 
{ 
    if [[ ${#@} -eq 0 || $(array.has-element "config" "$@") == "true" ]]; then
        run.inspect-variables-that-are starting-with LibRun
    fi
    if [[ ${#@} -eq 0 || $(array.has-element "totals" "$@") == "true" ]]; then
        hl.subtle "TOTALS"
        info "${bldgrn}${commands_completed} commands completed successfully"
        [[ ${commands_failed} -gt 0 ]] && info "${bldred}${commands_failed} commands failed"
        [[ ${commands_ignored} -gt 0 ]] && info "${bldylw}${commands_ignored} commands failed, but were ignored."
        echo
    fi
    if [[ ${#@} -eq 0 || $(array.has-element "current" "$@") == "true" ]]; then
        run.inspect-variables-that-are ending-with __LastExitCode
    fi
    reset-color
}

----

==== `run.inspect-variable`

[source,bash]
----
run.inspect-variable () 
{ 
    local var_name=${1}
    local var_value=${!var_name}
    local value=""
    local print_value=
    local max_len=120
    local avail_len=$(($(screen.width) - 45))
    local lcase_var_name="$(echo ${var_name} | tr 'A-Z' 'a-z')"
    local print_value=1
    local color="${bldblu}"
    local value_off=" ✘   "
    local value_check="✔︎"
    if [[ -n "${var_value}" ]]; then
        if [[ ${lcase_var_name} =~ 'exit' ]]; then
            if [[ ${var_value} -eq 0 ]]; then
                value=${value_check}
                color="${bldgrn}"
            else
                print_value=1
                value=${var_value}
                color="${bldred}"
            fi
        else
            if [[ "${var_value}" == "${True}" || "${var_value}" == "1" ]]; then
                value="${value_check}"
                color="${bldgrn}"
            else
                if [[ "${var_value}" == "${False}" || "${var_value}" == "0" ]]; then
                    value="${value_off}"
                    color="${bldred}"
                fi
            fi
        fi
    else
        value="${value_off}"
        color="${bldred}"
    fi
    if [[ ${LibRun__Inspect__SkipFalseOrBlank} -eq ${True} && "${value}" == "${value_off}" ]]; then
        return 0
    fi
    printf "    ${bldylw}%-35s ${txtblk}${color} " ${var_name}
    [[ ${avail_len} -gt ${max_len} ]] && avail_len=${max_len}
    if [[ "${print_value}" -eq 1 ]]; then
        if [[ -n "${value}" ]]; then
            printf "%*.*s" ${avail_len} ${avail_len} "${value}"
        else
            if $(util.is-numeric "${var_value}"); then
                avail_len=$((${avail_len} - 5))
                if [[ "${var_value}" =~ '.' ]]; then
                    printf "%*.2f" ${avail_len} "${var_value}"
                else
                    printf "%*d" ${avail_len} "${var_value}"
                fi
            else
                avail_len=$((${avail_len} - 5))
                printf "%*.*s" ${avail_len} ${avail_len} "${var_value}"
            fi
        fi
    else
        printf "%*.*s" ${avail_len} ${avail_len} "${value}"
    fi
    echo
}

----

==== `run.inspect-variables`

[source,bash]
----
run.inspect-variables () 
{ 
    local title=${1}
    shift
    hl.subtle "${title}"
    for var in $@
    do
        run.inspect-variable "${var}"
    done
}

----

==== `run.inspect-variables-that-are`

[source,bash]
----
run.inspect-variables-that-are () 
{ 
    local pattern_type="${1}"
    local pattern="${2}"
    run.inspect-variables "VARIABLES $(echo ${pattern_type} | tr 'a-z' 'A-Z') ${pattern}" "$(run.variables-${pattern_type} ${pattern} | tr '\n' ' ')"
}

----

==== `run.inspect.set-skip-false-or-blank`

[source,bash]
----
run.inspect.set-skip-false-or-blank () 
{ 
    local value="${1}"
    [[ -n "${value}" ]] && export LibRun__Inspect__SkipFalseOrBlank=${value}
    [[ -z "${value}" ]] && export LibRun__Inspect__SkipFalseOrBlank=${True}
}

----

==== `run.on-error.ask-is-enabled`

[source,bash]
----
run.on-error.ask-is-enabled () 
{ 
    [[ ${LibRun__AskOnError} -eq ${True} ]]
}

----

==== `run.print-command`

[source,bash]
----
run.print-command () 
{ 
    local command="$1"
    local max_width=${2:-"100"}
    local min_width=60
    local w
    w=$(($(.output.screen-width) - 10))
    [[ ${w} -gt ${max_width} ]] && w=${max_width}
    export LibRun__AssignedWidth=${w}
    local prefix="${LibOutput__LeftPrefix}${clr}"
    local ascii_cmd
    local command_prompt="${prefix}❯ "
    local command_width=$((w - 30))
    [[ ${command_width} -lt ${min_width} ]] && command_width=${min_width}
    ascii_cmd="$(printf "${command_prompt}$(run.dry-run-prefix)%-.${command_width}s " "${command:0:${command_width}}")"
    export LibRun__CommandLength=${#ascii_cmd}
    [[ ${LibRun__ShowCommandOutput} -eq ${True} ]] && { 
        export LibRun__AssignedWidth=$((w - 3))
        export LibRun__CommandLength=1
        printf "${prefix}${txtblk}# Command below will be shown with its output:${clr}\n"
    }
    if [[ "${LibRun__ShowCommand}" -eq ${False} ]]; then
        printf "${prefix}❯ ${bldylw}%-.${command_width}s " "$(.output.replicate-to "*" 40)"
    else
        printf "${prefix}❯ ${bldylw}%-.${command_width}s " "${command:0:${command_width}}"
    fi
}

----

==== `run.print-command-full-screen`

[source,bash]
----
run.print-command-full-screen () 
{ 
    run.print-long-command "$1" $(screen.width)
}

----

==== `run.print-long-command`

[source,bash]
----
run.print-long-command () 
{ 
    local command="$1"
    local max_width=${2:-"150"}
    local w
    w=$(($(.output.screen-width) - 10))
    [[ ${w} -gt ${max_width} ]] && w=${max_width}
    export LibRun__AssignedWidth=${w}
    local prefix="${LibOutput__LeftPrefix}${clr}"
    local ascii_cmd
    local command_prompt="${prefix}❯ $(run.dry-run-prefix)"
    local command_width=$((w - 10))
    printf "${prefix}❯ ${bldylw}"
    printf "${command}" | fold -s -w${w} | awk 'NR > 1 {printf "            "}; { printf "%s\n", $0}'
}

----

==== `run.print-variable`

[source,bash]
----
run.print-variable () 
{ 
    run.inspect-variable $1
}

----

==== `run.print-variables`

[source,bash]
----
run.print-variables () 
{ 
    local title=${1}
    shift
    hl.yellow "${title}"
    for var in $@
    do
        run.print-variable "${var}"
    done
}

----

==== `run.ui.press-any-key`

[source,bash]
----
run.ui.press-any-key () 
{ 
    local prompt="$*"
    [[ -z ${prompt} ]] && prompt="Press any key to continue..."
    br
    printf "    ${txtgrn}${italic}${prompt} ${clr}  "
    read -r -s -n1 key
    cursor.rewind
    printf "                                                           "
    cursor.up 2
    cursor.rewind
    echo
}

----

==== `run.variables-ending-with`

[source,bash]
----
run.variables-ending-with () 
{ 
    local suffix="${1}"
    env | grep -E -e ".*${suffix}=.*\$" | grep '=' | sedx 's/=.*//g' | sort
}

----

==== `run.variables-starting-with`

[source,bash]
----
run.variables-starting-with () 
{ 
    local prefix="${1}"
    env | grep -E -e "^${prefix}" | grep '=' | sedx 's/=.*//g' | sort
}

----

==== `run.was-successful`

[source,bash]
----
run.was-successful () 
{ 
    [[ ${LibRun__LastExitCode} -eq 0 ]]
}

----

==== `run.with.minimum-duration`

[source,bash]
----
run.with.minimum-duration () 
{ 
    local min_duration=$1
    shift
    local command="$*"
    local started=$(millis)
    info "starting a command with the minimum duration of ${bldylw}${min_duration} seconds"
    run "${command}"
    local result=$?
    local duration=$((($(millis) - ${started}) / 1000))
    if [[ ${result} -eq 0 && ${duration} -lt ${min_duration} ]]; then
        local cmd="$(echo ${command} | sedx 's/\"//g')"
        error "An operation finished too quickly. The threshold was set to ${bldylw}${min_duration} sec." "The command took ${bldylw}${duration}${txtred} secs." "${bldylw}${cmd}${txtred}"
        ((${BASH_IN_SUBSHELL})) && exit 1 || return 1
    else
        if [[ ${duration} -gt ${min_duration} ]]; then
            info "minimum duration operation ran in ${duration} seconds."
        fi
    fi
    return ${result}
}

----

==== `run.with.ruby-bundle`

[source,bash]
----
run.with.ruby-bundle () 
{ 
    .run.bundle.exec "$@"
}

----

==== `run.with.ruby-bundle-and-output`

[source,bash]
----
run.with.ruby-bundle-and-output () 
{ 
    .run.bundle.exec.with-output "$@"
}

----


=== Module `runtime-config`

==== `run.inspect`

[source,bash]
----
run.inspect () 
{ 
    if [[ ${#@} -eq 0 || $(array.has-element "config" "$@") == "true" ]]; then
        run.inspect-variables-that-are starting-with LibRun
    fi
    if [[ ${#@} -eq 0 || $(array.has-element "totals" "$@") == "true" ]]; then
        hl.subtle "TOTALS"
        info "${bldgrn}${commands_completed} commands completed successfully"
        [[ ${commands_failed} -gt 0 ]] && info "${bldred}${commands_failed} commands failed"
        [[ ${commands_ignored} -gt 0 ]] && info "${bldylw}${commands_ignored} commands failed, but were ignored."
        echo
    fi
    if [[ ${#@} -eq 0 || $(array.has-element "current" "$@") == "true" ]]; then
        run.inspect-variables-that-are ending-with __LastExitCode
    fi
    reset-color
}

----

==== `run.set-all`

[source,bash]
----
run.set-all () 
{ 
    ____run.configure all "$@"
}

----

==== `run.set-all.list`

[source,bash]
----
run.set-all.list () 
{ 
    set | ${GrepCommand} '^____run.set.all' | awk 'BEGIN{FS="."}{print $4}' | sedx 's/[() ]//g'
}

----

==== `run.set-next`

[source,bash]
----
run.set-next () 
{ 
    ____run.configure next "$@"
}

----

==== `run.set-next.list`

[source,bash]
----
run.set-next.list () 
{ 
    set | ${GrepCommand} '^____run.set.next' | awk 'BEGIN{FS="."}{print $4}' | sedx 's/[() ]//g'
}

----


=== Module `set`

==== `set-e-restore`

[source,bash]
----
set-e-restore () 
{ 
    [[ -f ${__bash_set_errexit_status} ]] && { 
        error "You must first save it with the function:s ${bldgrn}set-e-save"
        return 1
    }
    local status=$(cat ${__bash_set_errexit_status} | tr -d '\n')
    if [[ ${status} != 'on' && ${status} != 'off' ]]; then
        error "Invalid data in the set -e tempfile:" "$(cat ${__bash_set_errexit_status})"
        return 1
    fi
    set -o errexit ${status}
    rm -f ${__bash_set_errexit_status} 2> /dev/null
}

----

==== `set-e-save`

[source,bash]
----
set-e-save () 
{ 
    export __bash_set_errexit_status=$(mktemp -t 'errexit')
    rm -f ${__bash_set_errexit_status} 2> /dev/null
    set-e-status > ${__bash_set_errexit_status}
}

----

==== `set-e-status`

[source,bash]
----
set-e-status () 
{ 
    set -o | grep errexit | awk '{print $2}'
}

----


=== Module `settings`


=== Module `shell-set`

==== `save-restore-x`

[source,bash]
----
save-restore-x () 
{ 
    shell-set.pop-stack x
}

----

==== `save-set-x`

[source,bash]
----
save-set-x () 
{ 
    shell-set.push-stack x
}

----

==== `shell-set.init-stack`

[source,bash]
----
shell-set.init-stack () 
{ 
    unset SetOptsStack
    declare -a SetOptsStack=()
    export SetOptsStack
}

----

==== `shell-set.is-set`

[source,bash]
----
shell-set.is-set () 
{ 
    local v="$1"
    local is_set=${-//[^${v}]/}
    if [[ -n ${is_set} ]]; then
        return 0
    else
        return 1
    fi
}

----

==== `shell-set.pop-stack`

[source,bash]
----
shell-set.pop-stack () 
{ 
    local value="$1"
    local len=${#SetOptsStack[@]}
    local last_index=$((len - 1))
    local last=${SetOptsStack[${last_index}]}
    if [[ ${last} != "-${value}" && ${last} != "+${value}" ]]; then
        error "Can not restore ${value}, not the last element in ${SetOptsStack[*]} stack."
        return 1
    fi
    local pop=(${last})
    export SetOptsStack=("${SetOptsStack[@]/$pop/}")
    [[ -n ${DEBUG} ]] && shell-set-show
    eval "set ${last}"
}

----

==== `shell-set.push-stack`

[source,bash]
----
shell-set.push-stack () 
{ 
    local value="$1"
    local is_set=${-//[^${value}]/}
    shell-set.is-set ${value} && export SetOptsStack=(${SetOptsStack[@]} "-${value}")
    shell-set.is-set ${value} || export SetOptsStack=(${SetOptsStack[@]} "+${value}")
    [[ -n ${DEBUG} ]] && shell-set-show
}

----

==== `shell-set.show-stack`

[source,bash]
----
shell-set.show-stack () 
{ 
    info "Current Shell Set Stack: ${bldylw}[${SetOptsStack[*]}]"
}

----


=== Module `ssh`

==== `ssh.keys.generate`

[source,bash]
----
ssh.keys.generate () 
{ 
    local email="$(user.gitconfig.email)"
    [[ -z ${email} ]] && { 
        info "Couldnt' get your email from ~/.gitconfig..."
        run.ui.ask-user-value email "What's the email you'd like to use with this key?"
    }
    local date=$( time.now.db )
    if [[ -f ~/.ssh/id_rsa ]]; then
        warning "There is an existing file ${bldred}~/.ssh/id_rsa"
        info "It will be backed up into ~/.ssh/id_rsa.bak.${date}"
        for file in ~/.ssh/id_rsa ~/.ssh/id_rsa.pub
        do
            [[ -f ${file} ]] && run "mv ${file} ${file}.bak.${date}"
        done
    fi
    run.set-next show-output-on
    run "ssh-keygen -t rsa -b 4096 -C ${email}"
}

----

==== `ssh.load-keys`

[source,bash]
----
ssh.load-keys () 
{ 
    local pattern="$1"
    find ${HOME}/.ssh -type f -name "id_*${pattern}*" -and -not -name '*.pub' -print -exec ssh-add {} \
}

----


=== Module `subshell`

==== `bashmatic.detect-subshell`

[source,bash]
----
bashmatic.detect-subshell () 
{ 
    bashmatic.subshell-init
    [[ -n ${BASH_SUBSHELL_DETECTED} && -n ${BASH_IN_SUBSHELL} ]] && return ${BASH_IN_SUBSHELL}
    unset BASH_IN_SUBSHELL
    export BASH_SUBSHELL_DETECTED=true
    local len="${#BASH_SOURCE[@]}"
    local last_index=$((len - 1))
    [[ -n ${DEBUG} ]] && { 
        echo "BASH_SOURCE[*] = ${BASH_SOURCE[*]}" 1>&2
        echo "BASH_SOURCE[${last_index}] = ${BASH_SOURCE[${last_index}]}" 1>&2
        echo "\$0            = $0" 1>&2
    }
    if [[ -n ${ZSH_EVAL_CONEXT} && ${ZSH_EVAL_CONTEXT} =~ :file$ ]] || [[ -n ${BASH_VERSION} && "$0" != "${BASH_SOURCE[${last_index}]}" ]]; then
        export BASH_IN_SUBSHELL=0
    else
        export BASH_IN_SUBSHELL=1
    fi
    return ${BASH_IN_SUBSHELL}
}

----

==== `bashmatic.subshell-init`

[source,bash]
----
bashmatic.subshell-init () 
{ 
    export BASH_SUBSHELL_DETECTED=
}

----

==== `bashmatic.validate-sourced-in`

[source,bash]
----
bashmatic.validate-sourced-in () 
{ 
    bashmatic.detect-subshell
    [[ ${BASH_IN_SUBSHELL} -eq 0 ]] || { 
        echo "This script to be sourced in, not run in a subshell." 1>&2
        return 1
    }
    return 0
}

----

==== `bashmatic.validate-subshell`

[source,bash]
----
bashmatic.validate-subshell () 
{ 
    bashmatic.detect-subshell
    [[ ${BASH_IN_SUBSHELL} -eq 1 ]] || { 
        echo "This script to be run, not sourced-in" 1>&2
        return 1
    }
    return 0
}

----


=== Module `sym`

==== `decrypt.secrets`

[source,bash]
----
decrypt.secrets () 
{ 
    ./bin/decrypt
    local code=$?
    [[ ${code} != 0 ]] && { 
        error "bin/decrypt returned non-zero exit status ${code}"
        echo
        exit ${code}
    }
}

----

==== `dev.crypt.chef`

[source,bash]
----
dev.crypt.chef () 
{ 
    sym -ck APP_CHEF_SYM_KEY $*
}

----

==== `dev.decrypt.file`

[source,bash]
----
dev.decrypt.file () 
{ 
    [[ -f ${1} ]] || { 
        error 'usage: dev.decrypt.file <filename.enc>'
        return
    }
    sym -ck APP_SYM_KEY -n "${1}"
}

----

==== `dev.decrypt.str`

[source,bash]
----
dev.decrypt.str () 
{ 
    [[ -z ${1} ]] && { 
        error 'usage: dev.decrypt.str "string to decrypt"'
        return
    }
    sym -ck APP_SYM_KEY -d -s "$*"
}

----

==== `dev.edit.file`

[source,bash]
----
dev.edit.file () 
{ 
    [[ -f ${1} ]] || { 
        error 'usage: dev.edit.file <filename>'
        return
    }
    sym -ck APP_SYM_KEY -t "${1}"
}

----

==== `dev.encrypt.file`

[source,bash]
----
dev.encrypt.file () 
{ 
    [[ -f ${1} ]] || { 
        error 'usage: dev.encrypt.file <filename>'
        return
    }
    sym -ck APP_SYM_KEY -e -f "${1}" -o "${1}.enc"
}

----

==== `dev.encrypt.str`

[source,bash]
----
dev.encrypt.str () 
{ 
    [[ -z "${1}" ]] && { 
        error 'usage: dev.encrypt.str "string to encrypt"'
        return
    }
    sym -ck APP_SYM_KEY -e -s "$*"
}

----

==== `dev.sym`

[source,bash]
----
dev.sym () 
{ 
    sym -cqk APP_SYM_KEY $*
}

----

==== `sym.dev.configure`

[source,bash]
----
sym.dev.configure () 
{ 
    export SYMIT__KEY="APP_SYM_KEY"
}

----

==== `sym.dev.files`

[source,bash]
----
sym.dev.files () 
{ 
    find . -name '*.enc' -type f
}

----

==== `sym.dev.have-key`

[source,bash]
----
sym.dev.have-key () 
{ 
    sym.dev.configure
    if [[ -z ${CI} ]]; then
        [[ -z "$(keychain ${SYMIT__KEY} find 2>/dev/null)" ]] || printf "yes"
    else
        [[ -n "${APP_SYM_KEY}" ]] && print "yes"
    fi
}

----

==== `sym.dev.import`

[source,bash]
----
sym.dev.import () 
{ 
    local skip_instructions=${1:-0}
    if [[ ${AppCurrentOS} != 'Darwin' ]]; then
        error 'This is only meant to run on Mac OS-X'
        return
    fi
    sym.dev.configure
    sym.install.symit
    [[ -f ~/.sym.symit.bash ]] && source ~/.sym.symit.bash
    h2 'Encryption Key Import'
    info "Checking for the existence of the current key..."
    if [[ -n "$(sym.dev.have-key)" ]]; then
        info: "Key ${SYMIT_KEY} is already in you your OS-X Key Chain."
        run.ui.ask "Would you like to re-import it?"
        [[ $? != 0 ]] && return
    fi
    if [[ ${skip_instructions} == ${false} ]]; then
        hr
        echo
        info "1. Please open 1Password App and search for 'Encryption Key'"
        echo
        info "2. Once you find the entry, it will contain two items: encryption key"
        info "      and password. Start by copying the key to the clipboard."
        echo
        info "3. You will need to paste the key first, and then copy/paste"
        info "      the key password (also in 1Password)"
        echo
        info "4. As a final setup, you will be asked to create a new password."
        info "      It must be at least 7 characters long, and will be used to encrypt"
        info "      the key locally on your machine."
        echo
        echo
        run.ui.ask "Ready?"
        [[ $? != 0 ]] && return
    fi
    echo
    hr
    sym -iqpx APP_SYM_KEY
    code=$?
    [[ ${code} != 0 ]] && { 
        error "Sym exited with error code ${code}"
        return ${code}
    }
    hr
    echo
    info "Key import was successful, great job! ${bldylw}☺ "
    info "You can test that it works by encrypting, and decrypting a string,"
    echo
    info "\$ ${bldylw}source bin/bash"
    info "\$ ${bldylw}dev.encrypt.str hello"
    info "\$ ${bldylw}dev.decrypt.str \$(dev.encrypt.str hello )"
    echo
    info "Or a file:"
    info "\$ ${bldylw}dev.decrypt.file config/application.dev.yml.enc"
    echo
    info "You can edit the file as if it wasn't encrypted:"
    info "\$ ${bldylw}dev.edit.file config/application.dev.yml.enc"
    echo
}

----

==== `sym.dev.install-shell-helpers`

[source,bash]
----
sym.dev.install-shell-helpers () 
{ 
    local found=
    declare -a init_files=($(util.shell-init-files))
    for file in ${init_files[@]}
    do
        f=${HOME}/${file}
        [[ ! -f "${f}" ]] && continue
        [[ -n $(grep sym.symit ${f}) ]] && { 
            found=${f}
            break
        }
    done
    if [[ -z ${found} ]]; then
        for file in ${init_files[@]}
        do
            f="${HOME}/${file}"
            if [[ -f "${f}" ]]; then
                run "sym -B ${f} 1>/dev/null"
                return $?
            fi
        done
    else
        run "sym -B ${found} 1>/dev/null"
    fi
}

----

==== `sym.install.symit`

[source,bash]
----
sym.install.symit () 
{ 
    if [[ ! -f config.ru ]]; then
        error "Please run this command from the RAILS_ROOT folder"
        return 1
    fi
    [[ -n "$(which sym 2>/dev/null)" && -f ~/.sym.symit.bash ]] && return
    local symit_source="/tmp/sym.symit.bash.$$"
    trap "rm -f ${symit__source}; " EXIT
    local symit_url="https://raw.githubusercontent.com/kigster/sym/master/bin/sym.symit.bash"
    local cmd="curl -fsSL ${symit_url} -o ${symit_source}"
    export LibRun__AbortOnError=${True}
    run "${cmd}"
    if [[ ! -f ${symit_source} ]]; then
        err "unable to find downloaded file ${symit_source}"
        return 1
    fi
    source ${symit_source}
    rm -f ${symit_source}
    run "symit install"
    sym.dev.install-shell-helpers
}

----


=== Module `text`

==== `text.markdown-to-asciidoc`

[source,bash]
----
text.markdown-to-asciidoc () 
{ 
    local file="$1"
    shift
    local default_flags="--imagesdir=/assets/images --no-html-to-native"
    [[ -n $(command -v kramdoc) ]] || gem.install "kramdown-asciidoc"
    if [[ -z "${file}" ]]; then
        usage.set-min-flag-len 1
        usage-box "text.markdown-to-asciidoc markdown-file [ flags ] © Converts a markdown doc to asciidoc using the kramdown-asciidoc ruby gem" " " "Default flags: ${bldcyn}${default_flags}" " " "To override pass any flags that are supported by ${bldred}kramdoc${bldylw}, see below:"
        printf "\n${txtblu}"
        kramdoc --help | tail -16
        printf "${clr}\n"
        return 0
    fi
    [[ -f ${file} && $(file.extension "${file}") == "md" ]] || { 
        error "File ${file} either does not exist, or is not markdown."
        run.set-all on-decline-return
        run.ui.ask "Convert anyway?"
    }
    local target="$(file.extension.replace adoc "${file}")"
    file.ask.if-exists "${target}" || { 
        info "Aborting conversion, leaving ${target} in place."
        return 1
    }
    gem.install "kramdown-asciidoc"
    local args
    if [[ -z "$*" ]]; then
        args="--auto-ids --auto-id-prefix=_ --auto-id-separator=_ --imagesdir=/assets/images --no-html-to-native"
    else
        args="$*"
    fi
    run "kramdoc -o ${target} ${args} ${file}"
}

----


=== Module `time`

==== `epoch`

[source,bash]
----
epoch () 
{ 
    date +%s
}

----

==== `millis`

[source,bash]
----
millis () 
{ 
    .run.millis
}

----

==== `time.date-from-epoch`

[source,bash]
----
time.date-from-epoch () 
{ 
    local epoch_ts="$1"
    if [[ "${AppCurrentOS}" == "Darwin" ]]; then
        printf "date -r ${epoch_ts}"
    else
        printf "date --date='@${epoch_ts}'"
    fi
}

----

==== `time.duration.humanize`

[source,bash]
----
time.duration.humanize () 
{ 
    local seconds=${1}
    local hours=$((${seconds} / 3600))
    local remainder=$((${seconds} - ${hours} * 3600))
    local mins=$((${remainder} / 60))
    local secs=$((${seconds} - ${hours} * 3600 - ${mins} * 60))
    local prefixed=0
    [[ ${hours} -gt 0 ]] && { 
        printf "%02dh:" ${hours}
        prefixed=1
    }
    [[ ${mins} -gt 0 || ${prefixed} == 1 ]] && { 
        printf "%02dm:" ${mins}
        prefixed=1
    }
    { 
        printf "%02ds" ${secs}
    }
}

----

==== `time.duration.millis-to-secs`

[source,bash]
----
time.duration.millis-to-secs () 
{ 
    local duration="$1"
    local format="${2:-"%d.%d"}"
    local seconds=$((duration / 1000))
    local leftover=$((duration - 1000 * seconds))
    printf "${format}" ${seconds} ${leftover}
}

----

==== `time.epoch-to-iso`

[source,bash]
----
time.epoch-to-iso () 
{ 
    local epoch_ts=$1
    eval "$(time.date-from-epoch ${epoch_ts}) -u \"+%Y-%m-%dT%H:%M:%S%z\"" | sed 's/0000/00:00/g'
}

----

==== `time.epoch-to-local`

[source,bash]
----
time.epoch-to-local () 
{ 
    local epoch_ts=$1
    [[ -z ${epoch_ts} ]] && epoch_ts=$(epoch)
    eval "$(time.date-from-epoch ${epoch_ts}) \"+%m/%d/%Y, %r\""
}

----

==== `time.epoch.minutes-ago`

[source,bash]
----
time.epoch.minutes-ago () 
{ 
    local mins=${1}
    [[ -z ${mins} ]] && mins=1
    local seconds=$((${mins} * 60))
    local epoch=$(epoch)
    echo $((${epoch} - ${seconds}))
}

----

==== `time.now.db`

[source,bash]
----
time.now.db () 
{ 
    date '+%F.%T' | tr -d '[-.:]'
}

----

==== `time.now.file-extension`

[source,bash]
----
time.now.file-extension () 
{ 
    time.now.db
}

----

==== `today`

[source,bash]
----
today () 
{ 
    date +'%Y-%m-%d'
}

----


=== Module `trap`

==== `trap-setup`

[source,bash]
----
trap-setup () 
{ 
    .trap-remove
    local signal="${1:-"SIGINT"}"
    trap '.trap-catch' "${signal}"
    export __int_signal__="${signal}"
}

----

==== `trap-was-fired`

[source,bash]
----
trap-was-fired () 
{ 
    if [[ -n "${__int_marker__}" && -f "${__int_marker__}" ]]; then
        rm -f "${__int_marker__}"
        return 0
    fi
    return 1
}

----

==== `trapped`

[source,bash]
----
trapped () 
{ 
    if [[ ${__int_flag__} -eq 1 ]]; then
        unset __int__flag__
        return 0
    fi
    return 1
}

----


=== Module `url`

==== `url.downloader`

[source,bash]
----
url.downloader () 
{ 
    local downloader=
    if [[ -z "${LibUrl__Downloader}" ]]; then
        [[ -z "${downloader}" && -n $(which curl) ]] && downloader="$(which curl) ${LibUrl__CurlDownloaderFlags}"
        [[ -z "${downloader}" && -n $(which wget) ]] && downloader="$(which wget) ${LibUrl__WgetDownloaderFlags}"
        [[ -z "${downloader}" ]] && { 
            error "Neither Curl nor WGet appear in the \$PATH... HALP?"
            return 1
        }
        export LibUrl__Downloader="${downloader}"
    fi
    printf "${LibUrl__Downloader}"
}

----

==== `url.http-code`

[source,bash]
----
url.http-code () 
{ 
    local url="$1"
    local quiet="${2:-false}"
    [[ -z $(which wget) ]] && { 
        echo 1>&2
        err "This function currently only supports ${bldylw}wget.\n" 1>&2
        echo 1>&2
        return 100
    }
    url.is-valid "$url" || { 
        echo 1>&2
        err "The URL provided is not a valid URL: ${bldylw}${url}\n" 1>&2
        echo 1>&2
        return 101
    }
    local result=$(wget -v --spider "${url}" 2>&1 | ${GrepCommand} "response" | awk '{print $6}' | tr -d ' ' | tail -1)
    export LibUrl__LastHttpCode="${result}"
    if [[ ${quiet} == true ]]; then
        if [[ ${result} -gt 199 && ${result} -lt 210 ]]; then
            return 0
        else
            return 1
        fi
    else
        [[ -n "${result}" ]] && printf ${result} || printf "404"
    fi
}

----

==== `url.is-valid`

[source,bash]
----
url.is-valid () 
{ 
    local url="$1"
    if [[ $(url.valid-status "$url") = "ok" ]]; then
        return 0
    else
        return 1
    fi
}

----

==== `url.shorten`

[source,bash]
----
url.shorten () 
{ 
    local longUrl="$1"
    error "This function used Bitly API V3 which is now defunct."
    return 1
    if [[ -z "${BITLY_LOGIN}" || -z "${BITLY_API_KEY}" ]]; then
        printf "${longUrl}"
    else
        export BITLY_LOGIN=$(printf '%s' "${BITLY_LOGIN}" | tr -d '\r' | tr -d '\n')
        export BITLY_API_KEY=$(printf '%s' "${BITLY_API_KEY}" | tr -d '\r' | tr -d '\n')
        if [[ -n $(which ruby) ]]; then
            longUrl=$(ruby -e "require 'uri'; str = '${longUrl}'.force_encoding('ASCII-8BIT'); puts URI.encode(str)")
        fi
        bitlyUrl="http://api.bit.ly/v3/shorten?login=${BITLY_LOGIN}&apiKey=${BITLY_API_KEY}&format=txt&longURL=${longUrl}"
        debug "BITLY_LOLGIN : ${clr}${bldylw}${BITLY_LOGIN}" 1>&2
        debug "BITLY_LOLGIN : ${clr}${bldgrn}${BITLY_API_KEY}" 1>&2
        debug "BITLY_API_URL: ${clr}${undblu}${bitlyUrl}${clr}" 1>&2
        local output="$($(url.downloader) "${bitlyUrl}" 2>&1)"
        if [[ "${output}" =~ "INVALID" || "${output}" =~ "Server Error" ]]; then
            error "${output}"
            return 1
        else
            printf "%s" "${output}" | tr -d '\n' | tr -d ' '
            return 0
        fi
    fi
}

----

==== `url.valid-status`

[source,bash]
----
url.valid-status () 
{ 
    local url="$1"
    echo "${url}" | ruby -ne '
    require "uri"
    u = URI.parse("#{$_}".chomp)
    if u && u.host && u.host&.include?(".") && u&.scheme =~ /^http/
      print "ok"
    else
      print "invalid"
    end'
}

----


=== Module `usage`

==== `usage-box`

[source,bash]
----
usage-box () 
{ 
    local backup="$(.usage-cache-file)"
    if [[ "${EXPIRE_USAGE_CACHE}" -eq 0 && -s "${backup}" ]]; then
        cat "${backup}"
    else
        .usage.box "$@" | tee ${backup}
    fi
}

----

==== `usage-box.section`

[source,bash]
----
usage-box.section () 
{ 
    printf "${__color_headers}"
    .usage.hdr "$*"
}

----

==== `usage-box.sub-section`

[source,bash]
----
usage-box.sub-section () 
{ 
    .output.box-separator "${__color_bdr}"
    .output.boxed-text "${__color_bdr}" "${__color_sub_headers}" "$(.usage.hdr "$1")"
}

----

==== `usage.set-min-flag-len`

[source,bash]
----
usage.set-min-flag-len () 
{ 
    export LibUsage__MinFlagLen="${1}"
}

----


=== Module `user`

==== `user`

[source,bash]
----
user () 
{ 
    local user
    user=$(user.finger.name)
    [[ -z "${user}" ]] && user="$(user.gitconfig.name)"
    [[ -z "${user}" ]] && user="$(user.gitconfig.email)"
    [[ -z "${user}" ]] && user="$(user.username)"
    echo "${user}"
}

----

==== `user.finger.name`

[source,bash]
----
user.finger.name () 
{ 
    [[ -n $(which finge) ]] && finger ${USER} | head -1 | sedx 's/.*Name: //g'
}

----

==== `user.first`

[source,bash]
----
user.first () 
{ 
    user | tr '\n' ' ' | ruby -ne 'puts $_.split(/ /).first.capitalize'
}

----

==== `user.gitconfig.email`

[source,bash]
----
user.gitconfig.email () 
{ 
    if [[ -s ${HOME}/.gitconfig ]]; then
        grep email ${HOME}/.gitconfig | sedx 's/.*=\s?//g'
    fi
}

----

==== `user.gitconfig.name`

[source,bash]
----
user.gitconfig.name () 
{ 
    if [[ -s ${HOME}/.gitconfig ]]; then
        grep name ${HOME}/.gitconfig | sedx 's/.*=\s?//g'
    fi
}

----

==== `user.host`

[source,bash]
----
user.host () 
{ 
    local host=
    host=$(user.my.reverse-ip)
    [[ -z ${host} ]] && host=$(user.my.ip)
    printf "${host}"
}

----

==== `user.login-shell`

[source,bash]
----
user.login-shell () 
{ 
    basename $(user.login-shell-path)
}

----

==== `user.login-shell-path`

[source,bash]
----
user.login-shell-path () 
{ 
    if [[ -n $(command -V finger) ]]; then
        finger ${USER} | grep Shell: | sed 's/^.*Shell: //g'
    else
        echo $SHELL
    fi
}

----

==== `user.my.ip`

[source,bash]
----
user.my.ip () 
{ 
    dig +short myip.opendns.com @resolver1.opendns.com
}

----

==== `user.my.reverse-ip`

[source,bash]
----
user.my.reverse-ip () 
{ 
    nslookup $(user.my.ip) | grep 'name =' | sedx 's/.*name = //g'
}

----

==== `user.username`

[source,bash]
----
user.username () 
{ 
    echo ${USER:-$(whoami)}
}

----


=== Module `util`

==== `is-func`

[source,bash]
----
is-func () 
{ 
    util.is-a-function "$@"
}

----

==== `pause`

[source,bash]
----
pause () 
{ 
    sleep "${1:-1}"
}

----

==== `pause.long`

[source,bash]
----
pause.long () 
{ 
    sleep "${1:-10}"
}

----

==== `pause.medium`

[source,bash]
----
pause.medium () 
{ 
    sleep "${1:-0.3}"
}

----

==== `pause.short`

[source,bash]
----
pause.short () 
{ 
    sleep "${1:-0.1}"
}

----

==== `sedx`

[source,bash]
----
sedx () 
{ 
    [[ -z ${BASHMATIC_UTIL_SED_COMMAND} ]] && export BASHMATIC_UTIL_SED_COMMAND="$(sedx.cache-command)"
    ${BASHMATIC_UTIL_SED_COMMAND} "$*"
}

----

==== `sedx.cache-command`

[source,bash]
----
sedx.cache-command () 
{ 
    if [[ -z "${BASHMATIC_UTIL_SED_COMMAND}" ]]; then
        local sed_path
        local sed_command
        local os
        sed_path="$(which sed)"
        os="$(uname -s)"
        if [[ "${os}" == "Darwin" ]]; then
            local gsed_path
            gsed_path="$(which gsed)"
            if [[ -z "${gsed_path}" ]]; then
                [[ -n $(which brew) ]] || { 
                    error "Brew is needed to install GNU sed on OS-X"
                    return 1
                }
                brew install gnu-sed > /dev/null 2>&1
                brew link gnu-sed --force > /dev/null 2>&1
                gsed_path="$(which gsed)"
            fi
            [[ -z "${gsed_path}" ]] && { 
                error "Can't find GNU sed even after installation."
                return 2
            }
            sed_path="${gsed_path}"
        fi
        sed_command="${sed_path}"
    else
        sed_command="${BASHMATIC_UTIL_SED_COMMAND}"
    fi
    sed_command="${sed_command} -r -e "
    printf "%s" "${sed_command}"
    [[ -z ${BASHMATIC_UTIL_SED_COMMAND} ]] && export BASHMATIC_UTIL_SED_COMMAND="${sed_command}"
}

----

==== `util.append-to-init-files`

[source,bash]
----
util.append-to-init-files () 
{ 
    local string="$1"
    local search="${2:-$1}"
    is_installed=
    declare -a shell_files=($(util.shell-init-files))
    for init_file in ${shell_files[@]}
    do
        file=${HOME}/${init_file}
        [[ -f ${file} && -n $(grep "${search}" ${file}) ]] && { 
            is_installed=${file}
            break
        }
    done
    if [[ -z "${is_installed}" ]]; then
        for init_file in ${shell_files[@]}
        do
            file=${HOME}/${init_file}
            [[ -f ${file} ]] && { 
                echo "${string}" >> ${file}
                is_installed="${file}"
                break
            }
        done
    fi
    printf "${is_installed}"
}

----

==== `util.arch`

[source,bash]
----
util.arch () 
{ 
    echo -n "${AppCurrentOS}-$(uname -m)-$(uname -p)" | tr 'A-Z' 'a-z'
}

----

==== `util.call-if-function`

[source,bash]
----
util.call-if-function () 
{ 
    local func="$1"
    shift
    util.is-a-function "${func}" && { 
        ${func} "$@"
    }
}

----

==== `util.checksum.files`

[source,bash]
----
util.checksum.files () 
{ 
    cat $* | shasum | awk '{print $1}'
}

----

==== `util.checksum.stdin`

[source,bash]
----
util.checksum.stdin () 
{ 
    shasum | awk '{print $1}'
}

----

==== `util.dev-setup.update`

[source,bash]
----
util.dev-setup.update () 
{ 
    run "rm -f ~/.bashmatic/bin/.dev-setup"
    run "dev-setup -N -h > /tmp/a"
    run "mv /tmp/a ~/.bashmatic/bin/.dev-setup"
    run "cd ~/.bashmatic && git add bin/.dev-setup"
    run "cd -"
}

----

==== `util.functions-matching`

[source,bash]
----
util.functions-matching () 
{ 
    local prefix="${1}"
    local extra_command=${2:-"cat"}
    set | ${GrepCommand} "^${prefix}" | sedx 's/[\(\)]//g;' | tr -d ' ' | tr '\n' ' '
}

----

==== `util.functions-matching.diff`

[source,bash]
----
util.functions-matching.diff () 
{ 
    for e in $(util.functions-matching "${1}")
    do
        echo ${e/${1}/}
    done
}

----

==== `util.functions-starting-with`

[source,bash]
----
util.functions-starting-with () 
{ 
    local prefix="${1}"
    local extra_command=${2:-"cat"}
    set | ${GrepCommand} '^[^ ].* \(\) $' | ${GrepCommand} "^${prefix}" | sedx 's/[\(\)]//g;' | ${extra_command} | tr '\n ' ' '
}

----

==== `util.functions-starting-with-csv`

[source,bash]
----
util.functions-starting-with-csv () 
{ 
    local prefix="$1"
    util.functions-starting-with "${prefix}" | sedx "s/${prefix/./\\.}//g; s/\s+(\w)/, \1/g;"
}

----

==== `util.functions-starting-with-lines`

[source,bash]
----
util.functions-starting-with-lines () 
{ 
    local prefix="${1}"
    local extra_command=${2:-"cat"}
    set | ${GrepCommand} '^[^ ].* \(\) $' | ${GrepCommand} "^${prefix}" | sedx 's/[\(\)]//g;' | ${extra_command}
}

----

==== `util.generate-password`

[source,bash]
----
util.generate-password () 
{ 
    local len=${1:-32}
    local val=$(($(date '+%s') - 100000 * $RANDOM))
    [[ ${val:0:1} == "-" ]] && val=${val/-//}
    printf "$(echo ${val} | shasum -a 512 | awk '{print $1}' | base64 | head -c ${len})"
}

----

==== `util.i-to-ver`

[source,bash]
----
util.i-to-ver () 
{ 
    version=${1}
    /usr/bin/env ruby -e "ver='${version}'; printf %Q{%d.%d.%d}, ver[1..2].to_i, ver[3..5].to_i, ver[6..8].to_i"
}

----

==== `util.install-direnv`

[source,bash]
----
util.install-direnv () 
{ 
    [[ -n $(which direnv) ]] || brew.install.package direnv
    local init_file=
    local init_file=$(util.append-to-init-files 'eval "$(direnv hook bash)"; export DIRENV_LOG_FORMAT=' 'direnv hook')
    if [[ -f ${init_file} ]]; then
        info: "direnv init has been appended to ${bldylw}${init_file}..."
    else
        error: "direnv init could not be appended"
    fi
    eval "$(direnv hook bash)"
}

----

==== `util.is-a-function`

[source,bash]
----
util.is-a-function () 
{ 
    type "$1" 2> /dev/null | head -1 | grep -q 'is a function'
}

----

==== `util.is-numeric`

[source,bash]
----
util.is-numeric () 
{ 
    [[ -z $(echo ${1} | sed -E 's/^[0-9]+$//g') ]]
}

----

==== `util.is-variable-defined`

[source,bash]
----
util.is-variable-defined () 
{ 
    local var_name="$1"
    [[ -n ${!var_name+x} ]]
}

----

==== `util.lines-in-folder`

[source,bash]
----
util.lines-in-folder () 
{ 
    local folder=${1:-'.'}
    find ${folder} -type f -exec wc -l {} \; | awk 'BEGIN{a=0}{a+=$1}END{print a}'
}

----

==== `util.random-number`

[source,bash]
----
util.random-number () 
{ 
    local limit="${1:-"1000000"}"
    printf $(((RANDOM % ${limit})))
}

----

==== `util.remove-from-init-files`

[source,bash]
----
util.remove-from-init-files () 
{ 
    local search="${1}"
    local backup_extension="${2}"
    [[ -z ${backup_extension} ]] && backup_extension="$(epoch).backup"
    [[ -z ${search} ]] && return
    declare -a shell_files=($(util.shell-init-files))
    local temp_holder=$(mktemp)
    for init_file in ${shell_files[@]}
    do
        run.config.detail-is-enabled && inf "verifying file ${init_file}..."
        file=${HOME}/${init_file}
        if [[ -f ${file} && -n $(grep "${search}" ${file}) ]]; then
            run.config.detail-is-enabled && ui.closer.ok:
            local matches=$(grep -c "${search}" ${file})
            run.config.detail-is-enabled && info "file ${init_file} matches with ${bldylw}${matches} matches"
            run "grep -v \"${search}\" ${file} > ${temp_holder}"
            if [[ -n "${backup_extension}" ]]; then
                local backup="${file}.${backup_extension}"
                run.config.detail-is-enabled && info "backup file will created in ${bldylw}${backup}"
                [[ -n "${do_backup_changes}" ]] && "mv ${file} ${backup}"
            fi
            run "cp -v ${temp_holder} ${file}"
        else
            run.config.detail-is-enabled && ui.closer.not-ok:
        fi
    done
    return ${LibRun__LastExitCode}
}

----

==== `util.rot13`

[source,bash]
----
util.rot13 () 
{ 
    local value="$*"
    echo "$value" | util.rot13-stdin
}

----

==== `util.rot13-stdin`

[source,bash]
----
util.rot13-stdin () 
{ 
    ruby -e 'puts STDIN.read.
  tr(
    "0123456789",
    "5678901234").
  tr(
    "abcdefghijklmnopqrstuvwxyz",
    "nopqrstuvwxyzabcdefghijklm").
  tr(
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    "NOPQRSTUVWXYZABCDEFGHIJKLM")'
}

----

==== `util.shell-init-files`

[source,bash]
----
util.shell-init-files () 
{ 
    shell_name=$(util.shell-name)
    if [[ ${shell_name} == "bash" ]]; then
        echo ".bash_${USER} .bash_profile .bashrc .profile"
    else
        if [[ ${shell_name} == "zsh" ]]; then
            echo ".zsh_${USER} .zshrc .profile"
        fi
    fi
}

----

==== `util.shell-name`

[source,bash]
----
util.shell-name () 
{ 
    echo $(basename $(printf $SHELL))
}

----

==== `util.ver-to-i`

[source,bash]
----
util.ver-to-i () 
{ 
    version=${1}
    echo ${version} | awk 'BEGIN{FS="."}{ printf "1%02d%03.3d%03.3d", $1, $2, $3}'
}

----

==== `util.whats-installed`

[source,bash]
----
util.whats-installed () 
{ 
    declare -a hb_aliases=($(alias | ${GrepCommand} 'hb\..*=' | sedx 's/alias//g; s/=.*$//g'))
    h2 "Installed app aliases:" ' ' "${hb_aliases[@]}"
    h2 "Installed DB Functions:"
    info "hb.db  [ ms | r1 | r2 | c ]"
    info "hb.ssh <server-name-substring>, eg hb.ssh web"
}

----

==== `watch.command`

[source,bash]
----
watch.command () 
{ 
    [[ -z "$1" ]] && return 1
    trap "return 1" SIGINT
    while true; do
        clear
        hr.colored "${txtblu}"
        printf " ❯ Command: ${bldgrn}$*${clr}  •  ${txtblu}$(date)${clr}  •  Refresh: ${bldcyn}${LibUtil__WatchRefreshSeconds}${clr}\n"
        hr.colored "${txtblu}"
        eval "$*"
        hr.colored "${txtblu}"
        printf "To change refresh rate run ${bldylw}watch.set-refresh <seconds>${clr}\n\n\n"
        sleep "${LibUtil__WatchRefreshSeconds}"
    done
}

----

==== `watch.ls-al`

[source,bash]
----
watch.ls-al () 
{ 
    while true; do
        ls -al
        sleep ${LibUtil__WatchRefreshSeconds}
        clear
    done
}

----

==== `watch.set-refresh`

[source,bash]
----
watch.set-refresh () 
{ 
    export LibUtil__WatchRefreshSeconds="${1:-"0.5"}"
}

----


=== Module `vim`

==== `gvim.off`

[source,bash]
----
gvim.off () 
{ 
    vim.gvim-off
}

----

==== `gvim.on`

[source,bash]
----
gvim.on () 
{ 
    vim.gvim-on
}

----

==== `vim.gvim-off`

[source,bash]
----
vim.gvim-off () 
{ 
    vim.setup
    [[ "${EDITOR}" == "vim" ]] && return 0
    local regex_from='^export EDITOR=.*$'
    local regex_to='export EDITOR=vim'
    file.gsub "${LibVim__initFile}" "${regex_from}" "${regex_to}"
    file.gsub "${LibVim__initFile}" '^gvim.on$' 'gvim.off'
    ${GrepCommand} -q "${regex_from}" ${LibVim__initFile} || echo "${regex_to}" >> ${LibVim__initFile}
    ${GrepCommand} -q "^gvim\.o" ${LibVim__initFile} || echo "gvim.off" >> ${LibVim__initFile}
    eval "
    [[ -n '${DEBUG}' ]] && set -x
    export EDITOR=${LibVim__editorGvimOff}
    unalias ${LibVim__editorVi} 2>/dev/null
    unalias ${LibVim__editorGvimOff} 2>/dev/null
  "
}

----

==== `vim.gvim-on`

[source,bash]
----
vim.gvim-on () 
{ 
    vim.setup
    [[ "${EDITOR}" == "gvim" ]] && return 0
    local regex_from='^export EDITOR=.*$'
    local regex_to='export EDITOR=gvim'
    file.gsub "${LibVim__initFile}" "${regex_from}" "${regex_to}"
    file.gsub "${LibVim__initFile}" '^gvim.off$' 'gvim.on'
    ${GrepCommand} -q "${regex_from}" ${LibVim__initFile} || echo "${regex_to}" >> ${LibVim__initFile}
    ${GrepCommand} -q "^gvim\.o.*" ${LibVim__initFile} || echo "gvim.on" >> ${LibVim__initFile}
    eval "
    [[ -n '${DEBUG}' ]] && set -x
    export EDITOR=${LibVim__editorGvimOn}
    alias ${LibVim__editorVi}=${LibVim__editorGvimOn}
    alias ${LibVim__editorGvimOff}=${LibVim__editorGvimOn}
  "
}

----

==== `vim.setup`

[source,bash]
----
vim.setup () 
{ 
    export LibVim__initFile="${HOME}/.bash_profile"
    export LibVim__editorVi="vi"
    export LibVim__editorGvimOn="gvim"
    export LibVim__editorGvimOff="vim"
}

----


=== Module `yaml`

==== `yaml-diff`

[source,bash]
----
yaml-diff () 
{ 
    yaml.diff "$@"
}

----

==== `yaml-dump`

[source,bash]
----
yaml-dump () 
{ 
    yaml.dump "$@"
}

----

==== `yaml.diff`

[source,bash]
----
yaml.diff () 
{ 
    local f1="$1"
    shift
    local f2="$1"
    shift
    [[ -f "$f1" && -f "$f2" ]] || { 
        h2 "USAGE: ${bldylw}yaml-diff file1.yml file2.yml [ ydiff-options ]"
        return 1
    }
    [[ -n $(which ${BashMatic__DiffTool}) ]] || brew.package.install ${BashMatic__DiffTool}
    local t1="/tmp/${RANDOM}.$(basename ${f1}).$$.yml"
    local t2="/tmp/${RANDOM}.$(basename ${f2}).$$.yml"
    yaml.expand-aliases "$f1" > "$t1"
    yaml.expand-aliases "$f2" > "$t2"
    run.set-next show-output-on
    hr
    run "ydiff $* ${t1} ${t2}"
    hr
    run "rm -rf ${t1} ${t2}"
}

----

==== `yaml.dump`

[source,bash]
----
yaml.dump () 
{ 
    local f1="$1"
    shift
    [[ -f "$f1" ]] || { 
        h2 "USAGE: ${bldylw}yaml-dump file.yml"
        return 1
    }
    [[ -n $(which ${BashMatic__DiffTool}) ]] || brew.package.install ${BashMatic__DiffTool}
    local t1="/tmp/${RANDOM}.$(basename ${f1}).$$.yml"
    yaml.expand-aliases "$f1" > "$t1"
    vim "$t1"
    run "rm -rf ${t1}"
}

----

==== `yaml.expand-aliases`

[source,bash]
----
yaml.expand-aliases () 
{ 
    ruby -e "require 'yaml'; require 'json'; puts YAML.dump(JSON.parse(JSON.pretty_generate(YAML.load(File.read('${1}')))))"
}

----



== Copyright



© 2020 Konstantin Gredeskoul, All rights reserved, MIT License.