= Bashmatic Functions Index
:allow-uri-read:
:doctype: book
:sectnums:
:showtitle:
:toc:
:toclevels: 5

== Bashmatic Modules

* xref:#module-7z[7z]
* xref:#module-array[array]
* xref:#module-audio[audio]
* xref:#module-aws[aws]
* xref:#module-bashmatic[bashmatic]
* xref:#module-brew[brew]
* xref:#module-caller[caller]
* xref:#module-color[color]
* xref:#module-db[db]
* xref:#module-db_rails[db_rails]
* xref:#module-db_top[db_top]
* xref:#module-deploy[deploy]
* xref:#module-dir[dir]
* xref:#module-docker[docker]
* xref:#module-file[file]
* xref:#module-ftrace[ftrace]
* xref:#module-gem[gem]
* xref:#module-git[git]
* xref:#module-github[github]
* xref:#module-is[is]
* xref:#module-jemalloc[jemalloc]
* xref:#module-json[json]
* xref:#module-maths[maths]
* xref:#module-net[net]
* xref:#module-openssl[openssl]
* xref:#module-osx[osx]
* xref:#module-output[output]
* xref:#module-output-boxes[output-boxes]
* xref:#module-output-repeat-char[output-repeat-char]
* xref:#module-output-utils[output-utils]
* xref:#module-path[path]
* xref:#module-pdf[pdf]
* xref:#module-pg[pg]
* xref:#module-pids[pids]
* xref:#module-pipe[pipe]
* xref:#module-progress-bar[progress-bar]
* xref:#module-repositories[repositories]
* xref:#module-ruby[ruby]
* xref:#module-run[run]
* xref:#module-runtime[runtime]
* xref:#module-runtime-config[runtime-config]
* xref:#module-set[set]
* xref:#module-settings[settings]
* xref:#module-shdoc[shdoc]
* xref:#module-shell-set[shell-set]
* xref:#module-ssh[ssh]
* xref:#module-subshell[subshell]
* xref:#module-sym[sym]
* xref:#module-text[text]
* xref:#module-time[time]
* xref:#module-trap[trap]
* xref:#module-url[url]
* xref:#module-usage[usage]
* xref:#module-user[user]
* xref:#module-util[util]
* xref:#module-vim[vim]
* xref:#module-yaml[yaml]
* xref:#module-zsh[zsh]

== List of Bashmatic Functions


=== Module `7z`

==== `7z.a`

[source,bash]
----
7z.a () 
{ 
    7z.zip "$@"
}

----

==== `7z.install`

[source,bash]
----
7z.install () 
{ 
    [[ -n $(which 7z) ]] || run "brew install p7zip"
    [[ -n $(which 7z) ]] || { 
        error "7z is not found after installation"
        return 1
    }
    return 0
}

----

==== `7z.unzip`

[source,bash]
----
7z.unzip () 
{ 
    7z.install
    local archive="$1"
    [[ -f ${archive} ]] || archive="${archive}.tar.7z"
    [[ -f ${archive} ]] || { 
        error "Neither $1 nor ${archive} were found."
        return 1
    }
    info "Unpacking archive ${txtylw}${archive}$(txt-info), total of $(file.size ${archive}) bytes."
    run.set-next show-output-on
    run "7za x -so ${archive} | tar xfv -"
}

----

==== `7z.x`

[source,bash]
----
7z.x () 
{ 
    7z.unzip "$@"
}

----

==== `7z.zip`

[source,bash]
----
7z.zip () 
{ 
    local folder="$1"
    shift
    7z.install
    local archive="${folder}"
    [[ -f "${folder}" || -d "${folder}" ]] && archive="$(basename ${folder} | sed -E 's/\./-/g').tar.7z"
    [[ -f ${archive} ]] && { 
        run.set-next on-decline-return
        run.ui.ask "File ${archive} already exists. Press Y to remove it and continue." || return 1
        run "rm -f ${archive}"
    }
    local -a flags=
    local -a args=
    for arg in $@
    do
        if [[ ${arg:0:1} == "-" ]]; then
            flags=(${flags[@]} "${arg}")
        else
            args=(${args[@]} "${arg}")
        fi
    done
    printf "${bldgrn}"
    printf "${args[*]}\n"
    printf "${bldylw}"
    set +e
    local command="tar cf - ${folder} ${args[*]} | 7za a ${flags[*]} -si -bd ${archive}"
    run.print-command "${command}"
    eval "${command}"
    local code=$?
    printf "${clr}"
    if [[ ${code} -eq 0 ]]; then
        success "${archive} created."
    else
        error "Tar/7z Exited with code ${code}"
        return 1
    fi
}

----


=== Module `array`

==== `array.eval.in-groups-of`

[source,bash]
----
array.eval.in-groups-of () 
{ 
    local chunk="$1"
    shift
    local function="$1"
    shift
    local -a group
    for item in "$@"
    do
        index="$(( index + 1 ))"
        if [[ ${#group[@]} -eq ${chunk} ]]; then
            ${function} "${group[@]}"
            group=("${item}")
        else
            group=("${group[@]}" "${item}")
        fi
    done
    if [[ ${#group[@]} -gt 0 ]]; then
        ${function} "${group[@]}"
    fi
    return 0
}

----

==== `array.from.command`

[source,bash]
----
array.from.command () 
{ 
    local array_name=$1
    shift
    local command="$*"
    local OFS="$IFS"
    eval "IFS=\$'\\n' read -ra ${array_name} -d '' <<< \"\$(${command})\""
    export IFS="$OFS"
}

----

==== `array.has-element`

[source,bash]
----
array.has-element () 
{ 
    local search="$1"
    shift
    local r="false"
    local e
    [[ "$*" =~ ${search} ]] || { 
        echo -n $r
        return 1
    }
    for e in "${@}"
    do
        [[ "$e" == "${search}" ]] && r="true"
    done
    echo -n $r
    [[ $r == "false" ]] && return 1
    return 0
}

----

==== `array.includes`

[source,bash]
----
array.includes () 
{ 
    local search="$1"
    shift
    [[ "$*" =~ ${search} ]] || return 1
    for e in "${@}"
    do
        [[ "$e" == "${search}" ]] && { 
            return 0
        }
    done
    return 1
}

----

==== `array.includes-or-complain`

[source,bash]
----
array.includes-or-complain () 
{ 
    array.includes "$@" || { 
        element="$1"
        shift
        local -a output=()
        while true; do
            [[ -z "$1" ]] && break
            if [[ "$1" =~ " " ]]; then
                output=("${output[@]}" "$1")
            else
                output=("$1")
            fi
            shift
        done
        if [[ ${#output[@]} -gt 10 ]]; then
            error "Value ${element} must be one of the supplied values."
        else
            error "Value ${element} must be one of the supplied values:" "${output[@:0:10]}"
        fi
        echo
        return 0
    }
    return 1
}

----

==== `array.includes-or-exit`

[source,bash]
----
array.includes-or-exit () 
{ 
    array.includes-or-complain "$@" || exit 1
}

----

==== `array.join`

[source,bash]
----
array.join () 
{ 
    local sep="$1"
    shift
    local lines="$1"
    if [[ ${lines} == true || ${lines} == false ]]; then
        shift
    else
        lines=false
    fi
    local elem
    local len="$#"
    local last_index=$(( len - 1 ))
    local index=0
    for elem in "$@"
    do
        if ${lines}; then
            printf "${sep}%s\n" "${elem}"
        else
            printf "%s" "${elem}"
            [[ ${index} -lt ${last_index} ]] && printf '%s' "${sep}"
        fi
        index=$(( index + 1 ))
    done
}

----

==== `array.max`

[source,bash]
----
array.max () 
{ 
    local max="$1"
    shift
    for v in "$@"
    do
        is.numeric "$v" || continue
        [[ ${v} -gt ${max} ]] && max="$v"
    done
    printf -- "%d" "${max}"
}

----

==== `array.min`

[source,bash]
----
array.min () 
{ 
    local min="$1"
    shift
    for v in "$@"
    do
        is.numeric "$v" || continue
        [[ ${v} -lt ${min} ]] && min="$v"
    done
    printf -- "%d" "${min}"
}

----

==== `array.sort`

[source,bash]
----
array.sort () 
{ 
    local IFS_previous="${IFS}"
    export IFS=''
    printf "%s\n" "$@" | sort | tr '\n' ' ' | sed 's/ $//g'
    IFS="${IFS_previous}"
}

----

==== `array.sort-numeric`

[source,bash]
----
array.sort-numeric () 
{ 
    local IFS_previous="${IFS}"
    export IFS=''
    printf "%s\n" "$@" | sort -n | tr '\n' ' ' | sed 's/ $//g'
    IFS="${IFS_previous}"
}

----

==== `array.to.bullet-list`

[source,bash]
----
array.to.bullet-list () 
{ 
    array.join ' â€¢ ' true "$@"
}

----

==== `array.to.csv`

[source,bash]
----
array.to.csv () 
{ 
    array.join ', ' false "$@"
}

----

==== `array.to.piped-list`

[source,bash]
----
array.to.piped-list () 
{ 
    array.join ' | ' false "$@"
}

----

==== `array.uniq`

[source,bash]
----
array.uniq () 
{ 
    local IFS_previous="${IFS}"
    IFS=''
    printf "%s\n" "$@" | sort -u | tr '\n' ' ' | sed 's/ $//g'
    IFS="${IFS_previous}"
}

----


=== Module `audio`

==== `audio.dir.mp3-to-wav`

[source,bash]
----
audio.dir.mp3-to-wav () 
{ 
    local from="$1"
    local to="$2"
    run "cd \"${from}\""
    trap "return 1" INT
    while read -d '' filename; do
        audio.file.mp3-to-wav "${filename}" "${to}" < /dev/null
    done < <(find . -type f -name "*.mp3" -print0)
    run "cd -"
}

----

==== `audio.file.frequency`

[source,bash]
----
audio.file.frequency () 
{ 
    local file="$1"
    [[ -z $(command -V mdls) ]] && return 1
    local frequency=$(mdls "${file}" | grep kMDItemAudioSampleRate | sed 's/.*= //g')
    [[ -z ${frequency} ]] && frequency=48000
    local kHz=$(maths.eval "${frequency} / 1000.0" 0)
    printf ${kHz}
}

----

==== `audio.file.mp3-to-wav`

[source,bash]
----
audio.file.mp3-to-wav () 
{ 
    local from="${1/.\//}"
    local destination="$2"
    if [[ -z ${destination} ]]; then
        destination="$(dirname "${from}")"
    else
        destination="${destination}/$(dirname "${from}")"
    fi
    local to="${destination}/$(basename "${from/.mp3/.wav}")"
    if [[ ${from} =~ ".mp3" ]]; then
        h.blue "Source:      ${from}"
        cursor.up 1
        h.green "Destination: ${to}"
        [[ -f "${to}" ]] && { 
            info: "File already converted."
            return 0
        }
        run "mkdir -p \"${destination}\""
        run.set-next show-output-on
        run "lame --decode \"${from}\" \"${to}\""
    else
        error "File ${from} is not an MP3 file."
        return 1
    fi
}

----

==== `audio.make.mp3`

[source,bash]
----
audio.make.mp3 () 
{ 
    local file="$1"
    shift
    local nfile="$2"
    shift
    set +e
    [[ -n "$(command -V lame)" ]] || brew.package.install lame
    local default_options=" -m s -b 320 "
    [[ -n "${file}" ]] || { 
        audio.make.mp3.usage && return 1
    }
    [[ -s "${file}" ]] || { 
        error "File '${file}' does not exist."
        audio.make.mp3.usage && return 2
    }
    [[ -z ${nfile} ]] && nfile="$(echo "${file}" | sedx 's/\.(wav|aiff?)$/\.mp3/g')"
    local khz=$(audio.file.frequency "${file}")
    h2 "'$(basename "${file}")' â€”â¯ ${txtylw}${nfile}${txtgrn}, sample rate: ${khz:-'Unknown'}kHz"
    info "lame ${default_options} $* '${file}' '${nfile}'"
    run.set-next show-output-on abort-on-error
    run "lame ${default_options}  $* '${file}' '${nfile}'"
    hr
    success "MP3 file ${nfile} is $(file.size.mb "${nfile}")Mb"
}

----

==== `audio.make.mp3.usage`

[source,bash]
----
audio.make.mp3.usage () 
{ 
    usage-box "audio.wav-to-mp3 [ file.wav | file.aif | file.aiff ] [ file.mp3 ] Â© Convert a RAW PCM Audio to highest quality MP3" "You can pass additional flags to ${txtylw}lame" "" "Just run ${txtylw}lame --longhelp for more info." "" "Default Flags: ${default_options}" ""
}

----

==== `audio.make.mp3s`

[source,bash]
----
audio.make.mp3s () 
{ 
    local dir="${1:-"."}"
    local kHz="${2:-"48"}"
    local first="$(find "${dir}" -type f -a \( -name "*.aif*" -o -name "*.wav" \) -print | head -1)"
    h3 "Converting WAV and AIF files to MP3 in ${txtylw}${dir}."
    if [[ -z ${first} ]]; then
        error "No AIFF or WAV files in the folder ${bldgrn}${dir}"
        return 1
    fi
    inf "Determining audio sampling rate (will apply the same rate to all files)... "
    kHz=$(audio.file.frequency "${first}")
    printf "${bldgrn} â€” ${kHz}kHz"
    ok:
    SAVEIFS=$IFS
    run.set-all show-command-on show-output-off abort-on-error
    find "${dir}" -type f -a \( -name "*.aif*" -o -name "*.wav" \) -print0 | while read -d '' file; do
        local fn=$(ascii-clean "${file}")
        mp3=$(echo "${file}" | sedx 's/\.(wav|aiff?)$/.mp3/g')
        inf "checking ${txtylw}${file} $(txt-info) ... "
        if [[ -f "${mp3}" && -z "${FORCE}" ]]; then
            printf "${bldgrn} OK, already converted. Use FORCE=1 to overwrite. ${clr}"
            ok:
            continue
        fi
        printf "${txtcyn} Transcoding...${clr}"
        ui.closer.kind-of-ok:
        inf "â¯ ${txtylw}lame --silent -m s -b 320  \"${file}\""
        trap _term SIGINT
        lame --silent -m s -b 320 "${fn}" & child_pid=$!
        wait "$child_pid"
        code=$?
        if [[ ${code} -ne 0 ]]; then
            ui.closer.not-ok:
            info "${bakred}${bldwht}  ERROR: lame exited with an error code ${code}. Aborting!  "
            [[ -f "${mp3}" ]] && { 
                info "NOTE: removing unfinished MP3 file ${mp3}."
                rm -f "${mp3}" 1>&2 > /dev/null
            }
            break
        else
            ok:
        fi
    done
    success 'All done.'
}

----


=== Module `aws`

==== `aws.ec2`

[source,bash]
----
aws.ec2 () 
{ 
    local cmd="$1"
    local command="$cmd"
    case $command in 
        list | show | ls)
            __utf_table "$(aws ec2 describe-instances --query 'Reservations[*].Instances[*].{name: Name, instance_id: InstanceId, ip_address: PrivateIpAddress, state: State.Name}' --output table 2>/dev/null)"
            return $?
        ;
        *)
            error "Invalid Command: ${cmd}"
            return 1
        ;
    esac
}

----

==== `aws.rds.hostname`

[source,bash]
----
aws.rds.hostname () 
{ 
    local name=${1}
    [[ -z $(which jq) ]] && out=$(brew.install.package jq 2>/dev/null 1>/dev/null)
    [[ -z $(which aws) ]] && out=$(brew.install.package awscli 2>/dev/null 1>/dev/null)
    [[ -n ${name} ]] && aws rds describe-db-instances | jq '.[][].Endpoint.Address' | sedx 's/"//g' | ${GrepCommand} "^${name}\."
    [[ -z ${name} ]] && aws rds describe-db-instances | jq '.[][].Endpoint.Address' | sedx 's/"//g'
}

----

==== `aws.s3.upload`

[source,bash]
----
aws.s3.upload () 
{ 
    local pathname="$1"
    shift
    local skip_file_modification="$1"
    [[ -n ${skip_file_modification} ]] && skip_file_modification=true
    [[ -z ${skip_file_modification} ]] && skip_file_modification=false
    if [[ -z "${LibAws__DefaultUploadBucket}" || -z "${LibAws__DefaultUploadFolder}" ]]; then
        error "Required AWS S3 configuration is not defined." "Please set variables: ${bldylw}LibAws__DefaultUploadFolder" "and ${bldylw}LibAws__DefaultUploadBucket" "before using this function."
        return 1
    fi
    if [[ ! -f "${pathname}" ]]; then
        error "Local file was not found: ${bldylw}${pathname}"
        return 1
    fi
    local file=$(basename "${pathname}")
    local remote_file="${file}"
    local year=$(file.last-modified-year "${pathname}")
    local date=$(file.last-modified-date "${pathname}")
    [[ -z ${year} ]] && year=$(date +'%Y')
    [[ -z ${date} ]] && date=$(today)
    ${skip_file_modification} || { 
        [[ "${remote_file}" =~ "${date}" ]] && remote_file=$(echo "${remote_file}" | sedx "s/[_\.-]?${date}[_\.-]//g")
        [[ "${remote_file}" =~ "${date}" ]] || remote_file="${date}.${remote_file}"
    }
    remote_file=$(echo "${remote_file}" | sed -E 's/ /-/g;s/--+/-/g' | tr '[A-Z]' '[a-z]')
    local remote="s3://${LibAws__DefaultUploadBucket}/${LibAws__DefaultUploadFolder}/${year}/${remote_file}"
    run "aws s3 cp \"${pathname}\" \"${remote}\""
    if [[ ${LibRun__LastExitCode} -eq 0 ]]; then
        local remoteUrl="https://s3-${LibAws__DefaultRegion}.amazonaws.com/${LibAws__DefaultUploadBucket}/${LibAws__DefaultUploadFolder}/${year}/${remote_file}"
        [[ -n "${LibAws__ObjectUrlFile}" ]] && echo ${remoteUrl} > "${LibAws__ObjectUrlFile}"
        echo
        info "NOTE: You should now be able to access your resource at the following URL:"
        hr
        info "${bldylw}${remoteUrl}"
        hr
    else
        error "AWS S3 upload failed with code ${LibRun__LastExitCode}"
    fi
    return ${LibRun__LastExitCode}
}

----


=== Module `bashmatic`

==== `bashmatic.bash.exit-unless-version-four-or-later`

[source,bash]
----
bashmatic.bash.exit-unless-version-four-or-later () 
{ 
    bashmatic.bash.version-four-or-later || { 
        error "Sorry, this functionality requires BASH version 4 or later."
        exit 1 > /dev/null
    }
}

----

==== `bashmatic.bash.version`

[source,bash]
----
bashmatic.bash.version () 
{ 
    echo "${BASH_VERSION/[^0-9]*/}"
}

----

==== `bashmatic.bash.version-four-or-later`

[source,bash]
----
bashmatic.bash.version-four-or-later () 
{ 
    [[ $(bashmatic.bash.version) -gt 3 ]]
}

----

==== `bashmatic.cache.add-file`

[source,bash]
----
bashmatic.cache.add-file () 
{ 
    ((CacheEnabled)) || return
    [[ -n "${1}" ]] && BashMatic__LoadCache[${1}]=true
}

----

==== `bashmatic.cache.has-file`

[source,bash]
----
bashmatic.cache.has-file () 
{ 
    ((CacheEnabled)) || return 1
    local file="$1"
    test -z "$file" && return 1
    if [[ -n "$1" && -n "${BashMatic__LoadCache["${file}"]}" ]]; then
        return 0
    else
        return 1
    fi
}

----

==== `bashmatic.cache.init`

[source,bash]
----
bashmatic.cache.init () 
{ 
    return
    if bashmatic.bash.version-four-or-later; then
        declare -A BashMatic__LoadCache 2> /dev/null
        export BashMatic__LoadCache
    else
        CacheEnabled=0
    fi
}

----

==== `bashmatic.cache.list`

[source,bash]
----
bashmatic.cache.list () 
{ 
    ((CacheEnabled)) || return
    for f in "${!BashMatic__LoadCache[@]}"
    do
        echo $f
    done
}

----

==== `bashmatic.functions`

[source,bash]
----
bashmatic.functions () 
{ 
    bashmatic.functions-from '*.sh' "$@"
}

----

==== `bashmatic.functions-from`

[source,bash]
----
bashmatic.functions-from () 
{ 
    local pattern="${1}"
    [[ -n ${pattern} ]] && shift
    [[ -z ${pattern} ]] && pattern="[a-z]*.sh"
    cd "${BASHMATIC_HOME}/lib" > /dev/null || return 1
    export SCREEN_WIDTH=$(screen-width)
    if [[ ! ${pattern} =~ * && ! ${pattern} =~ .sh$ ]]; then
        pattern="${pattern}.sh"
    fi
    ${GrepCommand} '^[_a-zA-Z0-9]+.*\(\)' ${pattern} | sedx 's/^(lib\/)?.*\.sh://g' | sedx 's/^function //g' | sedx 's/\(\) *\{.*$//g' | tr -d '()' | sedx '/^ *$/d' | ${GrepCommand} '^(_|\.)' -v | sort | uniq | columnize "$@"
    cd - > /dev/null || return 1
}

----

==== `bashmatic.functions.output`

[source,bash]
----
bashmatic.functions.output () 
{ 
    bashmatic.functions-from 'output.sh' "$@"
}

----

==== `bashmatic.functions.runtime`

[source,bash]
----
bashmatic.functions.runtime () 
{ 
    bashmatic.functions-from 'run*.sh' "$@"
}

----

==== `bashmatic.is-developer`

[source,bash]
----
bashmatic.is-developer () 
{ 
    [[ ${BASHMATIC_DEVELOPER} -eq 1 || -f ${BASHMATIC_HOME}/.envrc.local ]]
}

----

==== `bashmatic.load-at-login`

[source,bash]
----
bashmatic.load-at-login () 
{ 
    local file="${1}"
    [[ -z ${file} ]] && file="$(user.login-shell-init-file)"
    grep -q -E 'BASHMATIC_HOME' "${file}" || { 
        { 
            echo "export BASHMATIC_HOME=\"${BASHMATIC_HOME:-"~/.bashmatic"}\""
            echo '[[ -f ${BASHMATIC_HOME}/init.sh ]] && source ${BASHMATIC_HOME}/init.sh'
            echo 'export PATH="${PATH}:${BASHMATIC_HOME}/bin"'
        } >> "${file}"
        source "${file}"
    }
}

----

==== `bashmatic.reload`

[source,bash]
----
bashmatic.reload () 
{ 
    source "${BASHMATIC_INIT}"
}

----

==== `bashmatic.setup`

[source,bash]
----
bashmatic.setup () 
{ 
    bashmatic.cache.init
    bashmatic.shell-check || return 1
    [[ -z ${BashMatic__Downloader} && -n $(command -v curl) ]] && export BashMatic__Downloader="curl -fsSL --connect-timeout 5 "
    [[ -z ${BashMatic__Downloader} && -n $(command -v wget) ]] && export BashMatic__Downloader="wget -q -O --connect-timeout=5 - "
    if [[ ! -d "${BASHMATIC_LIBDIR}" ]]; then
        printf "\e[1;31mUnable to establish BashMatic's library source folder.\e[0m\n"
        return 1
    fi
    bashmatic.source is.sh output.sh util.sh git.sh file.sh color.sh brew.sh
    bashmatic.source-dir "${BASHMATIC_LIBDIR}"
    [[ -d ${BASHMATIC_HOME}/.git ]] && bashmatic.auto-update
}

----

==== `bashmatic.shell-check`

[source,bash]
----
bashmatic.shell-check () 
{ 
    local shell="$(user.current-shell)"
    if [[ "${shell}" =~ bash$ || "${shell}" =~ zsh$ ]]; then
        return 0
    else
        cat "${BASHMATIC_HOME}/.init.sh" 1>&2
        return 120
    fi
}

----

==== `bashmatic.source`

[source,bash]
----
bashmatic.source () 
{ 
    local path="${BASHMATIC_LIBDIR}"
    for file in "${@}"
    do
        [[ "${file}" =~ "/" ]] || file="${path}/${file}"
        [[ -s "${file}" ]] || { 
            echo "Can't source file ${file} â€” fils is invalid."
            return 1
        }
        if [[ ${CacheEnabled} -eq 0 ]]; then
            [[ -n ${DEBUG} ]] && printf "${txtred}[source] ${bldylw}${file}${clr}...\n" 1>&2
            source "${file}"
        else
            if bashmatic.cache.has-file "${file}"; then
                [[ -n ${DEBUG} ]] && printf "${txtgrn}[cached] ${bldblu}${file}${clr} \n" 1>&2
            else
                [[ -n ${DEBUG} ]] && printf "${txtcyn}[source] ${bldylw}${file}${clr}...\n" 1>&2
                set +e
                source "${file}"
                bashmatic.cache.add-file "${file}"
            fi
        fi
    done
    return 0
}

----

==== `bashmatic.source-dir`

[source,bash]
----
bashmatic.source-dir () 
{ 
    local folder="${1}"
    local loaded=false
    local file
    unset files
    declare -a files
    eval "$(files.map.shell-scripts "${folder}" files)"
    if [[ ${#files[@]} -eq 0 ]]; then
        .err "No files were returned from files.map in " "\n  ${bldylw}${folder}"
        return 1
    fi
    for file in "${files[@]}"
    do
        bashmatic.source "${file}" && loaded=true
    done
    unset files
    ${loaded} || { 
        .err "Unable to find BashMatic library folder with files:" "${BASHMATIC_LIBDIR}"
        return 1
    }
    if [[ ${LoadedShown} -eq 0 ]]; then
        hr
        success "BashMatic was loaded! Happy Bashing :) "
        hr
        export LoadedShown=1
    fi
}

----

==== `bashmatic.version`

[source,bash]
----
bashmatic.version () 
{ 
    cat "$(dirname "${BASHMATIC_INIT}")/.version"
}

----


=== Module `brew`

==== `brew.cache-reset`

[source,bash]
----
brew.cache-reset () 
{ 
    if [[ "$1" == "cask" ]]; then
        rm -f "${LibBrew__CaskCacheList}"
    else
        if [[ "$2" == "package" ]]; then
            rm -f "${LibBrew__PackageCacheList}"
        else
            rm -f "${LibBrew__PackageCacheList}" "${LibBrew__CaskCacheList}"
        fi
    fi
}

----

==== `brew.cache-reset.delayed`

[source,bash]
----
brew.cache-reset.delayed () 
{ 
    ((BASH_IN_SUBSHELL)) || brew.cache-reset both
}

----

==== `brew.cask.all-installed`

[source,bash]
----
brew.cask.all-installed () 
{ 
    local -a installed_casks=($(brew.cask.list))
    for item in "$@"
    do
        array.includes "${item}" "${installed_casks[@]}" || return 1
    done
    return 0
}

----

==== `brew.cask.is-installed`

[source,bash]
----
brew.cask.is-installed () 
{ 
    if brew.cask.all-installed "$@"; then
        echo "true"
    else
        echo "false"
    fi
}

----

==== `brew.cask.list`

[source,bash]
----
brew.cask.list () 
{ 
    cache-or-command "${LibBrew__CaskCacheList}" 10 --cask -1
}

----

==== `brew.cask.tap`

[source,bash]
----
brew.cask.tap () 
{ 
    run "brew tap homebrew/cask-cask"
}

----

==== `brew.install`

[source,bash]
----
brew.install () 
{ 
    local brew=$(which brew 2>/dev/null)
    if [[ -z "${brew}" ]]; then
        info "Installing Homebrew, please wait..."
        /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
    else
        info "Detected Homebrew Version: ${bldylw}$(brew --version 2>/dev/null | head -1)"
        run "brew update"
    fi
}

----

==== `brew.install.cask`

[source,bash]
----
brew.install.cask () 
{ 
    local cask=$1
    local force=
    local verbose=
    [[ -n "${opts_force}" ]] && force="--force"
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    local installed_app="$(osx.app.is-installed "${cask}")"
    inf "checking if cask is installed: ${bldylw}${cask}"
    brew.cask.all-installed "${cask}" && { 
        ok:
        return 0
    }
    if [[ -n "${installed_app}" && -z "${opts_force}" ]]; then
        ui.closer.ok:
        return 0
    else
        ui.closer.kind-of-ok:
        run "brew cask install ${cask} ${force} ${verbose}"
        brew.cache-reset cask
    fi
}

----

==== `brew.install.package`

[source,bash]
----
brew.install.package () 
{ 
    local package="$1"
    local force=
    local verbose=
    local code
    [[ -n "${opts_force}" ]] && force="--force"
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    [[ -z "${opt_terse}" ]] && inf "checking for ðŸ» ${bldylw}${package}..."
    if brew.package.all-installed "${package}"; then
        [[ -z "${opt_terse}" ]] && ok:
        [[ -z "${opt_terse}" ]] || printf "${bldgrn}â—‹ "
        export LibRun__LastExitCode=0
    else
        if [[ -z "${opt_terse}" ]]; then
            ui.closer.kind-of-ok:
            run "brew install ${package} ${force} ${verbose}"
            code="${LibRun__LastExitCode}"
        else
            brew install "${package}" ${force} ${verbose} > /dev/null 2>&1
            code=$?
            brew.cache-reset package
        fi
        [[ -n ${force} ]] && { 
            run.set-next continue-on-error
            run "brew link ${package} --overwrite ${force} ${verbose}"
        }
        hash -r > /dev/null
        [[ "${code}" -eq 0 ]] || { 
            warning "Reinstalling ${package} as I couldn't find it after instal..."
            brew.reinstall.package "${package}"
        }
        export LibRun__LastExitCode=0
        if [[ "$(brew.package.is-installed "${package}")" == "true" ]]; then
            [[ -n "${opt_terse}" ]] && printf "\n ðŸŸ¢ "
        else
            [[ -n "${opt_terse}" ]] && printf "\n ðŸ”´ "
            export LibRun__LastExitCode=1
        fi
    fi
    return ${LibRun__LastExitCode}
}

----

==== `brew.install.packages`

[source,bash]
----
brew.install.packages () 
{ 
    local force=
    [[ -n "${opts_force}" ]] && force="--force"
    for package in "$@"
    do
        brew.install.package "${package}"
    done
}

----

==== `brew.package.all-installed`

[source,bash]
----
brew.package.all-installed () 
{ 
    local -a installed_packages=($(brew.package.list))
    for item in "$@"
    do
        array.includes "${item}" "${installed_packages[@]}" || return 1
    done
    return 0
}

----

==== `brew.package.available-versions`

[source,bash]
----
brew.package.available-versions () 
{ 
    local package="$1"
    [[ -z "$1" ]] && return 1
    brew search "${package}@" | tr -d 'a-z@A-Z =>-+' | sed '/^$/d' | sort -nr | tr '\n' ' '
}

----

==== `brew.package.is-installed`

[source,bash]
----
brew.package.is-installed () 
{ 
    if brew.package.all-installed "$@"; then
        echo "true"
    else
        echo "false"
    fi
}

----

==== `brew.package.link`

[source,bash]
----
brew.package.link () 
{ 
    local package="${1}"
    shift
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    run "brew link ${verbose} ${package} $*"
}

----

==== `brew.package.list`

[source,bash]
----
brew.package.list () 
{ 
    cache-or-command "${LibBrew__PackageCacheList}" 10 --formula -1
}

----

==== `brew.reinstall.package`

[source,bash]
----
brew.reinstall.package () 
{ 
    local package="${1}"
    local force=
    local verbose=
    [[ -n "${opts_force}" ]] && force="--force"
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    run "brew unlink    ${package} ${force} ${verbose}"
    run "brew uninstall ${package} ${force} ${verbose}"
    brew.install.package "${package}"
}

----

==== `brew.reinstall.packages`

[source,bash]
----
brew.reinstall.packages () 
{ 
    local force=
    local result=0
    [[ -n "${opts_force}" ]] && force="--force"
    for package in "$@"
    do
        brew.uninstall.package "${package}"
        brew.install.package "${package}"
        local result=$?
    done
    return ${result}
}

----

==== `brew.relink`

[source,bash]
----
brew.relink () 
{ 
    local package"${1}"
    local verbose=
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    run "brew link ${verbose} ${package} --overwrite"
}

----

==== `brew.service.down`

[source,bash]
----
brew.service.down () 
{ 
    local svc="$1"
    run "brew services stop ${svc}"
}

----

==== `brew.service.restart`

[source,bash]
----
brew.service.restart () 
{ 
    local svc="$1"
    run "brew services restart ${svc}"
}

----

==== `brew.service.up`

[source,bash]
----
brew.service.up () 
{ 
    local svc="$1"
    run "brew services start ${svc}"
}

----

==== `brew.setup`

[source,bash]
----
brew.setup () 
{ 
    brew.upgrade
}

----

==== `brew.uninstall`

[source,bash]
----
brew.uninstall () 
{ 
    echo y | /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall.sh)"
}

----

==== `brew.uninstall.package`

[source,bash]
----
brew.uninstall.package () 
{ 
    local package=$1
    local force=
    local verbose=
    [[ -n "${opts_force}" ]] && force="--force"
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    run.set-next continue-on-error
    run "brew unlink ${package} ${force} ${verbose}"
    run.set-next continue-on-error
    run "brew uninstall ${package} ${force} ${verbose}"
    brew.cache-reset.delayed
}

----

==== `brew.uninstall.packages`

[source,bash]
----
brew.uninstall.packages () 
{ 
    local force=
    [[ -n "${opts_force}" ]] && force="--force"
    for package in "$@"
    do
        brew.uninstall.package "${package}"
    done
}

----

==== `brew.upgrade`

[source,bash]
----
brew.upgrade () 
{ 
    brew.install
    if [[ -z "$(which brew)" ]]; then
        warn "brew is not installed...."
        return 1
    fi
    run "brew update --force"
    run "brew upgrade"
    run "brew cleanup -s"
}

----

==== `brew.upgrade.packages`

[source,bash]
----
brew.upgrade.packages () 
{ 
    [[ -z "$(which brew)" ]] || brew.install
    [[ -z $1 ]] && { 
        error "usage: brew.upgrade.packages package1 package2 ..."
        return 1
    }
    run "brew upgrade $*"
}

----

==== `cache-or-command`

[source,bash]
----
cache-or-command () 
{ 
    local file="$1"
    shift
    local stale_minutes="$1"
    shift
    if file.exists-and-newer-than "${file}" "${stale_minutes}"; then
        if [[ -s "${file}" ]]; then
            cat "${file}"
            return 0
        fi
    fi
    is-dbg && info "REFRESHING CACHE with command: ${bldylw}brew list ${*} >${file}"
    brew list "$@" > "${file}"
    cat "${file}"
}

----


=== Module `caller`

==== `caller.stack`

[source,bash]
----
caller.stack () 
{ 
    local index=${1:-"-1"}
    while true; do
        index=$((index + 1))
        caller ${index} 2>&1 > /dev/null || break
        local -a frame=($(caller ${index} | tr ' ' '\n'))
        printf "%3d [ %-40.40s ]: %s\n" ${index} "${frame[2]}:${frame[0]}" "${frame[1]}"
    done
}

----

==== `stack.frame`

[source,bash]
----
stack.frame () 
{ 
    caller.stack 0
}

----


=== Module `color`

==== `bold`

[source,bash]
----
bold () 
{ 
    .ansi 1 "$@"
}

----

==== `color.disable`

[source,bash]
----
color.disable () 
{ 
    export clr='\e[0m'
    unset txtblk
    unset txtred
    unset txtgrn
    unset txtylw
    unset txtblu
    unset txtpur
    unset txtcyn
    unset txtwht
    unset bldblk
    unset bldred
    unset bldgrn
    unset bldylw
    unset bldblu
    unset bldpur
    unset bldcyn
    unset bldwht
    unset unkblk
    unset undred
    unset undgrn
    unset undylw
    unset undblu
    unset undpur
    unset undcyn
    unset undwht
    unset bakblk
    unset bakred
    unset bakgrn
    unset bakylw
    unset bakblu
    unset bakpur
    unset bakcyn
    unset bakwht
    unset txtrst
    unset italic
    unset bold
    unset strikethrough
    unset underlined
    unset white_on_orange
    unset white_on_yellow
    unset white_on_red
    unset white_on_pink
    unset white_on_salmon
    unset yellow_on_gray
    export BashMatic__ColorLoaded=0
}

----

==== `color.enable`

[source,bash]
----
color.enable () 
{ 
    if [[ ${BashMatic__ColorLoaded} -eq 1 ]]; then
        [[ -n ${DEBUG} ]] && echo "colors are already loaded."
    else
        export txtblk='\e[0;30m'
        export txtred='\e[0;31m'
        export txtgrn='\e[0;32m'
        export txtylw='\e[0;33m'
        export txtblu='\e[0;34m'
        export txtpur='\e[0;35m'
        export txtcyn='\e[0;36m'
        export txtwht='\e[0;37m'
        export bldblk='\e[1;30m'
        export bldred='\e[1;31m'
        export bldgrn='\e[1;32m'
        export bldylw='\e[1;33m'
        export bldblu='\e[1;34m'
        export bldpur='\e[1;35m'
        export bldcyn='\e[1;36m'
        export bldwht='\e[1;37m'
        export unkblk='\e[4;30m'
        export undred='\e[4;31m'
        export undgrn='\e[4;32m'
        export undylw='\e[4;33m'
        export undblu='\e[4;34m'
        export undpur='\e[4;35m'
        export undcyn='\e[4;36m'
        export undwht='\e[4;37m'
        export bakblk='\e[40m'
        export bakred='\e[41m'
        export bakgrn='\e[42m'
        export bakylw='\e[43m'
        export bakblu='\e[44m'
        export bakpur='\e[45m'
        export bakcyn='\e[46m'
        export bakwht='\e[47m'
        export txtrst='\e[0m'
        export rst='\e[0m'
        export clr='\e[0m'
        export bold='\e[1m'
        export italic='\e[3m'
        export underlined='\e[4m'
        export strikethrough='\e[9m'
        export inverse_on='\e[7m'
        export inverse_off='\e[27m'
        export default_bg='\e[49m'
        export default_fg='\e[39m'
        export white_on_orange="\e[48;5;208m"
        export white_on_yellow="\e[48;5;214m"
        export white_on_red="\e[48;5;9m"
        export white_on_pink="\e[48;5;199m"
        export white_on_salmon="\e[48;5;196m"
        export yellow_on_gray="\e[38;5;220m\e[48;5;242m"
        export BashMatic__ColorLoaded=1
    fi
}

----

==== `error-text`

[source,bash]
----
error-text () 
{ 
    printf "${txtred}"
}

----

==== `italic`

[source,bash]
----
italic () 
{ 
    .ansi 3 "$@"
}

----

==== `red`

[source,bash]
----
red () 
{ 
    .ansi 31 "$@"
}

----

==== `reset-color`

[source,bash]
----
reset-color () 
{ 
    echo -en "${clr}"
}

----

==== `strikethrough`

[source,bash]
----
strikethrough () 
{ 
    .ansi 9 "$@"
}

----

==== `txt-err`

[source,bash]
----
txt-err () 
{ 
    printf "${clr}${bldylw}${bakred}"
}

----

==== `txt-info`

[source,bash]
----
txt-info () 
{ 
    printf "${clr}${txtblu}"
}

----

==== `txt-warn`

[source,bash]
----
txt-warn () 
{ 
    printf "${clr}${bldylw}"
}

----

==== `underline`

[source,bash]
----
underline () 
{ 
    .ansi 4 "$@"
}

----


=== Module `db`

==== `db.actions.connect`

[source,bash]
----
db.actions.connect () 
{ 
    db.psql.connect "$@"
}

----

==== `db.actions.connections`

[source,bash]
----
db.actions.connections () 
{ 
    db.config.connections
    echo
}

----

==== `db.actions.csv`

[source,bash]
----
db.actions.csv () 
{ 
    export flag_quiet=1
    db.psql.run "$@" --csv -A -P pager=off -P footer=off
}

----

==== `db.actions.data-dir`

[source,bash]
----
db.actions.data-dir () 
{ 
    db.psql.connect "$@" $(db.psql.args-data-only) -c 'show data_directory' | $(which grep) -E -v 'data_directory|row'
}

----

==== `db.actions.db-settings-pretty`

[source,bash]
----
db.actions.db-settings-pretty () 
{ 
    db.psql.connect.db-settings-pretty "$@"
}

----

==== `db.actions.db-settings-toml`

[source,bash]
----
db.actions.db-settings-toml () 
{ 
    db.psql.connect.db-settings-toml "$@"
}

----

==== `db.actions.explain`

[source,bash]
----
db.actions.explain () 
{ 
    local dbname="$1"
    shift
    local query="$1"
    shift
    local flags
    local explain_sql="EXPLAIN (ANALYZE, COSTS, VERBOSE, BUFFERS, FORMAT JSON)"
    local explain_json
    if [[ -f "${query}" ]]; then
        local explain="${query}.explain"
        local explain_json="${query}.explain.json"
        echo "${explain_sql}" > "${explain}"
        cat "${query}" >> "${explain}"
        flags="-f ${explain} -o ${explain_json}"
    else
        query="${query//\"/\\\"}"
        explain_json="$(echo "${query}" | shasum | cut -d' ' -f 1).json"
        flags="-c \"${explain_sql} ${query}\" -o ${explain_json}"
    fi
    db.psql.connect "${dbname}" "-AXt -P pager=off ${flags}"
}

----

==== `db.actions.run`

[source,bash]
----
db.actions.run () 
{ 
    db.psql.run "$@"
}

----

==== `db.actions.table-settings-set`

[source,bash]
----
db.actions.table-settings-set () 
{ 
    db.psql.connect.table-settings-set "$@"
}

----

==== `db.actions.table-settings-show`

[source,bash]
----
db.actions.table-settings-show () 
{ 
    db.psql.connect.table-settings-show "$@"
}

----

==== `db.actions.top`

[source,bash]
----
db.actions.top () 
{ 
    db.top "$@"
}

----

==== `db.config.connections`

[source,bash]
----
db.config.connections () 
{ 
    ascii-clean "$(db.config.connections-list | awk '{print $1}')"
}

----

==== `db.config.connections-list`

[source,bash]
----
db.config.connections-list () 
{ 
    [[ -f ${bashmatic_db_config} ]] || return 2
    ruby.handle-missing
    gem.install colored2 > /dev/null
    __yaml_source="${bashmatic_db_config}" ruby <<RUBY
  require 'yaml'
  require 'colored2'
  h = YAML.load(File.read(ENV['__yaml_source']))
  h.each_pair do |name, params|
    printf "%50s â†’ %s@%s/%s\n",
      name.bold.yellow,
      params['username'].blue,
      params['host'].green,
      params['database'].cyan
  end
RUBY

}

----

==== `db.config.get-file`

[source,bash]
----
db.config.get-file () 
{ 
    echo "${bashmatic_db_config}"
}

----

==== `db.config.init`

[source,bash]
----
db.config.init () 
{ 
    export bashmatic_db_connection=(host database username password)
}

----

==== `db.config.parse`

[source,bash]
----
db.config.parse () 
{ 
    local db="$1"
    [[ -z ${db} ]] && return 1
    [[ -f ${bashmatic_db_config} ]] || return 2
    db.config.init
    local -a script=("require 'yaml'; h = YAML.load(STDIN); ")
    for field in "${bashmatic_db_connection[@]}"
    do
        script+=("h.key?('${db}') && h['${db}'].key?('${field}') ? print(h['${db}']['${field}']) : print('null'); print ' '; ")
    done
    ruby.handle-missing
    ruby -e "${script[*]}" < "${bashmatic_db_config}"
}

----

==== `db.config.set-file`

[source,bash]
----
db.config.set-file () 
{ 
    [[ -s "$1" ]] || return 1
    export bashmatic_db_config="$1"
}

----

==== `db.datetime`

[source,bash]
----
db.datetime () 
{ 
    date '+%Y%m%d-%H%M%S'
}

----

==== `db.pg.local.num-procs`

[source,bash]
----
db.pg.local.num-procs () 
{ 
    /bin/ps -ef | /bin/grep "[p]ostgres" | wc -l | awk '{print $1}'
}

----

==== `db.postgres.version`

[source,bash]
----
db.postgres.version () 
{ 
    command -v postgres > /dev/null || return 1
    postgres --version | sed -E 's/[^0-9.]//g'
}

----

==== `db.psql.args`

[source,bash]
----
db.psql.args () 
{ 
    if [[ -z "${bashmatic_db_database}" || -z "${bashmatic_db_host}" ]]; then
        if [[ -n "$1" ]]; then
            db.psql.args.config "$1"
        else
            error "Unable to determine DB connection parameters"
            return 1
        fi
    else
        export PGPASSWORD="${bashmatic_db_password}"
        printf -- "-U ${bashmatic_db_username} -h ${bashmatic_db_host} ${bashmatic_db_database}"
    fi
}

----

==== `db.psql.args-data-only`

[source,bash]
----
db.psql.args-data-only () 
{ 
    printf -- "%s" "--no-align --pset footer -q -X --tuples-only"
}

----

==== `db.psql.args.config`

[source,bash]
----
db.psql.args.config () 
{ 
    local output="$(db.config.parse "$1")"
    local -a params
    [[ -z ${output} || "${output}" =~ "null" ]] && { 
        section.red 65 "Unknown database connection â€” ${bldylw}$1." 1>&2
        info "The following are connections defined in ${bldylw}${bashmatic_db_config/${HOME}/\~}:\n" 1>&2
        for c in $(db.config.connections)
        do
            info " â€¢ ${c}" 1>&2
        done
        echo 1>&2
        exit 1
    }
    params=($(db.config.parse "$1"))
    local dbhost
    local dbname
    local dbuser
    local dbpass
    dbhost=${params[0]}
    dbname=${params[1]}
    dbuser=${params[2]}
    dbpass=${params[3]}
    export PGPASSWORD="${dbpass}"
    printf -- "-U ${dbuser} -h ${dbhost} -d ${dbname}"
}

----

==== `db.psql.args.localhost`

[source,bash]
----
db.psql.args.localhost () 
{ 
    printf -- "-U postgres -h localhost $*"
}

----

==== `db.psql.args.maintenance`

[source,bash]
----
db.psql.args.maintenance () 
{ 
    db.psql.args.localhost "--maintenance-db=postgres $*"
}

----

==== `db.psql.connect`

[source,bash]
----
db.psql.connect () 
{ 
    local dbname="$1"
    shift
    if [[ -z ${dbname} ]]; then
        h1 "USAGE: db.connect connection-name" "WHERE: connection-name is defined by your ${bldylw}${bashmatic_db_config}${clr} file." 1>&2
        return 0``
    fi
    export __psql_stderr="$(file.temp)"
    cp /dev/null "${__psql_stderr}"
    local tempfile=$(mktemp)
    db.psql.args.config "${dbname}" > "${tempfile}"
    local -a args=($(cat "${tempfile}"))
    rm -f "${tempfile}" > /dev/null
    [[ ${flag_quiet} -eq 0 ]] && { 
        printf "${txtpur}export PGPASSWORD=[reducted]${clr}\n" 1>&2
        printf "${txtylw}$(which psql) ${args[*]}${clr}\n" 1>&2
        hr 1>&2
    }
    set +e
    is-verbose && echo
    if [[ ${action} == "run" ]]; then
        print-cli psql --echo-errors "${args[@]}" "$@"
        psql "${args[@]}" --echo-errors "$@" 2> "${__psql_stderr}"
        local code=$?
        [[ ${code} -ne 0 || -s "${__psql_stderr}" ]] && db.psql.report-error "${args[@]}" "$@"
    else
        print-cli "psql ${args[*]} --echo-errors $*"
        eval "psql ${args[*]} --echo-errors $*"
        local code=$?
    fi
    set -e
    return ${code}
}

----

==== `db.psql.connect.db-settings-pretty`

[source,bash]
----
db.psql.connect.db-settings-pretty () 
{ 
    db.psql.connect "$@" -A -X -q -c 'show all' | grep -v 'rows)' | sort | awk "BEGIN{FS=\"|\"}{ printf(\"%-40.40s %-30.30s ## %s\n\", \$1, \$2, \$3) }" | sedx '/##\s*$/d' | GREP_COLOR="1;32" grep -E -C 1000 -i --color=always -e '^([^ ]*)' | GREP_COLOR="3;0;34" grep -E -C 1000 -i --color=always -e '##.*$|$'
}

----

==== `db.psql.connect.db-settings-toml`

[source,bash]
----
db.psql.connect.db-settings-toml () 
{ 
    db.psql.connect.just-data "$1" -c 'show all' | awk 'BEGIN{FS="|"}{printf "%s=%s\n", $1, $2}' | sort
}

----

==== `db.psql.connect.just-data`

[source,bash]
----
db.psql.connect.just-data () 
{ 
    local dbname="$1"
    shift
    db.psql.connect "${dbname}" $(db.psql.args-data-only) "$@"
}

----

==== `db.psql.connect.table-settings-set`

[source,bash]
----
db.psql.connect.table-settings-set () 
{ 
    local dbname="$1"
    shift
    local table="$1"
    shift
    local setting="$1"
    shift
    local value="$1"
    shift
    [[ -z ${setting} || -z ${value} ]] && { 
        error "Either setting or value are not defined." 1>&2
        return 1
    }
    info "Setting ${setting} = ${value} on table ${table}...."
    db.psql.connect "${dbname}" $(db.psql.args-data-only) -c "ALTER TABLE \"${table}\" SET (${setting} = ${value});"
}

----

==== `db.psql.connect.table-settings-show`

[source,bash]
----
db.psql.connect.table-settings-show () 
{ 
    local dbname="$1"
    shift
    local table="$1"
    shift
    db.psql.connect "${dbname}" $(db.psql.args-data-only) -c "SELECT relname, reloptions FROM pg_class WHERE relname='${table}';"
}

----

==== `db.psql.db-settings`

[source,bash]
----
db.psql.db-settings () 
{ 
    psql "$*" -X -q -c 'show all' | sort | awk '{ printf("%s=%s\n", $1, $3) }' | sed -E 's/[()\-]//g;/name=setting/d;/^[-+=]*$/d;/^[0-9]*=$/d'
}

----

==== `db.psql.report-error`

[source,bash]
----
db.psql.report-error () 
{ 
    local -a argv=("$@")
    [[ -z "${__psql_stderr}" ]] && return 0
    [[ -s "${__psql_stderr}" ]] || return 0
    error "Error running command: " "${bldylw}psql ${argv[*]}"
    printf -- "${txtred}$(cat "${__psql_stderr}" | sed -E 's/^/   /g')${clr}\n"
    hr
    rm -f "${__psql_stderr}"
    unset __psql_stderr
}

----

==== `db.psql.run`

[source,bash]
----
db.psql.run () 
{ 
    local dbname="$1"
    shift
    db.psql.connect "${dbname}" -X --pset border=3 -c "$*" -c "\q"
}

----

==== `db.psql.version`

[source,bash]
----
db.psql.version () 
{ 
    command -v psql > /dev/null || return 1
    psql --version | sed -E 's/[^0-9.]//g'
}

----

==== `db.wait-until-db-online`

[source,bash]
----
db.wait-until-db-online () 
{ 
    local db="${1}"
    inf 'waiting for the database to come up...'
    while true; do
        out=$(psql -c "select count(*) from pg_stat_user_tables" "$(db.psql.args "${db}")" 2>&1)
        code=$?
        [[ ${code} == 0 ]] && break
        [[ ${code} == 1 ]] && break
        sleep 1
        [[ ${out} =~ 'does not exist' ]] && break
    done
    ui.closer.ok:
    return 0
}

----

==== `print-cli`

[source,bash]
----
print-cli () 
{ 
    is-verbose || return
    h1 "Running command line:" "${bldylw}$*"
}

----


=== Module `db_rails`

==== `db.rails.schema.checksum`

[source,bash]
----
db.rails.schema.checksum () 
{ 
    if [[ -d db/migrate ]]; then
        find db/migrate -type f -ls | awk '{printf("%10d-%s\n",$7,$11)}' | sort | shasum | awk '{print $1}'
    else
        local schema=$(db.rails.schema.file)
        [[ -s ${schema} ]] || error "can not find Rails schema in either ${RAILS_SCHEMA_RB} or ${RAILS_SCHEMA_SQL}"
        [[ -s ${schema} ]] && util.checksum.files "${schema}"
    fi
}

----

==== `db.rails.schema.file`

[source,bash]
----
db.rails.schema.file () 
{ 
    if [[ -f "${RAILS_SCHEMA_RB}" && -f "${RAILS_SCHEMA_SQL}" ]]; then
        if [[ "${RAILS_SCHEMA_RB}" -nt "${RAILS_SCHEMA_SQL}" ]]; then
            printf "${RAILS_SCHEMA_RB}"
        else
            printf "${RAILS_SCHEMA_SQL}"
        fi
    else
        if [[ -f "${RAILS_SCHEMA_RB}" ]]; then
            printf "${RAILS_SCHEMA_RB}"
        else
            if [[ -f "${RAILS_SCHEMA_SQL}" ]]; then
                printf "${RAILS_SCHEMA_SQL}"
            fi
        fi
    fi
}

----


=== Module `db_top`

==== `db.top`

[source,bash]
----
db.top () 
{ 
    local dbname
    local width_min=90
    local height_min=30
    local width=$(screen.width)
    local height=$(screen.height)
    if [[ "$1" == "-l" || "$1" == "--list" ]]; then
        db.config.connections
        echo
        return
    fi
    if [[ ${width} -lt ${width_min} || ${height} -lt ${height_min} ]]; then
        error "Your screen is too small for db.top."
        info "Minimum required screen dimensions are ${width_min} columns, ${height_min} rows."
        info "Your screen is ${bldred}${width}x${height}."
        return
    fi
    local -a connections_arguments
    local -a connections_names
    local -a connections_passwords
    local code=0
    local i=0
    local arguments
    local tof="$(mktemp -d "${TMPDIR:-/tmp/}.XXXXXXXXXXXX")/.db.top.$$"
    cp /dev/null "${tof}" > /dev/null
    for connection in "$@"
    do
        db.psql.args.config "${connection}" > /dev/null || return 1
        db.psql.args "${connection}" > "${tof}"
        arguments="$(cat "${tof}" | tr -d '\n')"
        connections_arguments+=("${arguments}")
        connections_names+=("${connection}")
        connections_passwords+=("${PGPASSWORD}")
        i=$((i + 1))
    done
    if [[ ${#connections_names[@]} -eq 0 ]]; then
        h1 "${bldgrn}USAGE: db.top db1 db2 ... " "   EG: db.top prod-master prod-replica1 prod-replica2"
        return 1
    fi
    ((BASH_IN_SUBSHELL)) && { 
        trap "clear" TERM
        trap "clear" EXIT
    }
    local interval=${bashmatic_db_top_refresh:-1}
    local num_dbs=${#connections_names[@]}
    h1 "Refreshing activity for ${num_dbs} databases..."
    while true; do
        local index=0
        rm -f "${tof}.errors"
        cp /dev/null "${tof}"
        local screen_height=$(screen.height)
        for dbname in "${connections_names[@]}"
        do
            local percent_total_height
            local percent_total_height_next
            percent_total_height=$(.db.top.vertical-offset "${num_dbs}" ${index})
            percent_total_height_next=$(.db.top.vertical-offset "${num_dbs}" $((index + 1)))
            local vertical_shift=$((percent_total_height * screen_height / 100))
            local vertical_shift_next=$((percent_total_height_next * screen_height / 100))
            local height=$((vertical_shift_next - vertical_shift - 7))
            cursor.at.y ${vertical_shift} >> "${tof}"
            [[ -n ${DEBUG} ]] && { 
                .output.set-indent 0
                info "CURRENT â¯${bldylw} % = ${percent_total_height}, %++ = ${percent_total_height_next}" >> "${tof}"
                h1 -- "Database: ${dbname}" "PSQL arguments:" "${connections_arguments[${index}]}" >> "${tof}"
            }
            .db.top.connection "${tof}" "${dbname}" "${connections_passwords[${index}]}" "${height}" "${connections_arguments[${index}]}"
            index=$((index + 1))
        done
        clear
        if [[ -s "${tof}.errors" ]]; then
            error "ERROR running psql with args: ${bldylw}${connections_arguments[${index}]}"
            printf "${bldred}"
            cat "${tof}.errors"
            printf "${clr}\n"
            h3 "Output:"
            cat "${tof}"
            code=111
            break
        else
            .output.set-indent 0
            hl.green "DbTopÂ© v1.1.0 Â© 2016-2020 Konstantin Gredeskoul â€¢ Â© All Rights Reserved â€¢ MIT License â€”â€” "
            cat "${tof}"
            cursor.at.y $(($(.output.screen-height) + 1))
            printf "${bldwht}Press Ctrl-C to quit.${clr}"
            code=0
        fi
        sleep "${interval}"
    done
    return ${code}
}

----

==== `db.top.set-refresh`

[source,bash]
----
db.top.set-refresh () 
{ 
    export bashmatic_db_top_refresh="$1"
}

----


=== Module `deploy`

==== `deploy.slack`

[source,bash]
----
deploy.slack () 
{ 
    local original_text="$*"
    [[ -z ${LibDeploy__SlackHookUrl} ]] && return 1
    local text=$(echo "${original_text}" | sed -E 's/"/\"/g' | sed -E "s/'/\'/g")
    local json="{\"text\": \"$text\"}"
    local slack_url="${LibDeploy__SlackHookUrl}"
    [[ ${LibRun__DryRun} -eq ${False} ]] && { 
        if ${LibDeploy__NoSlack}; then
            hl.green "${original_text}"
        else
            curl -s -d "payload=$json" "${slack_url}" > /dev/null
            if [[ $? -eq 0 ]]; then
                info: "sent to Slack: [${text}]"
            else
                warning: "error sending to Slack, is your SLACK_URL set?"
            fi
        fi
    }
    [[ ${LibRun__DryRun} -eq ${True} ]] && run "send to slack [${text}]"
}

----

==== `deploy.slack-ding`

[source,bash]
----
deploy.slack-ding () 
{ 
    deploy.slack "<!here> $@"
}

----

==== `deploy.validate-vpn`

[source,bash]
----
deploy.validate-vpn () 
{ 
    .deploy.check-vpn "$@" || .deploy.vpn-error "$@"
}

----


=== Module `dir`

==== `dir.count-slashes`

[source,bash]
----
dir.count-slashes () 
{ 
    local dir="${1}"
    echo "${dir}" | sed 's/[^/]//g' | tr -d '\n' | wc -c | tr -d ' '
}

----

==== `dir.expand-dir`

[source,bash]
----
dir.expand-dir () 
{ 
    local dir="${1}"
    if [[ "${dir:0:1}" != "/" && "${dir:0:1}" != "~" ]]; then
        dir="$(pwd)/${dir}"
    else
        if [[ "${dir:0:1}" == "~" ]]; then
            dir="${HOME}/${dir:1:1000}"
        fi
    fi
    printf -- "%s" "${dir}"
}

----

==== `dir.is-a-dir`

[source,bash]
----
dir.is-a-dir () 
{ 
    local dir="${1}"
    [[ -d "${dir}" ]]
}

----

==== `dir.short-home`

[source,bash]
----
dir.short-home () 
{ 
    local dir="$1"
    printf -- "%s" "${dir}" | sed -E "s#${HOME}#~#g"
}

----


=== Module `docker`

==== `docker.abort-if-down`

[source,bash]
----
docker.abort-if-down () 
{ 
    local should_exit="${1:-true}"
    inf 'Checking if Docker is running...'
    docker ps 2> /dev/null > /dev/null
    code=$?
    if [[ ${code} == 0 ]]; then
        ui.closer.ok:
    else
        ui.closer.not-ok:
        error "docker ps returned ${code}, is Docker running?"
        [[ "${should_exit}" == "true" ]] && exit 127
        return 127
    fi
}

----

==== `docker.actions.build`

[source,bash]
----
docker.actions.build () 
{ 
    docker.build.container "$@"
}

----

==== `docker.actions.clean`

[source,bash]
----
docker.actions.clean () 
{ 
    .docker.exec "docker-compose rm"
}

----

==== `docker.actions.pull`

[source,bash]
----
docker.actions.pull () 
{ 
    local tag=${1:-'latest'}
    .docker.check-repo "${2}" || return 1
    .docker.exec "docker pull ${AppDockerRepo}:${tag}"
}

----

==== `docker.actions.push`

[source,bash]
----
docker.actions.push () 
{ 
    local tag=${1:-$(.docker.next-version)}
    .docker.check-repo "${2}" || return 1
    docker.actions.tag latest
    [[ -n ${tag} ]] && docker.actions.tag "${tag}"
    .docker.check-repo || return 1
    .docker.exec docker push "${AppDockerRepo}:${tag}"
    [[ ${tag} != 'latest' ]] && .docker.exec docker push "${AppDockerRepo}:latest"
}

----

==== `docker.actions.setup`

[source,bash]
----
docker.actions.setup () 
{ 
    setup.docker
    docker.pull
    docker.build
}

----

==== `docker.actions.start`

[source,bash]
----
docker.actions.start () 
{ 
    .docker.exec "docker-compose start"
}

----

==== `docker.actions.stop`

[source,bash]
----
docker.actions.stop () 
{ 
    .docker.exec "docker-compose stop"
}

----

==== `docker.actions.tag`

[source,bash]
----
docker.actions.tag () 
{ 
    local tag=${1}
    [[ -z ${tag} ]] && return 1
    .docker.check-repo "${2}" || return 1
    .docker.exec docker tag "${AppDockerRepo}" "${AppDockerRepo}:${tag}"
}

----

==== `docker.actions.up`

[source,bash]
----
docker.actions.up () 
{ 
    .docker.exec "docker-compose up"
}

----

==== `docker.actions.update`

[source,bash]
----
docker.actions.update () 
{ 
    docker.build
    docker.push
}

----

==== `docker.build.container`

[source,bash]
----
docker.build.container () 
{ 
    .docker.check-repo "${1}" || return 1
    local tag=${AppDockerRepo}
    .docker.exec "docker build -m 3G -c 4 --pull -t ${tag} . $*"
}

----

==== `docker.containers.clean`

[source,bash]
----
docker.containers.clean () 
{ 
    local -a args=("$@")
    run "docker rm $(docker ps -q -a) ${args[*]}"
}

----

==== `docker.image.inspect`

[source,bash]
----
docker.image.inspect () 
{ 
    run.set-next show-output-on
    local jq=" | jq"
    [[ -z $(command -v jq) ]] && jq=
    run "docker image inspect ${*} $jq"
}

----

==== `docker.image.rm`

[source,bash]
----
docker.image.rm () 
{ 
    run "docker image rm ${*}"
}

----

==== `docker.images-named`

[source,bash]
----
docker.images-named () 
{ 
    local name="${1}"
    local func="${2}"
    docker.abort-if-down false || return 127
    hl.subtle "Processing Docker images matching ${name} with function ${func}..."
    local images="$(docker images | grep "^${name}" | sed 's/  */ /g' | cut -d ' ' -f 3 | tr '\n' ' ')"
    ${func} ${images}
}

----

==== `docker.images.clean`

[source,bash]
----
docker.images.clean () 
{ 
    local name=${1:-"<none>"}
    docker.images-named "${name}" "docker.image.rm"
}

----

==== `docker.images.inspect`

[source,bash]
----
docker.images.inspect () 
{ 
    local name=${1:-"<none>"}
    docker.images-named "${name}" "docker.image.inspect"
}

----

==== `docker.last-version`

[source,bash]
----
docker.last-version () 
{ 
    .docker.check-repo "${1}" || return 1
    [[ -z ${AppDockerRepo} ]] && { 
        error "usage: docker.last-version organization/reponame:version"
        return 1
    }
    .docker.last-version "$@"
}

----

==== `docker.next-version`

[source,bash]
----
docker.next-version () 
{ 
    .docker.check-repo "${1}" || return 1
    [[ -z ${AppDockerRepo} ]] && { 
        error "usage: docker.next-version [ organization/repo-name:version ]"
        return 1
    }
    .docker.next-version "$@"
}

----

==== `docker.set-repo`

[source,bash]
----
docker.set-repo () 
{ 
    [[ -n "$1" ]] && export AppDockerRepo="$1"
}

----


=== Module `file`

==== `dir.find`

[source,bash]
----
dir.find () 
{ 
    find . -name "*$1*" -type d -print
}

----

==== `ff`

[source,bash]
----
ff () 
{ 
    file.find "$@"
}

----

==== `file.ask.if-exists`

[source,bash]
----
file.ask.if-exists () 
{ 
    local file="$1"
    shift
    local message="$*"
    [[ -z "${message}" ]] && message="File ${file} exists. Overwrite?"
    if [[ -f ${file} ]]; then
        run.set-next on-decline-return
        run.ui.ask "${message}" || return 1
    fi
    return 0
}

----

==== `file.exists-and-newer-than`

[source,bash]
----
file.exists-and-newer-than () 
{ 
    local file="${1}"
    shift
    local minutes="${1}"
    shift
    if [[ -n "$(find ${file} -mmin -${minutes} -print 2>/dev/null)" ]]; then
        return 0
    else
        return 1
    fi
}

----

==== `file.extension`

[source,bash]
----
file.extension () 
{ 
    local filename="$1"
    printf "${filename##*.}"
}

----

==== `file.extension.remove`

[source,bash]
----
file.extension.remove () 
{ 
    local filename="$1"
    printf "${filename%.*}"
}

----

==== `file.extension.replace`

[source,bash]
----
file.extension.replace () 
{ 
    local ext="$1"
    shift
    [[ -z "$1" ]] && { 
        info "USAGE: file.extension.replace <new-extension> file1 file2 ... "
        return 1
    }
    ext=".$(echo ${ext} | tr -d '.')"
    local first=true
    for file in "$@"
    do
        ${first} || printf " "
        printf "%s%s" "$(file.strip.extension "${file}")" "${ext}"
        first=false
    done
}

----

==== `file.find`

[source,bash]
----
file.find () 
{ 
    find . -name "*$1*" -type f -print
}

----

==== `file.gsub`

[source,bash]
----
file.gsub () 
{ 
    local file="$1"
    shift
    local find="$1"
    shift
    local replace="$1"
    shift
    local runtime_options="$*"
    [[ ! -s "${file}" || -z "${find}" || -z "${replace}" ]] && { 
        error "Invalid usage of file.sub â€” " "USAGE: file.gsub <file>    <find-regex>        <replace-regex>" "EG:    file.gsub ~/.bashrc '^export EDITOR=vi' 'export EDITOR=gvim'"
        return 1
    }
    ${GrepCommand} -q "${find}" "${file}" || return 0
    [[ -z "${runtime_options}" ]] || run.set-next ${runtime_options}
    run "sed -i'' -E -e 's/${find}/${replace}/g' \"${file}\""
}

----

==== `file.install-with-backup`

[source,bash]
----
file.install-with-backup () 
{ 
    local source="$1"
    local dest="$2"
    if [[ ! -f "${source}" ]]; then
        error "file ${source} can not be found"
        return 4
    fi
    if [[ -f "${dest}" ]]; then
        if [[ -z $(diff "${dest}" "${source}" 2>/dev/null) ]]; then
            info: "${dest} is up to date"
            return 0
        else
            ((LibFile__ForceOverwrite)) || { 
                info "file ${dest} already exists, skipping (use -f to overwrite)"
                return 0
            }
            inf "making a backup of ${dest} (${dest}.bak)"
            cp "${dest}" "${dest}.bak" > /dev/null
            ui.closer.ok:
        fi
    fi
    run "mkdir -p $(dirname ${dest}) && cp ${source} ${dest}"
}

----

==== `file.last-modified-date`

[source,bash]
----
file.last-modified-date () 
{ 
    stat -f "%Sm" -t "%Y-%m-%d" "$1"
}

----

==== `file.last-modified-year`

[source,bash]
----
file.last-modified-year () 
{ 
    stat -f "%Sm" -t "%Y" "$1"
}

----

==== `file.list.filter-existing`

[source,bash]
----
file.list.filter-existing () 
{ 
    for file in "$@"
    do
        [[ -f "${file}" ]] && echo "${file}"
    done
}

----

==== `file.list.filter-non-empty`

[source,bash]
----
file.list.filter-non-empty () 
{ 
    for file in "$@"
    do
        [[ -s "${file}" ]] && echo "${file}"
    done
}

----

==== `file.size`

[source,bash]
----
file.size () 
{ 
    AppCurrentOS=${AppCurrentOS:-$(uname -s)}
    if [[ "Linux" == ${AppCurrentOS} ]]; then
        stat -c %s "$1"
    else
        file.stat "$1" st_size
    fi
}

----

==== `file.size.mb`

[source,bash]
----
file.size.mb () 
{ 
    local file="$1"
    shift
    local s=$(file.size "${file}")
    local mb=$(echo $((s / 10000)) | sedx 's/([0-9][0-9])$/.\1/g')
    printf "%.2f MB" ${mb}
}

----

==== `file.source-if-exists`

[source,bash]
----
file.source-if-exists () 
{ 
    local file
    for file in "$@"
    do
        [[ -f "${file}" ]] && source "${file}"
    done
}

----

==== `file.stat`

[source,bash]
----
file.stat () 
{ 
    local file="$1"
    local field="$2"
    [[ -f ${file} ]] || { 
        error "file ${file} is not found. Usage: file.stat <filename> <stat-field-name>"
        info "eg: ${bldylw}file.stat README.md st_size"
        return 1
    }
    [[ -n ${field} ]] || { 
        error "Second argument field is required."
        info "eg: ${bldylw}file.stat README.md st_size"
        return 2
    }
    eval $(stat -s "${file}" | tr ' ' '\n' | sed 's/^/local /g')
    echo ${!field}
}

----

==== `file.strip.extension`

[source,bash]
----
file.strip.extension () 
{ 
    file.extension.remove "$@"
}

----

==== `file.temp`

[source,bash]
----
file.temp () 
{ 
    local host="${HOST:-${HOSTNAME:-$(hostname)}}"
    local user="${USER:-"$(whoami)"}"
    local temp_file_pattern=".bashmatic.${host}.${user}."
    local n="$(epoch)"
    local t=$(( n % 99991 ))
    local file="/tmp/${temp_file_pattern}${n}$$${t}${RANDOM}${RANDOM}"
    find "$(dirname "${file}")" -maxdepth 1 -type f -name "${temp_file_pattern}*" -mtime +1 -delete > /dev/null 2>&1
    echo "${file}"
}

----

==== `files.find`

[source,bash]
----
files.find () 
{ 
    local folder="$1"
    local pattern="${2}"
    [[ -z ${folder} || -z ${pattern} ]] && { 
        echo "usage: files.find <folder> <pattern>" 1>&2
        return 1
    }
    find "$1" -name "${pattern}"
}

----

==== `files.map`

[source,bash]
----
files.map () 
{ 
    local folder="${1}"
    local pattern="${2}"
    local array="${3}"
    local -a files
    if bashmatic.bash.version-four-or-later; then
        mapfile -t files < <(files.find "${folder}" "${pattern}")
    else
        files=()
        while IFS='' read -r line; do
            files+=("$line")
        done < <(files.find "${folder}" "${pattern}")
    fi
    if [[ -n ${array} ]]; then
        printf "%s" "unset ${array}; declare -a ${array}; ${array}=(${files[*]}); export ${array}"
    else
        printf "%s" "${files[*]}"
    fi
}

----

==== `files.map.shell-scripts`

[source,bash]
----
files.map.shell-scripts () 
{ 
    files.map "$1" '*.sh' "$2"
}

----


=== Module `ftrace`

==== `ftrace-in`

[source,bash]
----
ftrace-in () 
{ 
    local func=$1
    shift
    local args="$*"
    [[ -z ${TraceON} ]] && return
    export __LibTrace__StackLevel=$(( ${__LibTrace__StackLevel} + 1 ))
    printf "    %*s ${bldylw}%s${bldblu}(%s)${clr}\n" ${__LibTrace__StackLevel} ' ' ${func} "${args}" 1>&2
}

----

==== `ftrace-off`

[source,bash]
----
ftrace-off () 
{ 
    unset TraceON
}

----

==== `ftrace-on`

[source,bash]
----
ftrace-on () 
{ 
    export TraceON=true
}

----

==== `ftrace-out`

[source,bash]
----
ftrace-out () 
{ 
    local func=$1
    shift
    local code=$1
    shift
    local msg="$*"
    [[ -z ${TraceON} ]] && return
    local color="${bldgrn}"
    [[ ${code} -ne 0 ]] && color="${bldred}"
    printf "    %*s ${bldylw}%s() ${color} âžœ  %d %s\n\n" ${__LibTrace__StackLevel} ' ' ${func} ${code} "${msg}" 1>&2
    export __LibTrace__StackLevel=$(( ${__LibTrace__StackLevel} - 1 ))
}

----


=== Module `gem`

==== `g-i`

[source,bash]
----
g-i () 
{ 
    gem.install "$@"
}

----

==== `g-u`

[source,bash]
----
g-u () 
{ 
    gem.uninstall "$@"
}

----

==== `gem.cache-installed`

[source,bash]
----
gem.cache-installed () 
{ 
    gem.configure-cache
    if [[ ! -s "${LibGem__GemListCache}" || -z $(find "${LibGem__GemListCache}" -mmin -30 2>/dev/null) ]]; then
        run "gem list > ${LibGem__GemListCache}" > /dev/null
    fi
}

----

==== `gem.cache-refresh`

[source,bash]
----
gem.cache-refresh () 
{ 
    ( gem.configure-cache
    gem.clear-cache
    gem.cache-installed ) > /dev/null
}

----

==== `gem.cache-reset`

[source,bash]
----
gem.cache-reset () 
{ 
    gem.cache-refresh
}

----

==== `gem.clear-cache`

[source,bash]
----
gem.clear-cache () 
{ 
    rm -f "${LibGem__GemListCache}" > /dev/null
}

----

==== `gem.configure-cache`

[source,bash]
----
gem.configure-cache () 
{ 
    export LibGem__GemListCacheBase="${BASHMATIC_TEMP}/.gem/gem.list"
    export LibGem__GemListCache=
    export LibGem__GemInstallFlags=" -N --force --quiet "
    local ruby_version=$(ruby.numeric-version)
    export LibGem__GemListCache="${LibGem__GemListCacheBase}.${ruby_version}"
    local dir=$(dirname ${LibGem__GemListCache})
    [[ -d ${dir} ]] || run "mkdir -p ${dir}" > /dev/null
}

----

==== `gem.ensure-gem-version`

[source,bash]
----
gem.ensure-gem-version () 
{ 
    local gem=$1
    local gem_version=$2
    [[ -z ${gem} || -z ${gem_version} ]] && return
    gem.cache-installed
    if [[ -z $(cat ${LibGem__GemListCache} | grep "${gem} (${gem_version})") ]]; then
        gem.uninstall ${gem}
        gem.install ${gem} ${gem_version}
    else
        info "gem ${gem} version ${gem_version} is already installed."
    fi
}

----

==== `gem.gemfile.bundler-version`

[source,bash]
----
gem.gemfile.bundler-version () 
{ 
    [[ -f Gemfile.lock ]] && grep -A2 BUNDLED Gemfile.lock | tail -1 | tr -d ' '
}

----

==== `gem.gemfile.version`

[source,bash]
----
gem.gemfile.version () 
{ 
    local gem=$1
    [[ -z ${gem} ]] && return
    if [[ -f Gemfile.lock ]]; then
        grep -E -e "^    ${gem} \([0-9]+\.[0-9]+\.[0-9](\.[a-zA-Z0-9]+)?\)" Gemfile.lock | awk '{print $2}' | sed 's/[()]//g'
    fi
}

----

==== `gem.global.latest-version`

[source,bash]
----
gem.global.latest-version () 
{ 
    local gem="$1"
    [[ -z ${gem} ]] && return
    declare -a versions=($(gem.global.versions ${gem}))
    local max=0
    local max_version=${versions[0]}
    for v in "${versions[@]}"
    do
        vi=$(util.ver-to-i "${v}")
        if [[ ${vi} -gt ${max} ]]; then
            max=${vi}
            max_version="${v}"
        fi
    done
    printf "%s" "${max_version}"
}

----

==== `gem.global.versions`

[source,bash]
----
gem.global.versions () 
{ 
    local gem=$1
    [[ -z ${gem} ]] && return
    gem.cache-installed
    cat "${LibGem__GemListCache}" | grep -E -e "^${gem} " | sedx "s/^${gem} //g;s/[(),]//g"
}

----

==== `gem.install`

[source,bash]
----
gem.install () 
{ 
    .gem.verify-name "$@" || return 1
    local gem_name="$1"
    local gem_version="$2"
    local gem_version_flags=
    local gem_version_name=
    gem_version=${gem_version:-$(gem.version ${gem_name})}
    if [[ -z ${gem_version} ]]; then
        gem_version_name=latest
        gem_version_flags=
    else
        gem_version_name="${gem_version}"
        gem_version_flags="--version ${gem_version}"
    fi
    if gem.is-installed ${gem_name} ${gem_version}; then
        info: "gem ${bldylw}${gem_name} (${bldgrn}${gem_version_name}${bldylw})${txtblu} is already installed"
    else
        info "installing ${bldylw}${gem_name} ${bldgrn}(${gem_version_name})${txtblu}..."
        run "gem install ${gem_name} ${gem_version_flags} ${LibGem__GemInstallFlags}"
        if [[ ${LibRun__LastExitCode} -eq 0 ]]; then
            rbenv rehash > /dev/null 2> /dev/null
            gem.cache-refresh
        else
            error "Unable to install gem ${bldylw}${gem_name}"
        fi
        return ${LibRun__LastExitCode}
    fi
}

----

==== `gem.is-installed`

[source,bash]
----
gem.is-installed () 
{ 
    local gem=$1
    local version=$2
    gem.cache-installed > /dev/null
    if [[ -z ${version} ]]; then
        grep -q -E -e "^${gem} \(" "${LibGem__GemListCache}"
    else
        grep -E -e "^${gem} \(" "${LibGem__GemListCache}" | grep -E -q -e "${version}"
    fi
}

----

==== `gem.remote.version`

[source,bash]
----
gem.remote.version () 
{ 
    [[ -z "$1" ]] && return
    gem query "$1" --remote -e | sedx "s/^${1} //g; s/[(),]//g"
}

----

==== `gem.uninstall`

[source,bash]
----
gem.uninstall () 
{ 
    .gem.verify-name "$@" || return 1
    local gem_name=$1
    local gem_version=$2
    gem.is-installed "${gem_name}" "${gem_version}" || { 
        info "gem ${bldylw}${gem_name}${txtblu} is not installed"
        return
    }
    local gem_flags="-x -I --force"
    if [[ -z ${gem_version} ]]; then
        gem_flags="${gem_flags} -a"
    else
        gem_flags="${gem_flags} --version ${gem_version}"
    fi
    run "gem uninstall ${gem_name} ${gem_flags}"
    gem.clear-cache
    return ${LibRun__LastExitCode}
}

----

==== `gem.version`

[source,bash]
----
gem.version () 
{ 
    local gem="$1"
    local default="$2"
    [[ -z ${gem} ]] && return
    local version
    [[ -f Gemfile.lock ]] && version=$(gem.gemfile.version "${gem}")
    if [[ -z ${version} ]]; then
        if gem.is-installed "${gem}"; then
            version=$(gem.global.latest-version "${gem}")
        else
            version=$(gem.remote.version "${gem}")
        fi
    fi
    [[ -z ${version} && -n ${default} ]] && version=${default}
    printf "%s" "${version}"
}

----


=== Module `git`

==== `bashmatic.auto-update`

[source,bash]
----
bashmatic.auto-update () 
{ 
    [[ ${Bashmatic__Test} -eq 1 ]] && return 0
    git.configure-auto-updates
    git.repo-is-clean || { 
        output.is-ssh || { 
            output.is-terminal && bashmatic.is-developer && attention "Bashmatic folder has local changes, can't auto-update." 1>&2
        }
        return 1
    }
    git.sync
}

----

==== `git.branch.current`

[source,bash]
----
git.branch.current () 
{ 
    git rev-parse --abbrev-ref HEAD
}

----

==== `git.cfgu`

[source,bash]
----
git.cfgu () 
{ 
    [[ -z $1 ]] && { 
        git config --global -l
        return
    }
    if [[ -n $2 ]]; then
        rm -f ~/.gitconfig.lock
        git config --global --replace-all user.$1 $2
    else
        if [[ $1 =~ - ]]; then
            git config --global $1
        else
            git config --global user.$1
        fi
    fi
}

----

==== `git.commits.last.message`

[source,bash]
----
git.commits.last.message () 
{ 
    git log --pretty=format:"%s" -1
}

----

==== `git.commits.last.sha`

[source,bash]
----
git.commits.last.sha () 
{ 
    git log --pretty=format:"%H" -1
}

----

==== `git.config.kigster`

[source,bash]
----
git.config.kigster () 
{ 
    [[ $(git.cfgu name) == "Konstantin Gredeskoul" && $(git.cfgu email) == "kigster@gmail.com" ]] && return 0
    git.cfgu name "Konstantin Gredeskoul"
    git.cfgu email "kigster@gmail.com"
}

----

==== `git.configure-auto-updates`

[source,bash]
----
git.configure-auto-updates () 
{ 
    export LibGit__StaleAfterThisManyHours="${LibGit__StaleAfterThisManyHours:-"1"}"
    export LibGit__LastUpdateTimestampFile="${BASHMATIC_TEMP}/.config/$(echo ${USER} | util.checksum.stdin)"
    mkdir -p "$(dirname ${LibGit__LastUpdateTimestampFile})"
}

----

==== `git.current-branch`

[source,bash]
----
git.current-branch () 
{ 
    git branch --no-color | grep -F "*" | cut -f 2 -d " "
}

----

==== `git.is-it-time-to-update`

[source,bash]
----
git.is-it-time-to-update () 
{ 
    local last_update_at=$(git.last-update-at)
    local second_since_update=$(git.seconds-since-last-pull ${last_update_at})
    local update_period_seconds=$((LibGit__StaleAfterThisManyHours * 60 * 60))
    [[ ${second_since_update} -gt ${update_period_seconds} ]]
}

----

==== `git.last-update-at`

[source,bash]
----
git.last-update-at () 
{ 
    git.configure-auto-updates
    local file="${1:-"${LibGit__LastUpdateTimestampFile}"}"
    local last_update=0
    if [[ ${LibGit__ForceUpdate} -eq 0 && -f ${file} ]]; then
        last_update="$(cat $file | tr -d '\n')"
    else
        last_update=0
    fi
    printf "%d" ${last_update}
}

----

==== `git.local-vs-remote`

[source,bash]
----
git.local-vs-remote () 
{ 
    local upstream=${1:-'@{u}'}
    local local_repo=$(git rev-parse @)
    local remote_repo=$(git rev-parse "$upstream")
    local base=$(git merge-base @ "$upstream")
    if [[ -n ${DEBUG} ]]; then
        printf "
      pwd         = $(pwd)
      remote      = $(git.remotes)
      base        = ${base}
      upstream    = ${upstream}
      local_repo  = ${local_repo}
      remote_repo = ${remote_repo}
    "
    fi
    local result=
    if [[ "${local_repo}" == "${remote_repo}" ]]; then
        result="ok"
    else
        if [[ "${local_repo}" == "${base}" ]]; then
            result="behind"
        else
            if [[ "${remote_repo}" == "${base}" ]]; then
                result="ahead"
            else
                result="diverged"
            fi
        fi
    fi
    printf '%s' ${result}
    [[ ${result} == "ok" ]] && return 0
    return 1
}

----

==== `git.open`

[source,bash]
----
git.open () 
{ 
    local remote="${1:-"origin"}"
    local url=$(git remote get-url origin | sed -E 's/git@/https:\/\//g;s/com:/com\//g')
    info "Opening URL ${bldylw}${url}"
    open -a 'Google Chrome' ${url}
}

----

==== `git.quiet`

[source,bash]
----
git.quiet () 
{ 
    [[ -n ${LibGit__QuietUpdate} ]]
}

----

==== `git.remotes`

[source,bash]
----
git.remotes () 
{ 
    git remote -v | awk '{print $2}' | uniq
}

----

==== `git.repo-is-clean`

[source,bash]
----
git.repo-is-clean () 
{ 
    local repo="${1:-${BASHMATIC_HOME}}"
    cd "${repo}" > /dev/null
    if [[ -z $(git status -s) ]]; then
        cd - > /dev/null
        return 0
    else
        cd - > /dev/null
        return 1
    fi
}

----

==== `git.repo.remote-to-git@`

[source,bash]
----
git.repo.remote-to-git@ () 
{ 
    local f=".git/config"
    if [[ -f "$f" ]]; then
        grep -q "url = git@" "$f" && { 
            info "The repo is already using git@ syntax for the remote."
            return 0
        }
        cat "${f}" | sed -E 's#url = https://github\.com/([^/]*)/#url = git@github\.com:\1/#g' > "${f}.ssh"
        mv "${f}" "${f}.https"
        cd .git
        ln -nfs config.ssh config
        cd - > /dev/null
        hr
        info "Created an ssh version of .git/config file, and symlinked it:"
        ls -l .git/config*
        info "Your new remote:"
        info $(grep "git@" "${f}")
        hr
    fi
}

----

==== `git.save-last-update-at`

[source,bash]
----
git.save-last-update-at () 
{ 
    echo $(epoch) > ${LibGit__LastUpdateTimestampFile}
}

----

==== `git.seconds-since-last-pull`

[source,bash]
----
git.seconds-since-last-pull () 
{ 
    local last_update="$1"
    local now=$(epoch)
    printf $((now - last_update))
}

----

==== `git.squash`

[source,bash]
----
git.squash () 
{ 
    local number="${1}"
    is.numeric ${number} || { 
        info "USAGE: git.squash <number> # of commits to go back"
        return
    }
    run "git reset --soft HEAD~${number}"
    info "We've squashed down ${number} commits locally."
    info "Now, you must commit this squash, and likely force push."
}

----

==== `git.sync`

[source,bash]
----
git.sync () 
{ 
    local dir="$(pwd)"
    cd "${BASHMATIC_HOME}" > /dev/null
    git.repo-is-clean || { 
        output.is-ssh || warning "${BASHMATIC_HOME} has locally modified files." "Please commit or stash them to allow auto-upgrade to function as designed." 1>&2
        cd "${dir}" > /dev/null
        return 1
    }
    git.update-repo-if-needed
    cd "${dir}" > /dev/null
    return 0
}

----

==== `git.sync-dirs`

[source,bash]
----
git.sync-dirs () 
{ 
    local pattern="${1:-'*'}"
    set -e
    run.set-all abort-on-error
    for dir in $(find . -type d -maxdepth 1 -name "${pattern}*")
    do
        hl.yellow-on-gray "syncing [$dir]..."
        cd $dir > /dev/null
        run "git pull --rebase"
        cd - > /dev/null
    done
}

----

==== `git.sync-remote`

[source,bash]
----
git.sync-remote () 
{ 
    git.is-it-time-to-update || return 0
    if git.quiet; then
        ( git remote update && git fetch ) 2>&1 > /dev/null
    else
        run "git remote update && git fetch"
    fi
    local git_status="$(git.local-vs-remote)"
    if [[ ${git_status} == "behind" ]]; then
        git.quiet || run "git pull --rebase"
        git.quiet && git pull --rebase 2>&1 > /dev/null
    else
        if [[ ${git_status} != "ahead" ]]; then
            git.save-last-update-at
        else
            if [[ ${git_status} != "ok" ]]; then
                error "Report $(pwd) is ${status} compared to the remote." "Please fix manually to continue."
                return 1
            fi
        fi
    fi
    git.save-last-update-at
    return 0
}

----

==== `git.update-repo-if-needed`

[source,bash]
----
git.update-repo-if-needed () 
{ 
    git.is-it-time-to-update && git.sync-remote
}

----

==== `git.upstream`

[source,bash]
----
git.upstream () 
{ 
    local this_branch=$(git.current-branch)
    this_branch=${this_branch:-master}
    run.set-next show-output-on
    run "git branch --set-upstream-to=origin/${this_branch} ${this_branch}"
}

----


=== Module `github`

==== `github.clone`

[source,bash]
----
github.clone () 
{ 
    test -n "$1" && github.validate && run "git clone git@github.com:$(github.org)/$1"
}

----

==== `github.org`

[source,bash]
----
github.org () 
{ 
    local namespace="$1"
    if [[ -z ${namespace} ]]; then
        git config --global --get user.github
    else
        git config --global --unset user.github
        git config --global --add user.github "${namespace}"
    fi
}

----

==== `github.setup`

[source,bash]
----
github.setup () 
{ 
    local namespace="$(github.org)"
    if [[ -z "${namespace}" ]]; then
        unset GITHUB_ORG
        run.ui.ask-user-value GITHUB_ORG "Please enter the name of your Github Organization:" || return 1
        github.org "${GITHUB_ORG}"
        echo
        h2 "Your github organization was saved in your ~/.gitconfig file." "To change it in the future, run: ${bldylw}github.org ${blgrn}new-organization"
        echo
    fi
    github.org > /dev/null
}

----

==== `github.validate`

[source,bash]
----
github.validate () 
{ 
    inf "Validating Github Configuration..."
    if github.org > /dev/null; then
        ok:
        return 0
    else
        not-ok:
        github.setup
        return $?
    fi
}

----


=== Module `is`

==== `is-validations`

[source,bash]
----
is-validations () 
{ 
    util.functions-matching.diff is\\. | sedx 's/^/is./g'
}

----

==== `is.a-directory`

[source,bash]
----
is.a-directory () 
{ 
    [[ -d "${1}" ]]
}

----

==== `is.a-function`

[source,bash]
----
is.a-function () 
{ 
    local shell="$(user.current-shell)"
    case $shell in 
        bash)
            declare -f "$1" > /dev/null
        ;
        zsh)
            type "$1" | grep -q function
        ;
        *)
            return 1
        ;
    esac
}

----

==== `is.a-non-empty-array`

[source,bash]
----
is.a-non-empty-array () 
{ 
    local var_name="$1"
    local -a array
    echo "array=( \"\${${var_name}[@]}\" )"
    eval "array=( \"\${${var_name}[@]}\" )"
    [[ -n ${array[*]} && ${var_name} =~ ^[0-9a-zA-Z_]+$ && ${#array[@]} -gt 0 ]]
}

----

==== `is.a-non-empty-file`

[source,bash]
----
is.a-non-empty-file () 
{ 
    [[ -s "${1}" ]]
}

----

==== `is.a-script`

[source,bash]
----
is.a-script () 
{ 
    bashmatic.detect-subshell
    [[ ${BASH_IN_SUBSHELL} -eq 1 ]]
}

----

==== `is.a-variable`

[source,bash]
----
is.a-variable () 
{ 
    local var_name="$1"
    [[ -n ${var_name} && ${var_name} =~ ^[0-9a-zA-Z_]+$ && -n ${!var_name+x} ]]
}

----

==== `is.alias`

[source,bash]
----
is.alias () 
{ 
    alias "$1" 2> /dev/null
}

----

==== `is.an-empty-file`

[source,bash]
----
is.an-empty-file () 
{ 
    [[ ! -s "${1}" ]]
}

----

==== `is.an-existing-file`

[source,bash]
----
is.an-existing-file () 
{ 
    [[ -f "${1}" ]]
}

----

==== `is.blank`

[source,bash]
----
is.blank () 
{ 
    [[ -z "${1}" ]]
}

----

==== `is.command`

[source,bash]
----
is.command () 
{ 
    command -v "$1" > /dev/null
}

----

==== `is.integer`

[source,bash]
----
is.integer () 
{ 
    is.numeric "$1" && [[ ! $1 =~ \. ]]
}

----

==== `is.missing`

[source,bash]
----
is.missing () 
{ 
    ! is.command "$@"
}

----

==== `is.not-a-blank-var`

[source,bash]
----
is.not-a-blank-var () 
{ 
    local var="$1"
    [[ -n "${!var}" ]]
}

----

==== `is.not-blank`

[source,bash]
----
is.not-blank () 
{ 
    [[ -n "${1}" ]]
}

----

==== `is.numeric`

[source,bash]
----
is.numeric () 
{ 
    case $1 in 
        '' | *[!\-0-9.]*)
            return 1
        ;
        *)
            return 0
        ;
    esac
}

----

==== `is.sourced-in`

[source,bash]
----
is.sourced-in () 
{ 
    bashmatic.detect-subshell
    [[ ${BASH_IN_SUBSHELL} -eq 0 ]]
}

----

==== `unless`

[source,bash]
----
unless () 
{ 
    ! __is.validation.error "${2}" "${1}" __is.validation.ignore-error "${@:3}"
}

----

==== `validations.add-error`

[source,bash]
----
validations.add-error () 
{ 
    local error="$1"
    local value="$2"
    is.not-blank "${error}" && is.not-blank "${value}" && { 
        export Bashmatic__IsErrors+=("${error}")
        export Bashmatic__IsValues+=("${value}")
    }
}

----

==== `validations.begin`

[source,bash]
----
validations.begin () 
{ 
    export Bashmatic__IsErrors=()
    export Bashmatic__IsValues=()
    export Bashmatic__IsSessionName="$1"
}

----

==== `validations.end`

[source,bash]
----
validations.end () 
{ 
    validations.print-errors "$@"
    validations.begin ""
}

----

==== `validations.print-errors`

[source,bash]
----
validations.print-errors () 
{ 
    local error_count="${#Bashmatic__IsErrors}"
    ((error_count)) || return 0
    is.not-blank "${Bashmatic__IsSessionName}" && hl.salmon "Reporing errors for ${Bashmatic__IsSessionName}"
    for i in $(seq 1 "${error_count}")
    do
        local error=${Bashmatic__IsErrors[$((i - 1))]}
        local value=${Bashmatic__IsValues[$((i - 1))]}
        error "${error}" "Invalid value: ${value}"
    done
    return "${error_count}"
}

----

==== `whenever`

[source,bash]
----
whenever () 
{ 
    __is.validation.error "${2}" "${1}" __is.validation.report-error "${@:3}"
}

----


=== Module `jemalloc`

==== `jm.check`

[source,bash]
----
jm.check () 
{ 
    local JM_Quiet=false
    local JM_Ruby=false
    local JM_Stats=false
    while :; do
        case $1 in 
            -q | --quiet)
                shift
                export JM_Quiet=true
            ;
            -r | --ruby)
                shift
                export JM_Ruby=true
            ;
            -s | --stats)
                shift
                export JM_Stats=true
                exit $?
            ;
            -h | -\? | --help)
                shift
                jm.usage
                exit 0
            ;
            --)
                shift
                break
            ;
            *)
                break
            ;
        esac
    done
    ${JM_Ruby} && { 
        jm.ruby.report
        exit 0
    }
    ${JM_Quiet} && { 
        jm.jemalloc.detect-quiet
        code=$?
        exit ${code}
    }
    ${JM_Stats} && { 
        jm.jemalloc.stats
        exit 0
    }
    jm.jemalloc.detect-loud
}

----

==== `jm.jemalloc.detect-loud`

[source,bash]
----
jm.jemalloc.detect-loud () 
{ 
    jm.jemalloc.detect-quiet
    local code=$?
    local local_ruby=$(jm.ruby.detect)
    printf "${ColorBlue}Checking if ruby ${ColorYellow}${local_ruby}${ColorBlue} is linked with jemalloc... \n\n "
    if [[ ${code} -eq 0 ]]; then
        printf " âœ… ${ColorGreen} â€”Â jemalloc was detected.\n"
    else
        printf " ðŸš« ${ColorRed} â€” jemalloc was not detected.\n"
    fi
    printf "${ColorReset}\n"
    return ${code}
}

----

==== `jm.jemalloc.detect-quiet`

[source,bash]
----
jm.jemalloc.detect-quiet () 
{ 
    MALLOC_CONF=stats_print:true ruby -e "exit" 2>&1 | grep -q "jemalloc statistics"
    return $?
}

----

==== `jm.jemalloc.stats`

[source,bash]
----
jm.jemalloc.stats () 
{ 
    jm.jemalloc.detect-quiet || { 
        printf "No Jemalloc was found for the curent ruby $(jm.ruby.detect)\n"
        return 1
    }
    MALLOC_CONF=stats_print:true ruby -e "exit" 2>&1 | less -S
}

----

==== `jm.ruby.detect`

[source,bash]
----
jm.ruby.detect () 
{ 
    local ruby_loc
    if [[ -n $(which rbenv) ]]; then
        ruby_loc=$(rbenv versions | grep '*' | awk '{print $2}')
        [[ -n ${ruby_loc} ]] && ruby_loc="(rbenv) ${ruby_loc}"
    else
        ruby_loc="$(which ruby) $(ruby -e 'puts "#{RUBY_VERSION} (#{RUBY_PLATFORM})"')"
    fi
    printf "%s" "${ruby_loc}"
}

----

==== `jm.ruby.report`

[source,bash]
----
jm.ruby.report () 
{ 
    printf "Ruby version being tested:\n  â†’  ${ColorBlue}$(which ruby) ${ColorYellow}$(jm.ruby.detect)${ColorReset}\n"
}

----

==== `jm.usage`

[source,bash]
----
jm.usage () 
{ 
    printf "
${ColorBlue}USAGE:${ColorReset}
  $(basename $0) [ -q/--quiet ]
                 [ -r/--ruby  ]
                 [ -s/--stats ]
                 [ -h/--help  ]

${ColorBlue}DESCRIPTION:${ColorReset}
  Determines whether the currently defined in the PATH ruby
  interpreter is linked with libjemalloc memory allocator.

${ColorBlue}OPTIONS${ColorReset}
  -q/--quiet        Do not print output, exit with 1 if no jemalloc
  -r/--ruby         Print which ruby is currently in the PATH
  -s/--stats        Print the jemalloc stats
  -h/--help         This page.
%s
" ""
    exit 0
}

----


=== Module `json`

==== `json.begin-array`

[source,bash]
----
json.begin-array () 
{ 
    [[ -n "$1" ]] && json.begin-key "$1"
    echo " ["
}

----

==== `json.begin-hash`

[source,bash]
----
json.begin-hash () 
{ 
    [[ -n "$1" ]] && json.begin-key "$1"
    echo "{"
}

----

==== `json.begin-key`

[source,bash]
----
json.begin-key () 
{ 
    if [[ -n "$1" ]]; then
        printf "\"${1}\": "
    fi
}

----

==== `json.end-array`

[source,bash]
----
json.end-array () 
{ 
    printf "]"
    [[ "$1" == "true" ]] && printf ","
    echo
}

----

==== `json.end-hash`

[source,bash]
----
json.end-hash () 
{ 
    printf "}"
    [[ "$1" == "true" ]] && printf ","
    echo
}

----

==== `json.file-to-array`

[source,bash]
----
json.file-to-array () 
{ 
    json.begin-array "$1"
    cat $2 | tr -d '\r' | tr -d '\015' | sed 's/^/"/g;s/$/",/g' | tail -r | awk -F, '{if (FNR!=1) print; else print $1} ' | tail -r
    json.end-array $3
}

----


=== Module `maths`

==== `maths.eval`

[source,bash]
----
maths.eval () 
{ 
    local __math_chars=(!Â²Â³Â¹Â¼Â½Â¾Ã—Ã·Î Î£â°â±â´âµâ¶â·â¸â¹â¿â…“â…”â…•â…–â…—â…˜â…™â…šâ…›â…œâ…â…žâˆ…âˆˆâˆ‰âˆšâˆ›âˆœâˆžâˆ©âˆªâˆ¿âŠ‚âŠƒâŸŒÏ„ð›•ðœð‰ðžƒðž½à¥¦à¥§à¥¨à¥©à¥ªà¥«à¥¬à¥­à¥®à¥¯â„¯ðžð‘’ð’†ð–¾ð—²ð˜¦ð™šðšŽï½…Ï€Ï–ð›‘ð›¡ðœ‹ðœ›ð…ð•ð¿ðžðž¹ðŸ‰ð¢ð‘–ð’Šð’¾ð“²ð”¦ð•šð–Žð—‚ð—¶ð˜ªð™žðš’)
    local -a __math_chars_array=($(echo "${__math_chars}" | sedx 's/(.)/\1 /g'))
    local __math_chars_array
    [[ -z "$1" ]] && { 
        output.set-max-width 100
        output.set-min-width 40
        usage-box "maths.eval 'expression' [ floating precitions [ total width ] Â© Computes a mathematical expression with UTF support" "Example 1." "maths.eval 'âˆš(57)*â…“Ã—(sin(Ï€Ã·(1.3)))' => 1.66882" "Example 2." "maths.eval '5!Ã—(ï½…)' => 326.19382" "Special Characters:" "" " 0 through 23" "${__math_chars_array[*]:0:24}" "24 through 48" "${__math_chars_array[*]:24:24}" "48 through 72" "${__math_chars_array[*]:48:24}" "72 through 96" "${__math_chars_array[*]:72:24}"
        info "NOTE: ensure to use () brackets to group items you want to compute."
        info "NOTE: if in doubt, add more brackets :) "
        output.reset-min-max-width
        return 0
    }
    gem.install unicode_math > /dev/null
    local expression="$1"
    shift
    local output_precision="${1:-"5"}"
    shift
    local output_width="${1}"
    local ruby_script="require 'unicode_math'; printf('%${output_width}.${output_precision}f', (Math.module_eval { ${expression} }))"
    ruby_script="$(echo "${ruby_script}" | sedx 's/ ?(Ã—|Ã·|!)/\.\1/g')"
    local temp_file
    temp_file="$(mktemp)"
    ruby -r 'unicode_math' -e "${ruby_script}" 2> "${temp_file}"
    local code="$?"
    [[ ${code} -ne 0 ]] && { 
        error "Unable to perform an arithmetic expression:" "${bldylw}${ruby_script}" 1>&2
        info "Error: \n${bldylw}$(cat "${temp_file}")"
        return 1
    }
    rm -f "${temp_file}"
    return 0
}

----


=== Module `net`

==== `net.fast-scan`

[source,bash]
----
net.fast-scan () 
{ 
    local subnet="${1:-"$(net.local-subnet)"}"
    local out=$(mktemp)
    run.set-next show-output-on
    local colored=/tmp/colored.$$
    run "sudo nmap --min-parallelism 15 -O --host-timeout 5 -F ${subnet} > ${out}"
    run "echo 'printf \"' > ${colored}"
    cat ${out} | sed -E "s/Nmap scan report for (.*)$/\n\${bldylw}Nmap scan report for \1\${clr}\n/g" >> ${colored}
    run "echo '\"' >> ${colored}"
    bash ${colored}
}

----

==== `net.local-net`

[source,bash]
----
net.local-net () 
{ 
    ifconfig -a | grep inet | grep broadcast | awk '{print $2}' | awk 'BEGIN{FS="."}{printf "%d.%d.%d.%s", $1, $2, $3, "0/24"}'
}

----

==== `net.local-subnet`

[source,bash]
----
net.local-subnet () 
{ 
    local subnet="$(ifconfig -a |
    grep inet | grep broadcast | 
    grep -v 'inet 169' |
    grep -v 'inet 127' |
    awk '{print $2}' |
    cut -d '.' -f 1,2,3 |
    sort |
    uniq |
    head -1).0/24"
    printf '%s' ${subnet}
}

----


=== Module `openssl`

==== `openssl.certs.generate-csr`

[source,bash]
----
openssl.certs.generate-csr () 
{ 
    local domain="${1:-"domain"}"
    local subject="${2:-"${default_certificate_info}"}${domain}"
    local server="${domain/\*/star}"
    hl.desc "Generating CSR + Private Key for domain [${domain}]"
    set -e
    openssl req -new -newkey rsa:4096 -nodes -keyout "${server}.key" -out "${server}.csr" -subj "${subject}"
    pbcopy < "${server}.csr"
    success "CSR is now in the file ${server}.csr and your clipboard."
    set +e
    .openssl.certs.print-generated "${server}.csr" 2> /dev/null
    return 0
}

----


=== Module `osx`

==== `afp.servers`

[source,bash]
----
afp.servers () 
{ 
    osx.local-servers afp
}

----

==== `bashmatic-set-fqdn`

[source,bash]
----
bashmatic-set-fqdn () 
{ 
    osx.set-fqdn "$@"
}

----

==== `bashmatic-term`

[source,bash]
----
bashmatic-term () 
{ 
    open $(bashmatic-term-program)
}

----

==== `bashmatic-term-program`

[source,bash]
----
bashmatic-term-program () 
{ 
    if [[ -d /Applications/iTerm.app ]]; then
        printf '%s' /Applications/iTerm.app
    else
        if [[ -d /Applications/Utilities/Terminal.app ]]; then
            printf '%s' /Applications/Utilities/Terminal.app
        else
            printf '%s' "echo 'No TERMINAL application found'"
        fi
    fi
}

----

==== `change-underscan`

[source,bash]
----
change-underscan () 
{ 
    set +e
    local amount_percentage="$1"
    if [[ -z "${amount_percentage}" ]]; then
        printf "%s\n\n" "USAGE: change-underscan percent"
        printf "%s\n" "   eg: change-underscan   5  # underscan by 5%"
        printf "%s\n" "   eg: change-underscan -10  # overscan by 10%"
        return -1
    fi
    local file="/var/db/.com.apple.iokit.graphics"
    local backup="/var/db/.com.apple.iokit.graphics.bak.$(date '+%F.%X')"
    local new_value=$(ruby -e "puts (10000.0 + 10000.0 * ${amount_percentage}.to_f / 100.0).to_i")
    h1 'This utility allows you to change underscan/overscan' 'on monitors that do not offer that option via GUI.'
    run.ui.ask "Continue?"
    info "Great! First we need to identify your monitor."
    hl.yellow "Please make sure that the external monitor is plugged in."
    run.ui.ask "Is it plugged in?"
    info "Making a backup of your current graphics settings..."
    inf "Please enter your password, if asked: "
    set -e
    bash -c 'set -e; sudo ls -1 > /dev/null; set +e'
    ok
    run "sudo rm -f \"${backup}\""
    export LibRun__AbortOnError=${True}
    run "sudo cp -v \"${file}\" \"${backup}\""
    h2 "Now: please change the resolution ${bldylw}on the problem monitor." "NOTE: it's ${italic}not important what resolution you choose," "as long as it's different than what you had previously..." "Finally: exit Display Preferences once you changed resolution."
    run "open /System/Library/PreferencePanes/Displays.prefPane"
    run.ui.ask "Have you changed the resolution and exited Display Prefs? "
    local line=$(sudo diff "${file}" "${backup}" 2>/dev/null | head -1 | /usr/bin/env ruby -ne 'puts $_.to_i')
    [[ -n $DEBUG ]] && info "diff line is at ${line}"
    value=
    if [[ "${line}" -gt 0 ]]; then
        line_pscn_key=$(($line - 4))
        line_pscn_value=$(($line - 3))
        ( awk "NR==${line_pscn_key}{print;exit}" "${file}" | grep -q pscn ) && { 
            value=$(awk "NR==${line_pscn_value}{print;exit}" "${file}" | awk 'BEGIN{FS="[<>]"}{print $3}')
            [[ -n $DEBUG ]] && info "current value is ${value}"
        }
    else
        error "It does not appear that anything changed, sorry."
        return -1
    fi
    h2 "Now, please unplug the problem monitor temporarily..."
    run.ui.ask "...and press Enter to continue "
    if [[ -n ${value} && ${value} -ne ${new_value} ]]; then
        export LibRun__AbortOnError=${True}
        run "sudo sed -i.backup \"${line_pscn_value}s/${value}/${new_value}/g\" \"${file}\""
        echo
        h2 "Congratulations!" "Your display underscan value has been changed."
        info "Previous Value â€” ${bldpur}${value}"
        info "New value:     â€” ${bldgrn}${new_value}"
        hr
        info "${bldylw}IMPORTANT!"
        info "You must restart your computer for the settings to take affect."
        echo
        run.ui.ask "Should I reboot your computer now? "
        info "Very well, rebooting!"
        run "sudo reboot"
    else
        warning "Unable to find the display scan value to change. "
        info "Could it be that you haven't restarted since your last run?"
        echo
        info "Feel free to edit file directly, using:"
        info "eg: ${bldylw}vim ${file} +${line_pscn_value}"
    fi
}

----

==== `cookie-dump`

[source,bash]
----
cookie-dump () 
{ 
    osx.cookie-dump "$@"
}

----

==== `http.servers`

[source,bash]
----
http.servers () 
{ 
    osx.local-servers http
}

----

==== `https.servers`

[source,bash]
----
https.servers () 
{ 
    osx.local-servers https
}

----

==== `osx.app.is-installed`

[source,bash]
----
osx.app.is-installed () 
{ 
    local app="$1"
    shift
    /bin/ls -1 /Applications ~/Applications | grep -E '\.app$' | sort -u | grep "$@" -E -i "${app}|${app/*-/}"
}

----

==== `osx.cookie-dump`

[source,bash]
----
osx.cookie-dump () 
{ 
    local file="$1"
    local tmp
    if [[ ! -s ${file} ]]; then
        tmp=$(mktemp)
        file=${tmp}
        pbpaste > "${file}"
        local size=$(file.size "${file}")
        if [[ ${size} -lt 4 ]]; then
            error "Pasted data is too small to be a valid cookie?"
            info "Here is what we got in your clipboard:\n\n$(cat ${file})\n"
            return 1
        fi
    fi
    if [[ -s ${file} ]]; then
        cat "${file}" | tr '; ' '\n' | sed '/^$/d' | awk 'BEGIN{FS="="}{printf( "%10d = %s\n", length($2), $1) }' | sort -n
    else
        info "File ${file} does not exist or is empty. "
        info "Copy the value of the ${bldylw}Set-Cookie:${txtblu} header into the clipboard,"
        info "and rerun this function."
    fi
    [[ -z ${tmp} ]] || rm -f ${tmp}
}

----

==== `osx.dropbox.exclude`

[source,bash]
----
osx.dropbox.exclude () 
{ 
    local dir="$1"
    if [[ -d "${dir}" ]]; then
        xattr -w com.dropbox.ignored 1 "$1"
    else
        error "Folder '${dir}' does not exist or is blank."
        return 1
    fi
}

----

==== `osx.dropbox.exclude-pwd`

[source,bash]
----
osx.dropbox.exclude-pwd () 
{ 
    xattr -w com.dropbox.ignored 1 "${PWD}"
}

----

==== `osx.env-print`

[source,bash]
----
osx.env-print () 
{ 
    local var="$1"
    printf "${bldylw}%20s: ${bldgrn}%s\n" ${var} ${!var}
}

----

==== `osx.local-servers`

[source,bash]
----
osx.local-servers () 
{ 
    local protocol="${1:-"ssh"}"
    run.set-next show-output-on
    run "timeout 20 dns-sd -B _${protocol}._tcp ."
}

----

==== `osx.ramdisk.mount`

[source,bash]
----
osx.ramdisk.mount () 
{ 
    local size="${1:-"8"}"
    local diskname="${2:-"ramdisk"}"
    local total=$((size * 2 * 1024))
    [[ $(uname -s) != "Darwin" ]] && { 
        error "This function only works on OSX"
        return 1
    }
    if [[ "${diskname}" =~ ' ' ]]; then
        error "Disk name can not contain spaces."
        return 1
    fi
    local path="/Volumes/${diskname}"
    if ( mount | ${GrepCommand} -q "/[V]olumes/${diskname}" ); then
        info "Looks like RAM disk already exists at ${path}..."
        return 1
    else
        run.ui.ask "Creating RAM disk sized ${size}Mb at ${path}"
        run.set-next show-output-on
        run "diskutil erasevolume HFS+ '${diskname}' $(hdiutil attach -nomount ram://${total})"
    fi
}

----

==== `osx.ramdisk.unmount`

[source,bash]
----
osx.ramdisk.unmount () 
{ 
    local diskname="${2:-"ramdisk"}"
    [[ $(uname -s) != "Darwin" ]] && { 
        error "This function only works on OSX"
        return 1
    }
    local path="/Volumes/${diskname}"
    if ( mount | ${GrepCommand} -q "/[V]olumes/${diskname}" ); then
        run.ui.ask "Unmount RAM disk at ${path}? "
        run "umount ${path}"
    else
        info "Couldn't find volume ${bldylw}${path}. Does the RAM disk exist?"
        return 1
    fi
}

----

==== `osx.scutil-print`

[source,bash]
----
osx.scutil-print () 
{ 
    local var="$1"
    printf "${bldylw}%20s: ${bldgrn}%s\n" ${var} $(sudo scutil --get ${var} | tr -d '\n')
}

----

==== `osx.set-fqdn`

[source,bash]
----
osx.set-fqdn () 
{ 
    local fqdn="$1"
    local domain=$(echo ${fqdn} | sed -E 's/^[^.]*\.//g')
    local host=$(echo ${fqdn} | sed -E 's/\..*//g')
    h1 "Current HostName: ${bldylw}${HOSTNAME}"
    echo
    info "â€¢ You provided the following FQDN : ${bldylw}${fqdn}"
    echo
    info "â€¢ Hostname will be set to: ${bldgrn}${host}"
    info "â€¢ Domain will also change: ${bldgrn}${domain}"
    echo
    run.ui.ask "Does that look correct to you?"
    echo
    inf "Now, please provide your SUDO password, if asked: "
    sudo printf '' || { 
        ui.closer.not-ok:
        exit 1
    }
    ui.closer.ok:
    run "sudo scutil --set HostName ${fqdn}"
    run "sudo scutil --set LocalHostName ${host}.local 2>/dev/null|| true"
    run "sudo scutil --set ComputerName ${host}"
    run "dscacheutil -flushcache"
    echo
    h2 "Result of the changes:"
    osx.scutil-print HostName
    osx.scutil-print LocalHostName
    osx.scutil-print ComputerName
    osx.env-print HOSTNAME
    echo
    hr
}

----

==== `ssh.servers`

[source,bash]
----
ssh.servers () 
{ 
    osx.local-servers ssh
}

----


=== Module `output`

==== `ascii-clean`

[source,bash]
----
ascii-clean () 
{ 
    .output.clean "$@"
}

----

==== `ascii-pipe`

[source,bash]
----
ascii-pipe () 
{ 
    cat | .output.clean.pipe
}

----

==== `center`

[source,bash]
----
center () 
{ 
    .output.center "$@"
}

----

==== `command-spacer`

[source,bash]
----
command-spacer () 
{ 
    local color="${txtgrn}"
    [[ ${LibRun__LastExitCode} -ne 0 ]] && color="${txtred}"
    [[ -z ${LibRun__AssignedWidth} || -z ${LibRun__CommandLength} ]] && return
    printf "%s${color}" ""
    local __width=$((LibRun__AssignedWidth - LibRun__CommandLength - 10))
    [[ ${__width} -gt 0 ]] && .output.replicate-to "â–ª" "${__width}"
}

----

==== `cursor.at.x`

[source,bash]
----
cursor.at.x () 
{ 
    .output.cursor-move-to-x "$@"
}

----

==== `cursor.at.y`

[source,bash]
----
cursor.at.y () 
{ 
    .output.cursor-move-to-y "$@"
}

----

==== `cursor.down`

[source,bash]
----
cursor.down () 
{ 
    .output.cursor-down-by "$@"
}

----

==== `cursor.left`

[source,bash]
----
cursor.left () 
{ 
    .output.cursor-left-by "$@"
}

----

==== `cursor.rewind`

[source,bash]
----
cursor.rewind () 
{ 
    local x=${1:-0}
    .output.cursor-move-to-x ${x}
}

----

==== `cursor.right`

[source,bash]
----
cursor.right () 
{ 
    .output.cursor-right-by "$@"
}

----

==== `cursor.shift.x`

[source,bash]
----
cursor.shift.x () 
{ 
    local shift="$1"
    if [[ "${shift:0:1}" == "-" ]]; then
        .output.cursor-left-by "${shift:1}"
    else
        .output.cursor-right-by "${shift}"
    fi
}

----

==== `cursor.up`

[source,bash]
----
cursor.up () 
{ 
    .output.cursor-up-by "$@"
}

----

==== `duration`

[source,bash]
----
duration () 
{ 
    local millis="$1"
    local exit_code="$2"
    [[ -n $(which bc) ]] || return
    if [[ -n ${millis} && ${millis} -ge 0 ]]; then
        local pattern
        pattern=" %6.6s ms "
        pattern="${txtblu}ã€”${pattern}ã€•"
        printf "${txtblu}${pattern}" "${millis}"
    fi
    if [[ -n ${exit_code} ]]; then
        [[ ${exit_code} -eq 0 ]] && printf " ${txtblk}${bakgrn} %3d ${clr}" ${exit_code}
        [[ ${exit_code} -gt 0 ]] && printf " ${bldwht}${bakred} %3d ${clr}" ${exit_code}
    fi
}

----

==== `hr`

[source,bash]
----
hr () 
{ 
    [[ -z "$*" ]] || printf "$*"
    .output.hr
}

----

==== `hr.colored`

[source,bash]
----
hr.colored () 
{ 
    local color="$*"
    [[ -z ${color} ]] && color="${bldred}"
    .output.hr "$(screen-width)" "â€”" "${*}"
}

----

==== `left`

[source,bash]
----
left () 
{ 
    .output.left-justify "$@"
}

----

==== `left-prefix`

[source,bash]
----
left-prefix () 
{ 
    [[ -z ${LibOutput__LeftPrefix} ]] && { 
        export LibOutput__LeftPrefix=$(.output.replicate-to " " "${LibOutput__LeftPrefixLen}")
    }
    printf "${LibOutput__LeftPrefix}"
}

----

==== `not-ok`

[source,bash]
----
not-ok () 
{ 
    ui.closer.not-ok "$@"
}

----

==== `not-ok:`

[source,bash]
----
not-ok: () 
{ 
    ui.closer.not-ok: "$@"
}

----

==== `ok`

[source,bash]
----
ok () 
{ 
    ui.closer.ok "$@"
}

----

==== `ok:`

[source,bash]
----
ok: () 
{ 
    ui.closer.ok: "$@"
}

----

==== `output.color.off`

[source,bash]
----
output.color.off () 
{ 
    reset-color: 1>&2
    reset-color: 1>&1
}

----

==== `output.color.on`

[source,bash]
----
output.color.on () 
{ 
    printf "${bldred}" 1>&2
    printf "${bldblu}" 1>&1
}

----

==== `output.constrain-screen-width`

[source,bash]
----
output.constrain-screen-width () 
{ 
    export LibOutput__WidthDetectionStrategy="constrained"
    [[ $1 -gt 0 ]] && output.set-max-width "$1"
    [[ $2 -gt 0 ]] && output.set-min-width "$2"
}

----

==== `output.has-stdin`

[source,bash]
----
output.has-stdin () 
{ 
    test -s /dev/stdin
}

----

==== `output.is-pipe`

[source,bash]
----
output.is-pipe () 
{ 
    [[ -p /dev/stdout ]]
}

----

==== `output.is-redirect`

[source,bash]
----
output.is-redirect () 
{ 
    [[ ! -t 1 && ! -p /dev/stdout ]]
}

----

==== `output.is-ssh`

[source,bash]
----
output.is-ssh () 
{ 
    [[ -n "${SSH_CLIENT}" || -n "${SSH_CONNECTION}" ]]
}

----

==== `output.is-terminal`

[source,bash]
----
output.is-terminal () 
{ 
    output.is-tty || output.is-redirect || output.is-pipe || output.is-ssh
}

----

==== `output.is-tty`

[source,bash]
----
output.is-tty () 
{ 
    [[ -t 1 ]]
}

----

==== `output.print-at-x-y`

[source,bash]
----
output.print-at-x-y () 
{ 
    local x=$1
    shift
    local y=$1
    shift
    .output.cursor-move-to-x "${x}"
    cursor.up "${y}"
    printf "%s" "$*"
    cursor.down "${y}"
    .output.cursor-move-to-x 0
}

----

==== `output.reset-min-max-width`

[source,bash]
----
output.reset-min-max-width () 
{ 
    export LibOutput__MinWidth=${LibOutput__MinWidth:-${LibOutput__MinWidth__Default}}
    export LibOutput__MaxWidth=${LibOutput__MaxWidth:-${LibOutput__MaxWidth__Default}}
}

----

==== `output.set-max-width`

[source,bash]
----
output.set-max-width () 
{ 
    [[ $1 -gt 0 ]] && export LibOutput__MaxWidth="$1"
}

----

==== `output.set-min-width`

[source,bash]
----
output.set-min-width () 
{ 
    [[ $1 -gt 0 ]] && export LibOutput__MinWidth="$1"
}

----

==== `output.unconstrain-screen-width`

[source,bash]
----
output.unconstrain-screen-width () 
{ 
    export LibOutput__WidthDetectionStrategy="unconstrained"
}

----

==== `screen-height`

[source,bash]
----
screen-height () 
{ 
    .output.screen-height
}

----

==== `screen-width`

[source,bash]
----
screen-width () 
{ 
    .output.screen-width
}

----

==== `screen.height`

[source,bash]
----
screen.height () 
{ 
    .output.screen-height
}

----

==== `screen.width`

[source,bash]
----
screen.width () 
{ 
    .output.screen-width
}

----

==== `section`

[source,bash]
----
section () 
{ 
    .output.left-powerline pur "$@"
}

----

==== `stderr`

[source,bash]
----
stderr () 
{ 
    local file=$1
    hl.subtle STDERR
    printf "${txtred}"
    [[ -s ${file} ]] && cat ${file}
    reset-color
}

----

==== `stdout`

[source,bash]
----
stdout () 
{ 
    local file=$1
    hl.subtle STDOUT
    printf "${clr}"
    [[ -s ${file} ]] && cat ${file}
    reset-color
}

----

==== `ui.closer.kind-of-ok`

[source,bash]
----
ui.closer.kind-of-ok () 
{ 
    .output.cursor-left-by 1000
    printf " ${bakylw}${bldwht} â– ${clr} "
}

----

==== `ui.closer.kind-of-ok:`

[source,bash]
----
ui.closer.kind-of-ok: () 
{ 
    ui.closer.kind-of-ok $@
    echo
}

----

==== `ui.closer.not-ok`

[source,bash]
----
ui.closer.not-ok () 
{ 
    .output.cursor-left-by 1000
    printf " ${bakred}${bldwht} âœ˜ ${clr} "
}

----

==== `ui.closer.not-ok:`

[source,bash]
----
ui.closer.not-ok: () 
{ 
    ui.closer.not-ok $@
    echo
}

----

==== `ui.closer.ok`

[source,bash]
----
ui.closer.ok () 
{ 
    .output.cursor-left-by 1000
    printf " ${txtblk}${bakgrn} âœ”ï¸Ž ${clr} "
}

----

==== `ui.closer.ok:`

[source,bash]
----
ui.closer.ok: () 
{ 
    ui.closer.ok "$@"
    echo
}

----


=== Module `output-boxes`

==== `attention`

[source,bash]
----
attention () 
{ 
    .output.left-powerline blu 65 "${txtwht}${bakblu}$@"
}

----

==== `box.black-on-blue`

[source,bash]
----
box.black-on-blue () 
{ 
    .output.box "${txtblk}${bakblu}" "${bakblu}" "$@"
}

----

==== `box.black-on-green`

[source,bash]
----
box.black-on-green () 
{ 
    .output.box "${txtblk}${bakgrn}" "${bakgrn}" "$@"
}

----

==== `box.black-on-purple`

[source,bash]
----
box.black-on-purple () 
{ 
    .output.box "${txtblk}${bakpur}" "${bakpur}" "$@"
}

----

==== `box.black-on-red`

[source,bash]
----
box.black-on-red () 
{ 
    .output.box "${txtblk}${bakred}" "${bakred}" "$@"
}

----

==== `box.black-on-yellow`

[source,bash]
----
box.black-on-yellow () 
{ 
    .output.box "${txtblk}${bakylw}" "${txtblk}${bakylw}" "$@"
}

----

==== `box.blue-in-green`

[source,bash]
----
box.blue-in-green () 
{ 
    .output.box "${bldblu}" "${bldgrn}" "$@"
}

----

==== `box.blue-in-yellow`

[source,bash]
----
box.blue-in-yellow () 
{ 
    .output.box "${bldylw}" "${bldblu}" "$@"
}

----

==== `box.green-in-cyan`

[source,bash]
----
box.green-in-cyan () 
{ 
    .output.box "${bldgrn}" "${bldcyn}" "$@"
}

----

==== `box.green-in-green`

[source,bash]
----
box.green-in-green () 
{ 
    .output.box "${bldgrn}" "${bldgrn}" "$@"
}

----

==== `box.green-in-magenta`

[source,bash]
----
box.green-in-magenta () 
{ 
    .output.box "${bldgrn}" "${bldpur}" "$@"
}

----

==== `box.green-in-yellow`

[source,bash]
----
box.green-in-yellow () 
{ 
    .output.box "${bldgrn}" "${bldylw}" "$@"
}

----

==== `box.magenta-in-blue`

[source,bash]
----
box.magenta-in-blue () 
{ 
    .output.box "${bldblu}" "${bldpur}" "$@"
}

----

==== `box.magenta-in-green`

[source,bash]
----
box.magenta-in-green () 
{ 
    .output.box "${bldpur}" "${bldgrn}" "$@"
}

----

==== `box.red-in-magenta`

[source,bash]
----
box.red-in-magenta () 
{ 
    .output.box "${bldred}" "${bldpur}" "$@"
}

----

==== `box.red-in-red`

[source,bash]
----
box.red-in-red () 
{ 
    .output.box "${txtred}" "${txtred}" "$@"
}

----

==== `box.red-in-yellow`

[source,bash]
----
box.red-in-yellow () 
{ 
    .output.box "${bldred}" "${bldylw}" "$@"
}

----

==== `box.white-on-blue`

[source,bash]
----
box.white-on-blue () 
{ 
    .output.box "${bakblu}${bldwht}" "${bakblu}${bldwht}" "$@"
}

----

==== `box.white-on-green`

[source,bash]
----
box.white-on-green () 
{ 
    .output.box "${bakgrn}${bldwht}" "${bakgrn}${bldwht}" "$@"
}

----

==== `box.white-on-red`

[source,bash]
----
box.white-on-red () 
{ 
    .output.box "${bakred}${bldwht}" "${bakred}${bldwht}" "$@"
}

----

==== `box.yellow-in-blue`

[source,bash]
----
box.yellow-in-blue () 
{ 
    .output.box "${bldylw}" "${bldblu}" "$@"
}

----

==== `box.yellow-in-red`

[source,bash]
----
box.yellow-in-red () 
{ 
    .output.box "${bldred}" "${bldylw}" "$@"
}

----

==== `box.yellow-in-yellow`

[source,bash]
----
box.yellow-in-yellow () 
{ 
    .output.box "${bldylw}" "${txtylw}" "$@"
}

----

==== `box.yellow-on-green`

[source,bash]
----
box.yellow-on-green () 
{ 
    .output.box "${bakgrn}${bldwht}" "${bakgrn}${bldylw}" "$@"
}

----

==== `box.yellow-on-purple`

[source,bash]
----
box.yellow-on-purple () 
{ 
    .output.box "${bakpur}" "${bldylw}" "$@"
}

----

==== `h.black`

[source,bash]
----
h.black () 
{ 
    center "${bldylw}${bakblk}" "$@"
}

----

==== `h.blue`

[source,bash]
----
h.blue () 
{ 
    center "${txtblk}${bakblu}" "$@"
}

----

==== `h.e`

[source,bash]
----
h.e () 
{ 
    .output.box "${bakred}${txtblk}" "${bakred}" "$@"
}

----

==== `h.green`

[source,bash]
----
h.green () 
{ 
    center "${txtblk}${bakgrn}" "$@"
}

----

==== `h.orange`

[source,bash]
----
h.orange () 
{ 
    left "${white_on_orange}" "$@"
}

----

==== `h.orange-center`

[source,bash]
----
h.orange-center () 
{ 
    center "${white_on_orange}" "$@"
}

----

==== `h.red`

[source,bash]
----
h.red () 
{ 
    center "${txtblk}${bakred}" "$@"
}

----

==== `h.salmon`

[source,bash]
----
h.salmon () 
{ 
    left "${white_on_salmon}" "$@"
}

----

==== `h.salmon-center`

[source,bash]
----
h.salmon-center () 
{ 
    center "${white_on_salmon}" "$@"
}

----

==== `h.yellow`

[source,bash]
----
h.yellow () 
{ 
    center "${txtblk}${bakylw}" "$@"
}

----

==== `h1`

[source,bash]
----
h1 () 
{ 
    box.blue-in-yellow "$@"
}

----

==== `h1.blue`

[source,bash]
----
h1.blue () 
{ 
    box.magenta-in-blue "$@"
}

----

==== `h1.green`

[source,bash]
----
h1.green () 
{ 
    box.green-in-magenta "$@"
}

----

==== `h1.purple`

[source,bash]
----
h1.purple () 
{ 
    box.magenta-in-green "$@"
}

----

==== `h1.red`

[source,bash]
----
h1.red () 
{ 
    box.red-in-red "$@"
}

----

==== `h1.yellow`

[source,bash]
----
h1.yellow () 
{ 
    box.yellow-in-red "$@"
}

----

==== `h1bg`

[source,bash]
----
h1bg () 
{ 
    box.white-on-blue "$@"
}

----

==== `h2`

[source,bash]
----
h2 () 
{ 
    box.blue-in-green "$@"
}

----

==== `h2.green`

[source,bash]
----
h2.green () 
{ 
    box.green-in-cyan "$@"
}

----

==== `h2bg`

[source,bash]
----
h2bg () 
{ 
    box.white-on-green "$@"
}

----

==== `h3`

[source,bash]
----
h3 () 
{ 
    box.magenta-in-green "$@"
}

----

==== `h3bg`

[source,bash]
----
h3bg () 
{ 
    box.yellow-on-purple "$@"
}

----

==== `h4`

[source,bash]
----
h4 () 
{ 
    section.blue "$@"
}

----

==== `h5`

[source,bash]
----
h5 () 
{ 
    section.purple "$@"
}

----

==== `h6`

[source,bash]
----
h6 () 
{ 
    section.yellow "$@"
}

----

==== `h7`

[source,bash]
----
h7 () 
{ 
    section.salmon "$@"
}

----

==== `h8`

[source,bash]
----
h8 () 
{ 
    section.cyan "$@"
}

----

==== `hdr`

[source,bash]
----
hdr () 
{ 
    h1 "$@"
}

----

==== `hl.blue`

[source,bash]
----
hl.blue () 
{ 
    left "${bldwht}${bakpur}" "$@"
}

----

==== `hl.desc`

[source,bash]
----
hl.desc () 
{ 
    left "${bakylw}${txtblk}${bakylw}" "$@"
}

----

==== `hl.green`

[source,bash]
----
hl.green () 
{ 
    left "${txtblk}${bakgrn}" "$@"
}

----

==== `hl.subtle`

[source,bash]
----
hl.subtle () 
{ 
    left "${bldwht}${bakblk}${underlined}" "$@"
}

----

==== `hl.yellow`

[source,bash]
----
hl.yellow () 
{ 
    left "${txtblk}${bakylw}" "$@"
}

----

==== `hl.yellow-on-black`

[source,bash]
----
hl.yellow-on-black () 
{ 
    left "${yellow_on_black}" "$@"
}

----

==== `hl.yellow-on-gray`

[source,bash]
----
hl.yellow-on-gray () 
{ 
    left "${yellow_on_gray}" "$@"
}

----

==== `notice`

[source,bash]
----
notice () 
{ 
    .output.left-powerline ylw 65 "${itablk}${bakylw}$@"
}

----

==== `section.blue`

[source,bash]
----
section.blue () 
{ 
    .output.left-powerline blu "$@"
}

----

==== `section.cyan`

[source,bash]
----
section.cyan () 
{ 
    .output.left-powerline cyn "$@"
}

----

==== `section.gray`

[source,bash]
----
section.gray () 
{ 
    .output.left-powerline blk "$@"
}

----

==== `section.gray-yellow`

[source,bash]
----
section.gray-yellow () 
{ 
    section.gray "${bldylw}${bakblk}$*"
}

----

==== `section.green`

[source,bash]
----
section.green () 
{ 
    .output.left-powerline grn "$@"
}

----

==== `section.purple`

[source,bash]
----
section.purple () 
{ 
    .output.left-powerline pur "$@"
}

----

==== `section.red`

[source,bash]
----
section.red () 
{ 
    .output.left-powerline red "$@"
}

----

==== `section.salmon`

[source,bash]
----
section.salmon () 
{ 
    .output.left-powerline wht 65 "${white_on_salmon}  $@  "
}

----

==== `section.white`

[source,bash]
----
section.white () 
{ 
    .output.left-powerline wht "$@"
}

----

==== `section.yellow`

[source,bash]
----
section.yellow () 
{ 
    .output.left-powerline ylw "$@"
}

----


=== Module `output-repeat-char`


=== Module `output-utils`

==== `abort`

[source,bash]
----
abort () 
{ 
    printf -- "${LibOutput__LeftPrefix}${txtblk}${bakred}  Â« ABORT Â»  ${clr} ${bldwht} âœ”  ${bldgrn}$*${clr}" 1>&2
    echo
}

----

==== `ask`

[source,bash]
----
ask () 
{ 
    printf -- "%s${txtylw}$*${clr}\n" "${LibOutput__LeftPrefix}"
    printf -- "%s${txtylw}â¯ ${bldwht}" "${LibOutput__LeftPrefix}"
}

----

==== `br`

[source,bash]
----
br () 
{ 
    echo
}

----

==== `columnize`

[source,bash]
----
columnize () 
{ 
    local columns="${1:-2}"
    local sw=${SCREEN_WIDTH:-120}
    [[ -z ${sw} ]] && sw=$(screen-width)
    pr -l 10000 -${columns} -e4 -w ${sw} | expand -8 | sed -E '/^ *$/d' | grep -v 'Page '
}

----

==== `dbg`

[source,bash]
----
dbg () 
{ 
    is-dbg && printf "     ${txtgrn}[DEBUG | ${txtylw}$(time.now.with-ms)${txtgrn}]  ${txtblu}$(txt-info)$*\n" 1>&2
    return 0
}

----

==== `dbg-off`

[source,bash]
----
dbg-off () 
{ 
    unset DEBUG
}

----

==== `dbg-on`

[source,bash]
----
dbg-on () 
{ 
    export DEBUG=$(time.now.db)
}

----

==== `dbgf`

[source,bash]
----
dbgf () 
{ 
    local func="$1"
    shift
    is.a-function "${func}" || { 
        error "${func} is not a function"
        return 1
    }
    dbg "${func}(" "$@" ")"
    ${func} "$@"
    local code=$?
    is-dbg || return "${code}"
    cursor.up 1
    cursor.at.x 0
    if [[ ${code} -eq 0 ]]; then
        ok:
    else
        not-ok:
    fi
    return ${code}
}

----

==== `err`

[source,bash]
----
err () 
{ 
    printf -- "${LibOutput__LeftPrefix}${bldylw}${bakred}  Â« ERROR! Â»  ${clr} ${bldred}$*${clr}" 1>&2
}

----

==== `error`

[source,bash]
----
error () 
{ 
    header=$(printf -- "${clr}${txtred}  Â« ERROR Â» ")
    box.white-on-red "${header} ${clr}${txtblk}${bakred} â€” $1" "${@:2}" 1>&2
}

----

==== `error:`

[source,bash]
----
error: () 
{ 
    err "$*"
    ui.closer.not-ok:
}

----

==== `fatal`

[source,bash]
----
fatal () 
{ 
    header=$(printf -- "${clr}${bldwht}  Â« ABORT Â» ")
    box.black-on-red "${header} ${clr}${txtblk}${bakred} â€” $1" "${@:2}" 1>&2
    exit 1
}

----

==== `inf`

[source,bash]
----
inf () 
{ 
    printf -- "${LibOutput__LeftPrefix}${clr}${txtcyn}$*${clr}"
}

----

==== `info`

[source,bash]
----
info () 
{ 
    inf $@
    echo
}

----

==== `info-debug`

[source,bash]
----
info-debug () 
{ 
    [[ -z ${DEBUG} ]] && return
    printf -- "${LibOutput__LeftPrefix}${bakpur}[ debug ] $*  ${clr}\n"
}

----

==== `info:`

[source,bash]
----
info: () 
{ 
    inf "$*"
    ui.closer.ok:
}

----

==== `is-dbg`

[source,bash]
----
is-dbg () 
{ 
    [[ -n $DEBUG ]]
}

----

==== `okay`

[source,bash]
----
okay () 
{ 
    printf -- " ${bldgrn} âœ“ ALL OK ðŸ‘  $*${clr}" 1>&2
    echo
}

----

==== `puts`

[source,bash]
----
puts () 
{ 
    printf "  â‡¨ ${txtwht}$*${clr}"
}

----

==== `reset-color`

[source,bash]
----
reset-color () 
{ 
    echo -en "${clr}"
}

----

==== `reset-color:`

[source,bash]
----
reset-color: () 
{ 
    printf "${clr}"
}

----

==== `shutdown`

[source,bash]
----
shutdown () 
{ 
    local message=${1:-"Shutting down..."}
    echo
    box.red-in-red "${message}"
    echo
    exit 1
}

----

==== `success`

[source,bash]
----
success () 
{ 
    printf -- "\n${LibOutput__LeftPrefix}${txtblk}${bakgrn}  Â« SUCCESS Â»  ${clr} ${bldwht} âœ”  ${bldgrn}$*${clr}" 1>&2
    printf -- "\n\n" 1>&2
}

----

==== `warn`

[source,bash]
----
warn () 
{ 
    printf -- "${LibOutput__LeftPrefix}${bldwht}${bakylw} Â« WARNING! Â» ${clr} ${bldylw}$*${clr}" 1>&2
}

----

==== `warning`

[source,bash]
----
warning () 
{ 
    header=$(printf -- "${clr}${txtylw}  Â« WARNING Â» ")
    local first="$1"
    shift
    box.black-on-yellow "${header} ${clr}${txtblk}${bakylw} â€” $first" "$@" 1>&2
}

----

==== `warning:`

[source,bash]
----
warning: () 
{ 
    warn "$*"
    ui.closer.kind-of-ok:
}

----


=== Module `path`

==== `PATH_add`

[source,bash]
----
PATH_add () 
{ 
    path.add "$@"
}

----

==== `path.add`

[source,bash]
----
path.add () 
{ 
    local new_path="${PATH}"
    for path in "$@"
    do
        is.a-directory "${path}" || { 
            error "Argument ${path} is not a valid directory, abort."
            return 1
        }
        [[ ":${PATH}:" =~ :${path}: ]] && continue
        export new_path="${new_path}:${path}"
        export new_path="${new_path/::/:}"
    done
    echo "${new_path}"
}

----

==== `path.append`

[source,bash]
----
path.append () 
{ 
    export PATH="$(path.add "$@")"
}

----

==== `path.dirs`

[source,bash]
----
path.dirs () 
{ 
    local path="${1:-${PATH}}"
    echo "${path//:/'
'}" | /usr/bin/tr -d "'" | sedx '/^$/d'
}

----

==== `path.size`

[source,bash]
----
path.size () 
{ 
    path.dirs "$@" | /usr/bin/wc -l | /usr/bin/tr -d ' '
}

----

==== `path.uniq`

[source,bash]
----
path.uniq () 
{ 
    local -a paths
    for dir in $(path.dirs "$@")
    do
        array.includes "${dir}" "${paths[@]}" || paths+=("${dir}")
    done
    echo "${paths[@]}" | /usr/bin/tr ' ' '\n'
}

----

==== `path.uniqify`

[source,bash]
----
path.uniqify () 
{ 
    path.uniq "$@" | /usr/bin/tr '\n' ':' | sedx 's/[$%]//g'
}

----

==== `path.uniqify-and-export`

[source,bash]
----
path.uniqify-and-export () 
{ 
    export PATH=$(path.uniqify "$@")
}

----


=== Module `pdf`

==== `pdf.combine`

[source,bash]
----
pdf.combine () 
{ 
    local merged="${1}"
    shift
    local files=""
    for f in "$@"
    do
        [[ -f "${f}" ]] && { 
            info "Appending file ${bldylw}${f}"
            files="${files} '${f}'"
        }
    done
    [[ -s "${merged}" ]] && { 
        warning "Merged file ${merged} already exists, removing..."
        run "rm -f \"${merged}\""
    }
    unalias gs 2> /dev/null
    [[ -n $(command -V gs) ]] || brew.install.package gs
    run "mkdir -p $(dirname "${merged}")"
    info "Please wait while GhostScript combines your PDFs into"
    info "destination file: ${bldylw}${merged}"
    run "gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=${merged} ${files}"
    return ${LibRun__LastExitCode}
}

----


=== Module `pg`

==== `pg.is-running`

[source,bash]
----
pg.is-running () 
{ 
    [[ $(/bin/ps -ef | grep -c '[p]ostgres:') -gt 4 ]]
}

----

==== `pg.running.data-dirs`

[source,bash]
----
pg.running.data-dirs () 
{ 
    ps -eo 'args' | $(which grep) '[p]ostgres.*-D' | awk 'BEGIN{FS="-D"}{print $2}' | awk '{print $1}' | sort
}

----

==== `pg.running.server-binaries`

[source,bash]
----
pg.running.server-binaries () 
{ 
    ps -eo 'args' | $(which grep) '[p]ostgres.*-D' | awk '{print $1}' | sort
}

----

==== `pg.server-in-path.version`

[source,bash]
----
pg.server-in-path.version () 
{ 
    is.command postgres || return 1
    $(which postgres) -V | sed -E 's/[^0-9.]//g;s/\..*$//g'
}

----


=== Module `pids`

==== `pall`

[source,bash]
----
pall () 
{ 
    pids.all "$@"
}

----

==== `pid.alive`

[source,bash]
----
pid.alive () 
{ 
    local pid="$1"
    util.is-numeric || { 
        error "First argument to pid.alive must be numeric."
        return 1
    }
    [[ -n "${pid}" && -n $(ps -p "${pid}" | grep -v TTY) ]]
}

----

==== `pid.sig`

[source,bash]
----
pid.sig () 
{ 
    local pid="${1}"
    shift
    local signal="${1}"
    shift
    [[ -z "${pid}" || -z "${signal}" ]] && { 
        printf "
USAGE:
  pid.sig pid signal
"
        return 1
    }
    util.is-numeric ${pid} || { 
        error "First argument to pid.sig must be numeric."
        return 1
    }
    util.is-numeric ${signal} || sig.is-valid ${signal} || { 
        error "First argument to pid.sig must be numeric."
        return 1
    }
    if pid.alive ${pid}; then
        info "sending ${bldred}${signal}$(txt-info) to ${bldylw}${pid}..."
        /bin/kill -s ${signal} ${pid} 2>&1 | cat > /dev/null
    else
        warning "pid ${pid} was dead by the time we tried sending ${sig} to it."
        return 1
    fi
}

----

==== `pid.stop`

[source,bash]
----
pid.stop () 
{ 
    local pid=${1}
    shift
    local delay=${1:-"0.3"}
    shift
    if [[ -z ${pid} ]]; then
        printf "
DESCRIPTION:
  If the given PID is active, first sends kill -TERM, waits a bit,
  then sends kill -9.

USAGE:
  ${bldgrn}pid.stop pid${clr}

EXAMPLES:
  # stop all sidekiqs, waiting half a sec in between
  ${bldgrn}pid.stop sidekiq 0.5${clr}
"
        return 1
    fi
    pid.alive "${pid}" && ( pid.sig "${pid}" "TERM" || true ) && sleep ${delay}
    pid.alive "${pid}" && pid.sig "${pid}" "KILL"
}

----

==== `pid.stop-and-kill`

[source,bash]
----
pid.stop-and-kill () 
{ 
    local pid="$1"
    delta=1
    sig=STOP
    while true; do
        pid.alive $pid || return 0
        kill -${sig} ${pid} 2>&1 > /dev/null
        delta=$((delta * 2))
        [[ ${delta} -gt 16 ]] && sig="KILL"
        sleep "0.${delta}"
    done
    pid.alive $pid && { 
        error "PID ${pid} is miraculously still alive..." 1>&2
        return 1
    }
}

----

==== `pids-with-args`

[source,bash]
----
pids-with-args () 
{ 
    local -a permitted=("%cpu" "%mem" acflag acflg args blocked caught comm command cpu cputime etime f flags gid group ignored inblk inblock jobc ktrace ktracep lim login logname lstart majflt minflt msgrcv msgsnd ni nice nivcsw nsignals nsigs nswap nvcsw nwchan oublk oublock p_ru paddr pagein pcpu pending pgid pid pmem ppid pri pstime putime re rgid rgroup rss ruid ruser sess sig sigmask sl start stat state stime svgid svuid tdev time tpgid tsess tsiz tt tty ucomm uid upr user usrpri utime vsize vsz wchan wq wqb wql wqr xstat)
    local -a additional=()
    local -a matching=()
    for arg in $@
    do
        array.includes "${arg}" "${permitted[@]}" && additional=(${additional[@]} $arg) && continue
        matching=("${matching[@]}" "${arg}")
    done
    local columns="pid,ppid,user,%cpu,%mem,command"
    if [[ ${#additional[@]} -gt 0 ]]; then
        columns="${columns},$(array.join ',' "${additional[@]}")"
    fi
    pids.matching.regexp "${matching[*]}" | xargs /bin/ps -www -o"${columns}" -p
}

----

==== `pids.all`

[source,bash]
----
pids.all () 
{ 
    if [[ -z "${1}" ]]; then
        printf "
DESCRIPTION:
  prints processes matching a given pattern

USAGE:
  ${bldgrn}pids.all pattern${clr}

EXAMPLES:
  ${bldgrn}pids.all puma${clr}
"
        return 0
    fi
    local pattern="$(pids.normalize.search-string "$1")"
    shift
    ps -ef | ${GrepCommand} "${pattern}" | ${GrepCommand} -v grep
}

----

==== `pids.for-each`

[source,bash]
----
pids.for-each () 
{ 
    if [[ -z "${1}" || -z "${2}" ]]; then
        printf "
DESCRIPTION:
  loops over matching PIDs and calls a named BASH function

USAGE:
  ${bldgrn}pids.for-each pattern function${clr}

EXAMPLES:
  ${bldgrn}pids.for-each puma echo
  function hup() { kill -HUP \$1; }; pids.for-each sidekiq hup${clr}
"
        return 0
    fi
    local pattern="$(pids.normalize.search-string "$1")"
    shift
    local func=${1:-"echo"}
    if [[ -z $(which ${func}) && -z $(type ${func} 2>/dev/null) ]]; then
        errror "Function ${func} does not exist."
        return 1
    fi
    while true; do
        local -a pids=($(pids.matching "${pattern}"))
        [[ ${#pids[@]} == 0 ]] && break
        eval "${func} ${pids[0]}"
        sleep 0.1
    done
}

----

==== `pids.matching`

[source,bash]
----
pids.matching () 
{ 
    local pattern="${1}"
    if [[ -z "${pattern}" ]]; then
        printf "
DESCRIPTION:
  Finds process IDs matching a given string.

USAGE:
  ${bldgrn}pids.matching string${clr}

EXAMPLES:
  ${bldgrn}pids.matching sidekiq${clr}
"
        return 0
    fi
    pattern="$(pids.normalize.search-string ${pattern})"
    pids.matching.regexp "${pattern}"
}

----

==== `pids.matching.regexp`

[source,bash]
----
pids.matching.regexp () 
{ 
    local pattern="${1}"
    if [[ -z "${pattern}" ]]; then
        printf "
DESCRIPTION:
  Finds process IDs matching a given regexp.

USAGE:
  ${bldgrn}pids.matching regular-expression${clr}

EXAMPLES:
  ${bldgrn}pids.matching '[s]idekiq\s+' ${clr}
"
        return 0
    fi
    ps -ef | ${GrepCommand} "${pattern}" | ${GrepCommand} -v grep | awk '{print $2}' | sort -n
}

----

==== `pids.normalize.search-string`

[source,bash]
----
pids.normalize.search-string () 
{ 
    local pattern="$*"
    [[ "${pattern:0:1}" == '[' ]] || pattern="[${pattern:0:1}]${pattern:1}"
    printf "${pattern}"
}

----

==== `pids.stop`

[source,bash]
----
pids.stop () 
{ 
    if [[ -z "${1}" ]]; then
        printf "
DESCRIPTION:
  finds and stops IDs matching a given pattern

USAGE:
  ${bldgrn}pids.stop <pattern>${clr}

EXAMPLES:
  ${bldgrn}pids.stop puma${clr}
"
        return 0
    fi
    pids.for-each "${1}" "pid.stop"
}

----

==== `pstop`

[source,bash]
----
pstop () 
{ 
    pids.stop "$@"
}

----

==== `sig.is-valid`

[source,bash]
----
sig.is-valid () 
{ 
    [[ -n $(kill -l ${1} 2>/dev/null) ]]
}

----

==== `sig.list`

[source,bash]
----
sig.list () 
{ 
    /bin/kill -l | sed -E 's/([ 0-9][0-9]\) SIG)//g; s/\s+/\n/g' | tr 'a-z' 'A-Z' | sort
}

----


=== Module `pipe`

==== `pipe.extract-variables`

[source,bash]
----
pipe.extract-variables () 
{ 
    sedx '/^\(\s*\)#.*$/D; /^\s*$/D; /^[^A-Z].*$/D' | sedx 's/export //ig' | cut -d '=' -f 1
}

----

==== `pipe.remove-blank-lines`

[source,bash]
----
pipe.remove-blank-lines () 
{ 
    sedx '/^$/D'
}

----

==== `pipe.remove-hash-comments`

[source,bash]
----
pipe.remove-hash-comments () 
{ 
    sedx '/^\(\s*\)?#.*$/D; s/#.*$//g;'
}

----


=== Module `progress-bar`

==== `progress.bar.auto-run`

[source,bash]
----
progress.bar.auto-run () 
{ 
    .progress.reset
    .progress.bar "$@"
    code=$?
    if [[ ${code} -ne 0 ]]; then
        .progress.reset
        return 1
    fi
    return 0
}

----

==== `progress.bar.config`

[source,bash]
----
progress.bar.config () 
{ 
    while true; do
        local setting="$1"
        shift
        [[ -z ${setting} ]] && break
        local key=${setting/=*/}
        local value=${setting/*=/}
        eval "export LibProgress__${key}=\"${value}\""
    done
}

----

==== `progress.bar.configure.color-green`

[source,bash]
----
progress.bar.configure.color-green () 
{ 
    progress.bar.config BarColor=${bldgrn}
}

----

==== `progress.bar.configure.color-red`

[source,bash]
----
progress.bar.configure.color-red () 
{ 
    progress.bar.config BarColor=${bldred}
}

----

==== `progress.bar.configure.color-yellow`

[source,bash]
----
progress.bar.configure.color-yellow () 
{ 
    progress.bar.config BarColor=${bldylw}
}

----

==== `progress.bar.configure.symbol-arrow`

[source,bash]
----
progress.bar.configure.symbol-arrow () 
{ 
    progress.bar.config BarChar="â¯"
}

----

==== `progress.bar.configure.symbol-bar`

[source,bash]
----
progress.bar.configure.symbol-bar () 
{ 
    progress.bar.config BarChar="â–ˆ"
}

----

==== `progress.bar.configure.symbol-block`

[source,bash]
----
progress.bar.configure.symbol-block () 
{ 
    progress.bar.config BarChar="${LibProgress__BarChar__Default}"
}

----

==== `progress.bar.configure.symbol-square`

[source,bash]
----
progress.bar.configure.symbol-square () 
{ 
    progress.bar.config BarChar="â—¼ï¸Ž"
}

----

==== `progress.bar.launch-and-wait`

[source,bash]
----
progress.bar.launch-and-wait () 
{ 
    local command="$*"
    run.print-command "${command}\n"
    ${command} > /dev/null 2>&1 & local pid=$!
    info "Waiting for background process to finish; PID=${bldylw}${pid}"
    set -e
    while .progress.bar.check-pid-alive $pid; do
        progress.bar.auto-run 0.5 10
    done
    set +e
    return 0
}

----


=== Module `repositories`

==== `repo.rebase`

[source,bash]
----
repo.rebase () 
{ 
    run "git pull origin master --rebase"
}

----

==== `repo.stash-and-rebase`

[source,bash]
----
repo.stash-and-rebase () 
{ 
    run "git stash >/dev/null"
    run "git reset --hard"
    repo.rebase
}

----

==== `repo.update`

[source,bash]
----
repo.update () 
{ 
    local folder="$1"
    h2 "Entering repo â–º ${bldgren}${folder}"
    [[ -d "${folder}" ]] || return 1
    [[ -d "${folder}/.git" ]] || return 1
    [[ "$(pwd)" != "${folder}" ]] && { 
        cd "${folder}" || return 2
    }
    if [[ -z "$(git status -s)" ]]; then
        repo.rebase
    else
        repo.stash-and-rebase
    fi
}

----

==== `repos.catch-interrupt`

[source,bash]
----
repos.catch-interrupt () 
{ 
    export LibRepo__Interrupted=true
}

----

==== `repos.init-interrupt`

[source,bash]
----
repos.init-interrupt () 
{ 
    export LibRepo__Interrupted=false
    trap 'repos.catch-interrupt' SIGINT
}

----

==== `repos.recursive-update`

[source,bash]
----
repos.recursive-update () 
{ 
    local repo="${1}"
    run.set-all show-output-off
    if [[ ${LibRepo__Interrupted} == true ]]; then
        warn "Detected SINGINT, exiting..."
        return 2
    fi
    if [[ -n "$repo" ]]; then
        repo.update "$repo"
    else
        for dir in $(find . -type d -name '.git')
        do
            local subdir=$(dirname "$dir")
            [[ -n "${DEBUG}" ]] && info "checking out sub-folder ${bldcyn}${subdir}..."
            repos.recursive-update "${subdir}"
            if [[ $? -eq 2 ]]; then
                error "folder ${bldylw}${subdir}${bldred} return error!"
                return 2
            fi
        done
    fi
    if [[ -n ${repo} ]]; then
        info "returning to the root dir ${bldylw}${root_folder}..."
        cd "${root_folder}" > /dev/null || return 2
    fi
}

----

==== `repos.update`

[source,bash]
----
repos.update () 
{ 
    export root_folder="$(pwd)"
    bash -c "
    [[ -d ${BASHMATIC_HOME} ]] || {
      echo 'Can not find bashmatic installation sorry'
      return
    }
    source ${BASHMATIC_HOME}/init.sh
    repos.init-interrupt
    repos.recursive-update '$*'
  "
}

----

==== `repos.was-interrupted`

[source,bash]
----
repos.was-interrupted () 
{ 
    [[ ${LibRepo__Interrupted} == true ]]
}

----


=== Module `ruby`

==== `bundle.gems-with-c-extensions`

[source,bash]
----
bundle.gems-with-c-extensions () 
{ 
    run.set-next show-output-on
    run "bundle show --paths | ruby -e \"STDIN.each_line {|dep| puts dep.split('/').last if File.directory?(File.join(dep.chomp, 'ext')) }\""
}

----

==== `interrupted`

[source,bash]
----
interrupted () 
{ 
    export BashMatic__Interrupted=true
}

----

==== `ruby.bundle-install`

[source,bash]
----
ruby.bundle-install () 
{ 
    if [[ -f Gemfile.lock ]]; then
        run "bundle install"
    fi
}

----

==== `ruby.bundler-version`

[source,bash]
----
ruby.bundler-version () 
{ 
    if [[ ! -f Gemfile.lock ]]; then
        error "Can not find Gemfile.lock"
        return 1
    fi
    tail -1 Gemfile.lock | sedx 's/ //g'
}

----

==== `ruby.compiled-with`

[source,bash]
----
ruby.compiled-with () 
{ 
    if [[ -z "$*" ]]; then
        error "usage: ruby.compiled-with <library>"
        return 1
    fi
    ruby -r rbconfig -e "puts RbConfig.CONFIG['LIBS']" | grep -q "$*"
}

----

==== `ruby.default-gems`

[source,bash]
----
ruby.default-gems () 
{ 
    declare -a DEFAULT_RUBY_GEMS=(bundler rubocop relaxed-rubocop rubocop-performance warp-dir colored2 sym pry pry-doc pry-byebug rspec rspec-its awesome_print activesupport pivotal_git_scripts git-smart travis awscli irbtools kramdown-asciidoc asciidoctor kramdown gemsmith rspec rspec-its)
    export DEFAULT_RUBY_GEMS
    printf "${DEFAULT_RUBY_GEMS[*]}"
}

----

==== `ruby.ensure-rbenv`

[source,bash]
----
ruby.ensure-rbenv () 
{ 
    [[ -n $(command -v rbenv) ]] && return 0
    brew.install
    brew.install.package rbenv ruby-build
    grep -q "rbenv init" ~/.bash_profile && echo 'eval "$(rbenv init -)"' >> ~/.bash_profile
    [[ -n $(command -V rbenv) ]] && return 0
    return 1
}

----

==== `ruby.ensure-rbenv-or-complain`

[source,bash]
----
ruby.ensure-rbenv-or-complain () 
{ 
    ruby.ensure-rbenv || { 
        error "Can't install rbenv via HomeBrew, please try manually."
        return 1
    }
    return 0
}

----

==== `ruby.full-version`

[source,bash]
----
ruby.full-version () 
{ 
    /usr/bin/env ruby --version
}

----

==== `ruby.gemfile-lock-version`

[source,bash]
----
ruby.gemfile-lock-version () 
{ 
    local gem=${1}
    if [[ ! -f Gemfile.lock ]]; then
        error "Can not find Gemfile.lock"
        return 1
    fi
    ${GrepCommand} " ${gem} \([0-9]" Gemfile.lock | sed -e 's/[\(\)]//g' | awk '{print $2}'
}

----

==== `ruby.gems`

[source,bash]
----
ruby.gems () 
{ 
    ruby.gems.install "$@"
}

----

==== `ruby.gems.install`

[source,bash]
----
ruby.gems.install () 
{ 
    local -a gems=($@)
    gem.clear-cache
    [[ ${#gems[@]} -eq 0 ]] && gems=($(ruby.default-gems))
    local -a existing=($(ruby.installed-gems))
    [[ ${#gems[@]} -eq 0 ]] && { 
        error 'Unable to determine what gems to install. ' "Argument is empty, so is ${DEFAULT_RUBY_GEMS[@]}" "USAGE: ${bldgrn}ruby.gems ${bldred} rails rubocop puma pry"
        return 1
    }
    h2 "There are a total of ${#existing[@]} of globally installed Gems." "Total of ${#gems[@]} need to be installed unless they already exist. " "${bldylw}Checking for gems that still missing..."
    local -a gems_to_be_installed=()
    for gem in "${gems[@]}"
    do
        local gem_info=
        if [[ $(array.has-element "${gem}" "${existing[@]}") == "true" ]]; then
            gem_info="${bldgrn} âœ”  ${gem}${clr}\n"
        else
            gem_info="${bldred} x  ${gem}${clr}\n"
            gems_to_be_installed+=("${gem}")
        fi
        printf "   ${gem_info}"
    done
    if [[ ${#gems_to_be_installed[@]} -eq 0 ]]; then
        info "All gems are already installed. ðŸ‘ðŸ¼"
        return 0
    fi
    info "Looks like ${#gems_to_be_installed[@]} gems are left to install..."
    local -a gem_installed
    for gem in "${gems_to_be_installed[@]}"
    do
        run "gem install -q --force --no-document $gem"
        if [[ ${LibRun__LastExitCode} -ne 0 ]]; then
            error "Gem ${gem} refuses to install." "Perhaps try installing it manually?" "${bldgrn}Action: Skip and Continuing..."
            break
        else
            gem_installed+=("${gem}")
            continue
        fi
    done
    gem.clear-cache
    info "Total of ${#gem_installed[@]} gems were installed."
    echo
}

----

==== `ruby.gems.uninstall`

[source,bash]
----
ruby.gems.uninstall () 
{ 
    local -a gems
    gems=("$@")
    gem.clear-cache
    [[ ${#gems[@]} -eq 0 ]] && declare -a gems=($(ruby.default-gems))
    local -a existing=($(ruby.installed-gems))
    [[ ${#gems[@]} -eq 0 ]] && { 
        error "Unable to determine what gems to remove. Argument is empty, so is ${DEFAULT_RUBY_GEMS[@]}" "USAGE: ${bldgrn}ruby.gems.uninstall ${bldred} rails rubocop puma pry"
        return 1
    }
    h1.blue "There are a total of ${#existing[@]} of gems installed in a global namespace." "Total of ${#gems[@]} need to be removed."
    local deleted=0
    for gem in "${gems[@]}"
    do
        local gem_info=
        if [[ $(array.has-element "${gem}" "${existing[@]}") == "true" ]]; then
            run "gem uninstall -a -x -I -D --force ${gem}"
            deleted=$((deleted + 1))
        else
            gem_info="${bldred} x [not found] ${bldylw}${gem}${clr}\n"
        fi
        printf "   ${gem_info}"
    done
    gem.clear-cache
    echo
    success "Total of ${deleted} gems were successfully obliterated."
    echo
}

----

==== `ruby.handle-missing`

[source,bash]
----
ruby.handle-missing () 
{ 
    command -v ruby > /dev/null || { 
        info "Couldn't find Ruby, installing it..." 1>&2
        ruby.install-ruby "$(ruby.numeric-version)"
    }
    command -v ruby > /dev/null
}

----

==== `ruby.init`

[source,bash]
----
ruby.init () 
{ 
    h1 "Installing Critical Gems for Your Glove, Thanos..."
    ruby.rubygems-update
    ruby.install-upgrade-bundler
    ruby.gems.install
    ruby.kigs-gems
}

----

==== `ruby.install`

[source,bash]
----
ruby.install () 
{ 
    ruby.install-ruby "$@"
}

----

==== `ruby.install-ruby`

[source,bash]
----
ruby.install-ruby () 
{ 
    local version="$1"
    shift
    local version_source="provided as an argument"
    if [[ -z ${version} && -f .ruby-version ]]; then
        version="$(cat .ruby-version | tr -d '\n')"
        version_source="auto-detected from .ruby-version file"
    fi
    [[ -z ${version} ]] && { 
        error "USAGE: ruby.install-ruby VERSION" "Or, you can create a local .ruby-version file"
        return 1
    }
    local -a required_packages
    required_packages=(rbenv ruby-build)
    h3 "Installing Ruby Version ${bldpur}${version} ${bldblu}${version_source}."
    ruby.validate-version "${version}" || return 1
    brew.install.packages "${required_packages[@]}"
    brew.upgrade.packages "${required_packages[@]}"
    if [[ -n "$*" ]]; then
        info "Attemping to install additional packages via Brew:"
        for package in "$@"
        do
            run.set-next abort-on-error
            brew.install.package "${package}"
            local func=".ruby.configure-with.${package}"
            util.is-a-function "${func}" && ${func}
        done
    fi
    eval "$(rbenv init -)"
    h2 "RUBY_CONFIGURE_OPTS: ${bldgrn}${RUBY_CONFIGURE_OPTS}"
    run "RUBY_CONFIGURE_OPTS=\"${RUBY_CONFIGURE_OPTS}\" rbenv install -s ${version}"
    return "${LibRun__LastExitCode:-"0"}"
}

----

==== `ruby.install-ruby-with-deps`

[source,bash]
----
ruby.install-ruby-with-deps () 
{ 
    local version="$1"
    declare -a packages=(cask bash bash-completion git go haproxy htop jemalloc libxslt jq libiconv libzip netcat nginx openssl pcre pstree p7zip rbenv redis ruby_build readline tree vim watch wget zlib)
    run.set-next show-output-on
    run "brew install --display-times ${packages[*]}"
}

----

==== `ruby.install-ruby-with-readline-and-openssl`

[source,bash]
----
ruby.install-ruby-with-readline-and-openssl () 
{ 
    local version="$1"
    [[ -z ${version} ]] && { 
        error "usage: ruby.install-ruby-with-readline-and-openssl ruby-version"
        return 1
    }
    shift
    ruby.install-ruby ${version} openssl readline "$@"
}

----

==== `ruby.install-upgrade-bundler`

[source,bash]
----
ruby.install-upgrade-bundler () 
{ 
    gem.install bundler
    run "bundle --update bundler || true"
}

----

==== `ruby.installed-gems`

[source,bash]
----
ruby.installed-gems () 
{ 
    gem list | cut -d ' ' -f 1 | uniq
}

----

==== `ruby.kigs-gems`

[source,bash]
----
ruby.kigs-gems () 
{ 
    if [[ -z $(type wd 2>/dev/null) && -n $(command -v warp-dir) ]]; then
        [[ -f ~/.bash_wd ]] || { 
            warp-dir install --dotfile ~/.bashrc > /dev/null
            source ~/.bash_wd
        }
    fi
    [[ -n $(command -v sym) ]] && { 
        [[ -f ~/.sym.completion.bash ]] || { 
            sym -B ~/.bashrc
        }
    }
}

----

==== `ruby.linked-libs`

[source,bash]
----
ruby.linked-libs () 
{ 
    ruby -r rbconfig -e "puts RbConfig.CONFIG['LIBS']"
}

----

==== `ruby.numeric-version`

[source,bash]
----
ruby.numeric-version () 
{ 
    /usr/bin/env ruby --version | sed 's/^ruby //g; s/ (.*//g'
}

----

==== `ruby.rbenv`

[source,bash]
----
ruby.rbenv () 
{ 
    ruby.ensure-rbenv-or-complain || return 1
    if [[ -n "$*" ]]; then
        rbenv $*
    else
        eval "$(rbenv init -)"
    fi
    run "rbenv rehash"
}

----

==== `ruby.rubygems-update`

[source,bash]
----
ruby.rubygems-update () 
{ 
    info "Updating RubyGems..."
    run.set-next show-output-on
    run "gem update --system"
    gem.clear-cache
}

----

==== `ruby.stop`

[source,bash]
----
ruby.stop () 
{ 
    local regex='/[r]uby| [p]uma| [i]rb| [r]ails | [b]undle| [u]nicorn| [r]ake'
    local procs=$(ps -ef | ${GrepCommand} "${regex}" | ${GrepCommand} -v grep | awk '{print $2}' | sort | uniq | wc -l)
    [[ ${procs} -eq 0 ]] && { 
        info: "No ruby processes were found."
        return 0
    }
    local -a pids=$(ps -ef | ${GrepCommand} "${regex}" | ${GrepCommand} -v grep | awk '{print $2}' | sort | uniq | tr '\n' ' -p ')
    h2 "Detected ${#pids[@]} Ruby Processes..., here is the tree:"
    printf "${txtcyn}"
    pstree ${pids[*]}
    printf "${clr}"
    hr
    printf "To abort, press Ctrl-C. To kill them all press any key.."
    run.ui.press-any-key
    ps -ef | ${GrepCommand} "${regex}" | ${GrepCommand} -v grep | awk '{print $2}' | sort | uniq | xargs kill -9
}

----

==== `ruby.top-versions`

[source,bash]
----
ruby.top-versions () 
{ 
    local platform="${1:-"2\."}"
    local arg="$(.ruby.ruby-build.list-argument)"
    rbenv install ${arg} | ${GrepCommand} "^${platform}" | ruby -e '
      last_v = nil
      last_m = nil
      ARGF.each do |line|
        v = line.split(".")[0..1].join(".")
        if last_v != v
          puts last_m if last_m
          last_v = v
        end
        last_m = line
      end
      puts last_m if last_m'
}

----

==== `ruby.top-versions-as-yaml`

[source,bash]
----
ruby.top-versions-as-yaml () 
{ 
    ruby.top-versions | sed 's/^/ - /g'
}

----

==== `ruby.validate-version`

[source,bash]
----
ruby.validate-version () 
{ 
    local version="$1"
    local -a ruby_versions=()
    run "brew upgrade ruby-build || true"
    [[ -d ~/.rbenv/plugins/ruby-build ]] && { 
        run "cd ~/.rbenv/plugins/ruby-build && git reset --hard && git pull --rebase"
    }
    local arg="$(.ruby.ruby-build.list-argument)"
    array.from.stdin ruby_versions "rbenv install ${arg} | sed -E \"s/\s+//g\""
    inf "Validating ruby version: ${version}"
    array.includes "${version}" "${ruby_versions[@]}" || { 
        not-ok:
        error "Ruby Version provided was NOT found by rbenv: ${bldylw}${version}" "Found a total of ${bldgrn}${#ruby_versions[*]} ruby versions."
        return 1
    }
    ok:
    return 0
}

----


=== Module `run`

==== `run`

[source,bash]
----
run () 
{ 
    .run "$@"
    return ${LibRun__LastExitCode}
}

----

==== `run.ui.ask`

[source,bash]
----
run.ui.ask () 
{ 
    local question=$*
    local func="${LibRun__AskDeclineFunction}"
    export LibRun__AskDeclineFunction="${LibRun__AskDeclineFunction__Default}"
    echo
    inf "${bldcyn}${question}${clr} [Y/n] ${bldylw}"
    read a 2> /dev/null
    code=$?
    if [[ ${code} != 0 ]]; then
        error "Unable to read from STDIN."
        eval "${func} 12"
    fi
    echo
    if [[ ${a} == 'y' || ${a} == 'Y' || ${a} == '' ]]; then
        info "${bldblu}Roger that."
        info "Let's just hope it won't go nuclear on us :) ðŸ’¥"
        hr
        echo
    else
        info "${bldred}(Great idea!) Abort! Abandon ship!  ðŸ›³   "
        hr
        echo
        eval "${func} 1"
    fi
}

----

==== `run.ui.ask-user-value`

[source,bash]
----
run.ui.ask-user-value () 
{ 
    local variable="$1"
    shift
    local text="$*"
    local user_input
    trap 'echo; echo Aborting at user request... ; echo; abort; return' int
    ask "${text}"
    read user_input
    if [[ -z "${user_input}" ]]; then
        error "Sorry, I didn't get that. Please try again or press Ctrl-C to abort."
        return 1
    else
        eval "export ${variable}=\"${user_input}\""
        return 0
    fi
}

----

==== `run.ui.get-user-value`

[source,bash]
----
run.ui.get-user-value () 
{ 
    run.ui.retry-command run.ui.ask-user-value "${@}"
}

----

==== `run.ui.press-any-key`

[source,bash]
----
run.ui.press-any-key () 
{ 
    local prompt="$*"
    [[ -z ${prompt} ]] && prompt="Press any key to continue..."
    br
    printf "    ${txtgrn}${italic}${prompt} ${clr}  "
    read -r -s -n1 key
    cursor.rewind
    printf "                                                           "
    cursor.up 2
    cursor.rewind
    echo
}

----

==== `run.ui.retry-command`

[source,bash]
----
run.ui.retry-command () 
{ 
    local command="$*"
    local retries=5
    n=0
    until [ $n -ge ${retries} ]; do
        [[ ${n} -gt 0 ]] && info "Retry number ${n}..."
        command && break
        n=$(($n + 1))
        sleep 1
    done
}

----


=== Module `runtime`

==== `run`

[source,bash]
----
run () 
{ 
    .run "$@"
    return ${LibRun__LastExitCode}
}

----

==== `run.config.detail-is-enabled`

[source,bash]
----
run.config.detail-is-enabled () 
{ 
    [[ ${LibRun__Detail} -eq ${True} ]]
}

----

==== `run.config.is-dry-run`

[source,bash]
----
run.config.is-dry-run () 
{ 
    [[ ${LibRun__DryRun} -eq ${True} ]]
}

----

==== `run.config.verbose-is-enabled`

[source,bash]
----
run.config.verbose-is-enabled () 
{ 
    [[ ${LibRun__Verbose} -eq ${True} ]]
}

----

==== `run.dry-run-prefix`

[source,bash]
----
run.dry-run-prefix () 
{ 
    if [[ ${LibRun__DryRun} == ${True} ]]; then
        printf "${txtcyn}${italic}Â« dry run Â»${clr} "
    fi
}

----

==== `run.inspect`

[source,bash]
----
run.inspect () 
{ 
    if [[ ${#@} -eq 0 || $(array.has-element "config" "$@") == "true" ]]; then
        run.inspect-variables-that-are starting-with LibRun
    fi
    if [[ ${#@} -eq 0 || $(array.has-element "totals" "$@") == "true" ]]; then
        hl.subtle "TOTALS"
        info "${bldgrn}${commands_completed} commands completed successfully"
        [[ ${commands_failed} -gt 0 ]] && info "${bldred}${commands_failed} commands failed"
        [[ ${commands_ignored} -gt 0 ]] && info "${bldylw}${commands_ignored} commands failed, but were ignored."
        echo
    fi
    if [[ ${#@} -eq 0 || $(array.has-element "current" "$@") == "true" ]]; then
        run.inspect-variables-that-are ending-with __LastExitCode
    fi
    reset-color
}

----

==== `run.inspect-variable`

[source,bash]
----
run.inspect-variable () 
{ 
    local var_name=${1}
    local var_value=${!var_name}
    local value=""
    local print_value=
    local max_len=120
    local avail_len=$(($(screen.width) - 45))
    local lcase_var_name="$(echo ${var_name} | tr 'A-Z' 'a-z')"
    local print_value=1
    local color="${bldblu}"
    local value_off=" âœ˜   "
    local value_check="âœ”ï¸Ž"
    if [[ -n "${var_value}" ]]; then
        if [[ ${lcase_var_name} =~ 'exit' ]]; then
            if [[ ${var_value} -eq 0 ]]; then
                value=${value_check}
                color="${bldgrn}"
            else
                print_value=1
                value=${var_value}
                color="${bldred}"
            fi
        else
            if [[ "${var_value}" == "${True}" || "${var_value}" == "1" ]]; then
                value="${value_check}"
                color="${bldgrn}"
            else
                if [[ "${var_value}" == "${False}" || "${var_value}" == "0" ]]; then
                    value="${value_off}"
                    color="${bldred}"
                fi
            fi
        fi
    else
        value="${value_off}"
        color="${bldred}"
    fi
    if [[ ${LibRun__Inspect__SkipFalseOrBlank} -eq ${True} && "${value}" == "${value_off}" ]]; then
        return 0
    fi
    printf "    ${bldylw}%-35s ${txtblk}${color} " ${var_name}
    [[ ${avail_len} -gt ${max_len} ]] && avail_len=${max_len}
    if [[ "${print_value}" -eq 1 ]]; then
        if [[ -n "${value}" ]]; then
            printf "%*.*s" ${avail_len} ${avail_len} "${value}"
        else
            if $(util.is-numeric "${var_value}"); then
                avail_len=$((${avail_len} - 5))
                if [[ "${var_value}" =~ '.' ]]; then
                    printf "%*.2f" ${avail_len} "${var_value}"
                else
                    printf "%*d" ${avail_len} "${var_value}"
                fi
            else
                avail_len=$((${avail_len} - 5))
                printf "%*.*s" ${avail_len} ${avail_len} "${var_value}"
            fi
        fi
    else
        printf "%*.*s" ${avail_len} ${avail_len} "${value}"
    fi
    echo
}

----

==== `run.inspect-variables`

[source,bash]
----
run.inspect-variables () 
{ 
    local title=${1}
    shift
    hl.subtle "${title}"
    for var in $@
    do
        run.inspect-variable "${var}"
    done
}

----

==== `run.inspect-variables-that-are`

[source,bash]
----
run.inspect-variables-that-are () 
{ 
    local pattern_type="${1}"
    local pattern="${2}"
    run.inspect-variables "VARIABLES $(echo ${pattern_type} | tr 'a-z' 'A-Z') ${pattern}" "$(run.variables-${pattern_type} ${pattern} | tr '\n' ' ')"
}

----

==== `run.inspect.set-skip-false-or-blank`

[source,bash]
----
run.inspect.set-skip-false-or-blank () 
{ 
    local value="${1}"
    [[ -n "${value}" ]] && export LibRun__Inspect__SkipFalseOrBlank=${value}
    [[ -z "${value}" ]] && export LibRun__Inspect__SkipFalseOrBlank=${True}
}

----

==== `run.on-error.ask-is-enabled`

[source,bash]
----
run.on-error.ask-is-enabled () 
{ 
    [[ ${LibRun__AskOnError} -eq ${True} ]]
}

----

==== `run.print-command`

[source,bash]
----
run.print-command () 
{ 
    local command="$1"
    local max_width=${2:-"100"}
    local min_width=60
    local w
    w=$(($(.output.screen-width) - 10))
    [[ ${w} -gt ${max_width} ]] && w=${max_width}
    export LibRun__AssignedWidth=${w}
    local prefix="${LibOutput__LeftPrefix}${clr}"
    local ascii_cmd
    local command_prompt="${prefix}â¯ "
    local command_width=$((w - 30))
    [[ ${command_width} -lt ${min_width} ]] && command_width=${min_width}
    ascii_cmd="$(printf "${command_prompt}$(run.dry-run-prefix)%-.${command_width}s " "${command:0:${command_width}}")"
    export LibRun__CommandLength=${#ascii_cmd}
    [[ ${LibRun__ShowCommandOutput} -eq ${True} ]] && { 
        export LibRun__AssignedWidth=$((w - 3))
        export LibRun__CommandLength=1
        printf "${prefix}${txtblk}# Command below will be shown with its output:${clr}\n"
    }
    if [[ "${LibRun__ShowCommand}" -eq ${False} ]]; then
        printf "${prefix}â¯ ${bldylw}%-.${command_width}s " "$(.output.replicate-to "*" 40)"
    else
        printf "${prefix}â¯ ${bldylw}%-.${command_width}s " "${command:0:${command_width}}"
    fi
}

----

==== `run.print-command-full-screen`

[source,bash]
----
run.print-command-full-screen () 
{ 
    run.print-long-command "$1" $(screen.width)
}

----

==== `run.print-long-command`

[source,bash]
----
run.print-long-command () 
{ 
    local command="$1"
    local max_width=${2:-"150"}
    local w
    w=$(($(.output.screen-width) - 10))
    [[ ${w} -gt ${max_width} ]] && w=${max_width}
    export LibRun__AssignedWidth=${w}
    local prefix="${LibOutput__LeftPrefix}${clr}"
    local ascii_cmd
    local command_prompt="${prefix}â¯ $(run.dry-run-prefix)"
    local command_width=$((w - 10))
    printf "${prefix}â¯ ${bldylw}"
    printf "${command}" | fold -s -w${w} | awk 'NR > 1 {printf "            "}; { printf "%s\n", $0}'
}

----

==== `run.print-variable`

[source,bash]
----
run.print-variable () 
{ 
    run.inspect-variable $1
}

----

==== `run.print-variables`

[source,bash]
----
run.print-variables () 
{ 
    local title=${1}
    shift
    hl.yellow "${title}"
    for var in $@
    do
        run.print-variable "${var}"
    done
}

----

==== `run.ui.press-any-key`

[source,bash]
----
run.ui.press-any-key () 
{ 
    local prompt="$*"
    [[ -z ${prompt} ]] && prompt="Press any key to continue..."
    br
    printf "    ${txtgrn}${italic}${prompt} ${clr}  "
    read -r -s -n1 key
    cursor.rewind
    printf "                                                           "
    cursor.up 2
    cursor.rewind
    echo
}

----

==== `run.variables-ending-with`

[source,bash]
----
run.variables-ending-with () 
{ 
    local suffix="${1}"
    env | grep -E -e ".*${suffix}=.*\$" | grep '=' | sedx 's/=.*//g' | sort
}

----

==== `run.variables-starting-with`

[source,bash]
----
run.variables-starting-with () 
{ 
    local prefix="${1}"
    env | grep -E -e "^${prefix}" | grep '=' | sedx 's/=.*//g' | sort
}

----

==== `run.was-successful`

[source,bash]
----
run.was-successful () 
{ 
    [[ ${LibRun__LastExitCode} -eq 0 ]]
}

----

==== `run.with.minimum-duration`

[source,bash]
----
run.with.minimum-duration () 
{ 
    local min_duration=$1
    shift
    local command="$*"
    local started=$(millis)
    info "starting a command with the minimum duration of ${bldylw}${min_duration} seconds"
    run "${command}"
    local result=$?
    local duration=$((($(millis) - ${started}) / 1000))
    if [[ ${result} -eq 0 && ${duration} -lt ${min_duration} ]]; then
        local cmd="$(echo ${command} | sedx 's/\"//g')"
        error "An operation finished too quickly. The threshold was set to ${bldylw}${min_duration} sec." "The command took ${bldylw}${duration}${txtred} secs." "${bldylw}${cmd}${txtred}"
        ((${BASH_IN_SUBSHELL})) && exit 1 || return 1
    else
        if [[ ${duration} -gt ${min_duration} ]]; then
            info "minimum duration operation ran in ${duration} seconds."
        fi
    fi
    return ${result}
}

----

==== `run.with.ruby-bundle`

[source,bash]
----
run.with.ruby-bundle () 
{ 
    .run.bundle.exec "$@"
}

----

==== `run.with.ruby-bundle-and-output`

[source,bash]
----
run.with.ruby-bundle-and-output () 
{ 
    .run.bundle.exec.with-output "$@"
}

----


=== Module `runtime-config`

==== `run.inspect`

[source,bash]
----
run.inspect () 
{ 
    if [[ ${#@} -eq 0 || $(array.has-element "config" "$@") == "true" ]]; then
        run.inspect-variables-that-are starting-with LibRun
    fi
    if [[ ${#@} -eq 0 || $(array.has-element "totals" "$@") == "true" ]]; then
        hl.subtle "TOTALS"
        info "${bldgrn}${commands_completed} commands completed successfully"
        [[ ${commands_failed} -gt 0 ]] && info "${bldred}${commands_failed} commands failed"
        [[ ${commands_ignored} -gt 0 ]] && info "${bldylw}${commands_ignored} commands failed, but were ignored."
        echo
    fi
    if [[ ${#@} -eq 0 || $(array.has-element "current" "$@") == "true" ]]; then
        run.inspect-variables-that-are ending-with __LastExitCode
    fi
    reset-color
}

----

==== `run.set-all`

[source,bash]
----
run.set-all () 
{ 
    ____run.configure all "$@"
}

----

==== `run.set-all.list`

[source,bash]
----
run.set-all.list () 
{ 
    set | ${GrepCommand} '^____run.set.all' | awk 'BEGIN{FS="."}{print $4}' | sedx 's/[() ]//g'
}

----

==== `run.set-next`

[source,bash]
----
run.set-next () 
{ 
    ____run.configure next "$@"
}

----

==== `run.set-next.list`

[source,bash]
----
run.set-next.list () 
{ 
    set | ${GrepCommand} '^____run.set.next' | awk 'BEGIN{FS="."}{print $4}' | sedx 's/[() ]//g'
}

----


=== Module `set`

==== `set-e-restore`

[source,bash]
----
set-e-restore () 
{ 
    [[ -f ${__bash_set_errexit_status} ]] && { 
        error "You must first save it with the function:s ${bldgrn}set-e-save"
        return 1
    }
    local status=$(cat ${__bash_set_errexit_status} | tr -d '\n')
    if [[ ${status} != 'on' && ${status} != 'off' ]]; then
        error "Invalid data in the set -e tempfile:" "$(cat ${__bash_set_errexit_status})"
        return 1
    fi
    set -o errexit ${status}
    rm -f ${__bash_set_errexit_status} 2> /dev/null
}

----

==== `set-e-save`

[source,bash]
----
set-e-save () 
{ 
    export __bash_set_errexit_status=$(mktemp -t 'errexit')
    rm -f ${__bash_set_errexit_status} 2> /dev/null
    set-e-status > ${__bash_set_errexit_status}
}

----

==== `set-e-status`

[source,bash]
----
set-e-status () 
{ 
    set -o | grep errexit | awk '{print $2}'
}

----


=== Module `settings`


=== Module `shdoc`

==== `gawk.install`

[source,bash]
----
gawk.install () 
{ 
    local gawk_path="$(command -v gawk 2>/dev/null)"
    [[ -n "${gawk_path}" && -x "${gawk_path}" ]] || brew.install.package gawk
}

----

==== `shdoc.install`

[source,bash]
----
shdoc.install () 
{ 
    hash -r
    export install_shdoc_path="/usr/local/bin"
    [[ -x ${install_shdoc_path}/shdoc ]] && return 0
    is.command gawk || gawk.install
    local temp="$(file.temp)"
    run "rm -rf ${temp}"
    run "mkdir -p ${temp}"
    run "curl -fsSL https://raw.githubusercontent.com/reconquest/shdoc/master/shdoc -o ${temp}/shdoc"
    sed -E -e 's~#\!/usr/bin/gawk~#\!/usr/bin/env gawk~g' "${temp}/shdoc" > "${install_shdoc_path}/shdoc"
    run "chmod 755 ${install_shdoc_path}/shdoc"
}

----

==== `shdoc.reinstall`

[source,bash]
----
shdoc.reinstall () 
{ 
    hash -r
    local i=0
    while true; do
        i=$(( i + 1 ))
        [[ $i -gt 3 ]] && { 
            error "After 3 attempts still can't find shdoc in /usr/local/bin?"
            return 1
        }
        local shdoc_path="$(which shdoc)"
        [[ ${shdoc_path} =~ ${BASHMATIC_HOME} ]] && continue
        [[ -z "${shdoc_path}" ]] && break
        [[ -f "${shdoc_path}" ]] && run "rm -f ${shdoc_path} || sudo rm -f ${shdoc_path}"
        hash -r
    done
    shdoc.install
}

----


=== Module `shell-set`

==== `save-restore-x`

[source,bash]
----
save-restore-x () 
{ 
    shell-set.pop-stack x
}

----

==== `save-set-x`

[source,bash]
----
save-set-x () 
{ 
    shell-set.push-stack x
}

----

==== `shell-set.init-stack`

[source,bash]
----
shell-set.init-stack () 
{ 
    unset SetOptsStack
    declare -a SetOptsStack=()
    export SetOptsStack
}

----

==== `shell-set.is-set`

[source,bash]
----
shell-set.is-set () 
{ 
    local v="$1"
    local is_set=${-//[^${v}]/}
    if [[ -n ${is_set} ]]; then
        return 0
    else
        return 1
    fi
}

----

==== `shell-set.pop-stack`

[source,bash]
----
shell-set.pop-stack () 
{ 
    local value="$1"
    local len=${#SetOptsStack[@]}
    local last_index=$((len - 1))
    local last=${SetOptsStack[${last_index}]}
    if [[ ${last} != "-${value}" && ${last} != "+${value}" ]]; then
        error "Can not restore ${value}, not the last element in ${SetOptsStack[*]} stack."
        return 1
    fi
    local pop=(${last})
    export SetOptsStack=("${SetOptsStack[@]/$pop/}")
    [[ -n ${DEBUG} ]] && shell-set-show
    eval "set ${last}"
}

----

==== `shell-set.push-stack`

[source,bash]
----
shell-set.push-stack () 
{ 
    local value="$1"
    local is_set=${-//[^${value}]/}
    shell-set.is-set ${value} && export SetOptsStack=(${SetOptsStack[@]} "-${value}")
    shell-set.is-set ${value} || export SetOptsStack=(${SetOptsStack[@]} "+${value}")
    [[ -n ${DEBUG} ]] && shell-set-show
}

----

==== `shell-set.show-stack`

[source,bash]
----
shell-set.show-stack () 
{ 
    info "Current Shell Set Stack: ${bldylw}[${SetOptsStack[*]}]"
}

----


=== Module `ssh`


=== Module `subshell`

==== `bashmatic.detect-subshell`

[source,bash]
----
bashmatic.detect-subshell () 
{ 
    bashmatic.subshell-init
    [[ -n ${BASH_SUBSHELL_DETECTED} && -n ${BASH_IN_SUBSHELL} ]] && return "${BASH_IN_SUBSHELL}"
    unset BASH_IN_SUBSHELL
    export BASH_SUBSHELL_DETECTED=true
    local len="${#BASH_SOURCE[@]}"
    local last_index=$((len - 1))
    [[ -n ${DEBUG} ]] && { 
        echo "BASH_SOURCE[*] = ${BASH_SOURCE[*]}" 1>&2
        echo "BASH_SOURCE[${last_index}] = ${BASH_SOURCE[${last_index}]}" 1>&2
        echo "\$0            = $0" 1>&2
    }
    if [[ -n ${ZSH_EVAL_CONEXT} && ${ZSH_EVAL_CONTEXT} =~ :file$ ]] || [[ -n ${BASH_VERSION} && "$0" != "${BASH_SOURCE[${last_index}]}" ]]; then
        export BASH_IN_SUBSHELL=0
    else
        export BASH_IN_SUBSHELL=1
    fi
    return ${BASH_IN_SUBSHELL}
}

----

==== `bashmatic.subshell-init`

[source,bash]
----
bashmatic.subshell-init () 
{ 
    export BASH_SUBSHELL_DETECTED=
}

----

==== `bashmatic.validate-sourced-in`

[source,bash]
----
bashmatic.validate-sourced-in () 
{ 
    bashmatic.detect-subshell
    [[ ${BASH_IN_SUBSHELL} -eq 0 ]] || { 
        echo "This script is meant to be sourced in, not run in a subshell." 1>&2
        return 1
    }
    return 0
}

----

==== `bashmatic.validate-subshell`

[source,bash]
----
bashmatic.validate-subshell () 
{ 
    bashmatic.detect-subshell
    [[ ${BASH_IN_SUBSHELL} -eq 1 ]] || { 
        echo "This script is meant to be run, not sourced-in" 1>&2
        return 1
    }
    return 0
}

----


=== Module `sym`

==== `decrypt.secrets`

[source,bash]
----
decrypt.secrets () 
{ 
    ./bin/decrypt
    local code=$?
    [[ ${code} != 0 ]] && { 
        error "bin/decrypt returned non-zero exit status ${code}"
        echo
        exit ${code}
    }
}

----

==== `dev.crypt.chef`

[source,bash]
----
dev.crypt.chef () 
{ 
    sym -ck APP_CHEF_SYM_KEY $*
}

----

==== `dev.decrypt.file`

[source,bash]
----
dev.decrypt.file () 
{ 
    [[ -f ${1} ]] || { 
        error 'usage: dev.decrypt.file <filename.enc>'
        return
    }
    sym -ck APP_SYM_KEY -n "${1}"
}

----

==== `dev.decrypt.str`

[source,bash]
----
dev.decrypt.str () 
{ 
    [[ -z ${1} ]] && { 
        error 'usage: dev.decrypt.str "string to decrypt"'
        return
    }
    sym -ck APP_SYM_KEY -d -s "$*"
}

----

==== `dev.edit.file`

[source,bash]
----
dev.edit.file () 
{ 
    [[ -f ${1} ]] || { 
        error 'usage: dev.edit.file <filename>'
        return
    }
    sym -ck APP_SYM_KEY -t "${1}"
}

----

==== `dev.encrypt.file`

[source,bash]
----
dev.encrypt.file () 
{ 
    [[ -f ${1} ]] || { 
        error 'usage: dev.encrypt.file <filename>'
        return
    }
    sym -ck APP_SYM_KEY -e -f "${1}" -o "${1}.enc"
}

----

==== `dev.encrypt.str`

[source,bash]
----
dev.encrypt.str () 
{ 
    [[ -z "${1}" ]] && { 
        error 'usage: dev.encrypt.str "string to encrypt"'
        return
    }
    sym -ck APP_SYM_KEY -e -s "$*"
}

----

==== `dev.sym`

[source,bash]
----
dev.sym () 
{ 
    sym -cqk APP_SYM_KEY $*
}

----

==== `sym.dev.configure`

[source,bash]
----
sym.dev.configure () 
{ 
    export SYMIT__KEY="APP_SYM_KEY"
}

----

==== `sym.dev.files`

[source,bash]
----
sym.dev.files () 
{ 
    find . -name '*.enc' -type f
}

----

==== `sym.dev.have-key`

[source,bash]
----
sym.dev.have-key () 
{ 
    sym.dev.configure
    if [[ -z ${CI} ]]; then
        [[ -z "$(keychain ${SYMIT__KEY} find 2>/dev/null)" ]] || printf "yes"
    else
        [[ -n "${APP_SYM_KEY}" ]] && print "yes"
    fi
}

----

==== `sym.dev.import`

[source,bash]
----
sym.dev.import () 
{ 
    local skip_instructions=${1:-0}
    if [[ ${AppCurrentOS} != 'Darwin' ]]; then
        error 'This is only meant to run on Mac OS-X'
        return
    fi
    sym.dev.configure
    sym.install.symit
    [[ -f ~/.sym.symit.bash ]] && source ~/.sym.symit.bash
    h2 'Encryption Key Import'
    info "Checking for the existence of the current key..."
    if [[ -n "$(sym.dev.have-key)" ]]; then
        info: "Key ${SYMIT_KEY} is already in you your OS-X Key Chain."
        run.ui.ask "Would you like to re-import it?"
        [[ $? != 0 ]] && return
    fi
    if [[ ${skip_instructions} == ${false} ]]; then
        hr
        echo
        info "1. Please open 1Password App and search for 'Encryption Key'"
        echo
        info "2. Once you find the entry, it will contain two items: encryption key"
        info "      and password. Start by copying the key to the clipboard."
        echo
        info "3. You will need to paste the key first, and then copy/paste"
        info "      the key password (also in 1Password)"
        echo
        info "4. As a final setup, you will be asked to create a new password."
        info "      It must be at least 7 characters long, and will be used to encrypt"
        info "      the key locally on your machine."
        echo
        echo
        run.ui.ask "Ready?"
        [[ $? != 0 ]] && return
    fi
    echo
    hr
    sym -iqpx APP_SYM_KEY
    code=$?
    [[ ${code} != 0 ]] && { 
        error "Sym exited with error code ${code}"
        return ${code}
    }
    hr
    echo
    info "Key import was successful, great job! ${bldylw}â˜º "
    info "You can test that it works by encrypting, and decrypting a string,"
    echo
    info "\$ ${bldylw}source bin/bash"
    info "\$ ${bldylw}dev.encrypt.str hello"
    info "\$ ${bldylw}dev.decrypt.str \$(dev.encrypt.str hello )"
    echo
    info "Or a file:"
    info "\$ ${bldylw}dev.decrypt.file config/application.dev.yml.enc"
    echo
    info "You can edit the file as if it wasn't encrypted:"
    info "\$ ${bldylw}dev.edit.file config/application.dev.yml.enc"
    echo
}

----

==== `sym.dev.install-shell-helpers`

[source,bash]
----
sym.dev.install-shell-helpers () 
{ 
    local found=
    declare -a init_files=($(util.shell-init-files))
    for file in "${init_files[@]}"
    do
        f="${file}"
        [[ ! -f "${f}" ]] && continue
        [[ -n $(grep sym.symit ${f}) ]] && { 
            found=${f}
            break
        }
    done
    if [[ -z ${found} ]]; then
        for file in "${init_files[@]}"
        do
            f="${file}"
            if [[ -f "${f}" ]]; then
                run "sym -B ${f} 1>/dev/null"
                return $?
            fi
        done
    else
        run "sym -B ${found} 1>/dev/null"
    fi
}

----

==== `sym.install.symit`

[source,bash]
----
sym.install.symit () 
{ 
    if [[ ! -f config.ru ]]; then
        error "Please run this command from the RAILS_ROOT folder"
        return 1
    fi
    [[ -n "$(which sym 2>/dev/null)" && -f ~/.sym.symit.bash ]] && return
    local symit_source="/tmp/sym.symit.bash.$$"
    trap "rm -f ${symit__source}; " EXIT
    local symit_url="https://raw.githubusercontent.com/kigster/sym/master/bin/sym.symit.bash"
    local cmd="curl -fsSL ${symit_url} -o ${symit_source}"
    export LibRun__AbortOnError=${True}
    run "${cmd}"
    if [[ ! -f ${symit_source} ]]; then
        err "unable to find downloaded file ${symit_source}"
        return 1
    fi
    source ${symit_source}
    rm -f ${symit_source}
    run "symit install"
    sym.dev.install-shell-helpers
}

----


=== Module `text`

==== `text.chr`

[source,bash]
----
text.chr () 
{ 
    [ "$1" -lt 256 ] || return 1
    printf "\\$(printf '%03o' "$1")"
}

----

==== `text.markdown-to-asciidoc`

[source,bash]
----
text.markdown-to-asciidoc () 
{ 
    local file="$1"
    shift
    local default_flags="--imagesdir=/assets/images --no-html-to-native"
    [[ -n $(command -v kramdoc) ]] || gem.install "kramdown-asciidoc"
    if [[ -z "${file}" ]]; then
        usage.set-min-flag-len 1
        usage-box "text.markdown-to-asciidoc markdown-file [ flags ] Â© Converts a markdown doc to asciidoc using the kramdown-asciidoc ruby gem" " " "Default flags: ${bldcyn}${default_flags}" " " "To override pass any flags that are supported by ${bldred}kramdoc${bldylw}, see below:"
        printf "\n${txtblu}"
        kramdoc --help | tail -16
        printf "${clr}\n"
        return 0
    fi
    [[ -f ${file} && $(file.extension "${file}") == "md" ]] || { 
        error "File ${file} either does not exist, or is not markdown."
        run.set-all on-decline-return
        run.ui.ask "Convert anyway?"
    }
    local target="$(file.extension.replace adoc "${file}")"
    file.ask.if-exists "${target}" || { 
        info "Aborting conversion, leaving ${target} in place."
        return 1
    }
    gem.install "kramdown-asciidoc"
    local args
    if [[ -z "$*" ]]; then
        args="--auto-ids --auto-id-prefix=_ --auto-id-separator=_ --imagesdir=/assets/images --no-html-to-native"
    else
        args="$*"
    fi
    run "kramdoc -o ${target} ${args} ${file}"
}

----

==== `text.ord`

[source,bash]
----
text.ord () 
{ 
    LC_CTYPE=C printf '%d' "'$1"
}

----


=== Module `time`

==== `date.now.with-time`

[source,bash]
----
date.now.with-time () 
{ 
    date '+%F.%T'
}

----

==== `epoch`

[source,bash]
----
epoch () 
{ 
    date +%s
}

----

==== `millis`

[source,bash]
----
millis () 
{ 
    .run.millis
}

----

==== `time.date-from-epoch`

[source,bash]
----
time.date-from-epoch () 
{ 
    local epoch_ts="$1"
    if [[ "${AppCurrentOS}" == "Darwin" ]]; then
        printf "date -r ${epoch_ts}"
    else
        printf "date --date='@${epoch_ts}'"
    fi
}

----

==== `time.duration.humanize`

[source,bash]
----
time.duration.humanize () 
{ 
    local seconds=${1}
    local hours=$((${seconds} / 3600))
    local remainder=$((${seconds} - ${hours} * 3600))
    local mins=$((${remainder} / 60))
    local secs=$((${seconds} - ${hours} * 3600 - ${mins} * 60))
    local prefixed=0
    [[ ${hours} -gt 0 ]] && { 
        printf "%02dh:" ${hours}
        prefixed=1
    }
    [[ ${mins} -gt 0 || ${prefixed} == 1 ]] && { 
        printf "%02dm:" ${mins}
        prefixed=1
    }
    { 
        printf "%02ds" ${secs}
    }
}

----

==== `time.duration.millis-to-secs`

[source,bash]
----
time.duration.millis-to-secs () 
{ 
    local duration="$1"
    local format="${2:-"%d.%d"}"
    local seconds=$((duration / 1000))
    local leftover=$((duration - 1000 * seconds))
    printf "${format}" ${seconds} ${leftover}
}

----

==== `time.epoch-to-iso`

[source,bash]
----
time.epoch-to-iso () 
{ 
    local epoch_ts=$1
    eval "$(time.date-from-epoch ${epoch_ts}) -u \"+%Y-%m-%dT%H:%M:%S%z\"" | sed 's/0000/00:00/g'
}

----

==== `time.epoch-to-local`

[source,bash]
----
time.epoch-to-local () 
{ 
    local epoch_ts=$1
    [[ -z ${epoch_ts} ]] && epoch_ts=$(epoch)
    eval "$(time.date-from-epoch ${epoch_ts}) \"+%m/%d/%Y, %r\""
}

----

==== `time.epoch.minutes-ago`

[source,bash]
----
time.epoch.minutes-ago () 
{ 
    local mins=${1}
    [[ -z ${mins} ]] && mins=1
    local seconds=$((${mins} * 60))
    local epoch=$(epoch)
    echo $((${epoch} - ${seconds}))
}

----

==== `time.now.db`

[source,bash]
----
time.now.db () 
{ 
    date '+%F.%T.%S   ' | tr -d '[\:\-\.]'
}

----

==== `time.now.file-extension`

[source,bash]
----
time.now.file-extension () 
{ 
    time.now.db
}

----

==== `time.now.with-ms`

[source,bash]
----
time.now.with-ms () 
{ 
    local date_runnable
    date_runnable='date'
    if [[ "${AppCurrentOS}" == "Darwin" ]]; then
        [[ -z $(command -v gdate) ]] && .time.osx.coreutils
        [[ -n $(command -v gdate) ]] && date_runnable='gdate'
    fi
    ${date_runnable} '+%T.%3N'
}

----

==== `today`

[source,bash]
----
today () 
{ 
    date +'%Y-%m-%d'
}

----


=== Module `trap`

==== `trap-setup`

[source,bash]
----
trap-setup () 
{ 
    .trap-remove
    local signal="${1:-"SIGINT"}"
    trap '.trap-catch' "${signal}"
    export __int_signal__="${signal}"
}

----

==== `trap-was-fired`

[source,bash]
----
trap-was-fired () 
{ 
    if [[ -n "${__int_marker__}" && -f "${__int_marker__}" ]]; then
        rm -f "${__int_marker__}"
        return 0
    fi
    return 1
}

----

==== `trapped`

[source,bash]
----
trapped () 
{ 
    if [[ ${__int_flag__} -eq 1 ]]; then
        unset __int__flag__
        return 0
    fi
    return 1
}

----


=== Module `url`

==== `url.downloader`

[source,bash]
----
url.downloader () 
{ 
    local downloader=
    if [[ -z "${LibUrl__Downloader}" ]]; then
        [[ -z "${downloader}" && -n $(which curl) ]] && downloader="$(which curl) ${LibUrl__CurlDownloaderFlags}"
        [[ -z "${downloader}" && -n $(which wget) ]] && downloader="$(which wget) ${LibUrl__WgetDownloaderFlags}"
        [[ -z "${downloader}" ]] && { 
            error "Neither Curl nor WGet appear in the \$PATH... HALP?"
            return 1
        }
        export LibUrl__Downloader="${downloader}"
    fi
    printf "${LibUrl__Downloader}"
}

----

==== `url.http-code`

[source,bash]
----
url.http-code () 
{ 
    local url="$1"
    local quiet="${2:-false}"
    [[ -z $(which wget) ]] && { 
        echo 1>&2
        err "This function currently only supports ${bldylw}wget.\n" 1>&2
        echo 1>&2
        return 100
    }
    url.is-valid "$url" || { 
        echo 1>&2
        err "The URL provided is not a valid URL: ${bldylw}${url}\n" 1>&2
        echo 1>&2
        return 101
    }
    local result=$(wget -v --spider "${url}" 2>&1 | ${GrepCommand} "response" | awk '{print $6}' | tr -d ' ' | tail -1)
    export LibUrl__LastHttpCode="${result}"
    if [[ ${quiet} == true ]]; then
        if [[ ${result} -gt 199 && ${result} -lt 210 ]]; then
            return 0
        else
            return 1
        fi
    else
        [[ -n "${result}" ]] && printf ${result} || printf "404"
    fi
}

----

==== `url.is-valid`

[source,bash]
----
url.is-valid () 
{ 
    local url="$1"
    if [[ $(url.valid-status "$url") = "ok" ]]; then
        return 0
    else
        return 1
    fi
}

----

==== `url.shorten`

[source,bash]
----
url.shorten () 
{ 
    local longUrl="$1"
    error "This function used Bitly API V3 which is now defunct."
    return 1
    if [[ -z "${BITLY_LOGIN}" || -z "${BITLY_API_KEY}" ]]; then
        printf "${longUrl}"
    else
        export BITLY_LOGIN=$(printf '%s' "${BITLY_LOGIN}" | tr -d '\r' | tr -d '\n')
        export BITLY_API_KEY=$(printf '%s' "${BITLY_API_KEY}" | tr -d '\r' | tr -d '\n')
        if [[ -n $(which ruby) ]]; then
            longUrl=$(ruby -e "require 'uri'; str = '${longUrl}'.force_encoding('ASCII-8BIT'); puts URI.encode(str)")
        fi
        bitlyUrl="http://api.bit.ly/v3/shorten?login=${BITLY_LOGIN}&apiKey=${BITLY_API_KEY}&format=txt&longURL=${longUrl}"
        debug "BITLY_LOLGIN : ${clr}${bldylw}${BITLY_LOGIN}" 1>&2
        debug "BITLY_LOLGIN : ${clr}${bldgrn}${BITLY_API_KEY}" 1>&2
        debug "BITLY_API_URL: ${clr}${undblu}${bitlyUrl}${clr}" 1>&2
        local output="$($(url.downloader) "${bitlyUrl}" 2>&1)"
        if [[ "${output}" =~ "INVALID" || "${output}" =~ "Server Error" ]]; then
            error "${output}"
            return 1
        else
            printf "%s" "${output}" | tr -d '\n' | tr -d ' '
            return 0
        fi
    fi
}

----

==== `url.valid-status`

[source,bash]
----
url.valid-status () 
{ 
    local url="$1"
    echo "${url}" | ruby -ne '
    require "uri"
    u = URI.parse("#{$_}".chomp)
    if u && u.host && u.host&.include?(".") && u&.scheme =~ /^http/
      print "ok"
    else
      print "invalid"
    end'
}

----


=== Module `usage`

==== `help-command`

[source,bash]
----
help-command () 
{ 
    printf "    ${bldylw}\$ $*\n"
}

----

==== `help-comment`

[source,bash]
----
help-comment () 
{ 
    printf "    ${txtblk}# $*\n"
}

----

==== `help-details`

[source,bash]
----
help-details () 
{ 
    printf "    ${txtblu}$*\n"
}

----

==== `help-example`

[source,bash]
----
help-example () 
{ 
    printf "    ${bldgrn}\$ $*\n"
}

----

==== `help-name`

[source,bash]
----
help-name () 
{ 
    box.white-on-green "$@"
}

----

==== `help-section`

[source,bash]
----
help-section () 
{ 
    printf "\n${bldgrn}$(echo "$*" | tr '[:lower:]' '[:upper:]')\n"
}

----

==== `usage-box`

[source,bash]
----
usage-box () 
{ 
    local backup="$(.usage-cache-file)"
    if [[ "${EXPIRE_USAGE_CACHE}" -eq 0 && -s "${backup}" ]]; then
        cat "${backup}"
    else
        .usage.box "$@" | tee ${backup}
    fi
}

----

==== `usage-box.section`

[source,bash]
----
usage-box.section () 
{ 
    printf "${__color_headers}"
    .usage.hdr "$*"
}

----

==== `usage-box.sub-section`

[source,bash]
----
usage-box.sub-section () 
{ 
    .output.box-separator "${__color_bdr}"
    .output.boxed-text "${__color_bdr}" "${__color_sub_headers}" "$(.usage.hdr "$1")"
}

----

==== `usage.set-min-flag-len`

[source,bash]
----
usage.set-min-flag-len () 
{ 
    export LibUsage__MinFlagLen="${1}"
}

----


=== Module `user`

==== `user`

[source,bash]
----
user () 
{ 
    local user
    user=$(user.finger.name)
    [[ -z "${user}" ]] && user="$(user.gitconfig.name)"
    [[ -z "${user}" ]] && user="$(user.gitconfig.email)"
    [[ -z "${user}" ]] && user="$(user.username)"
    echo "${user}"
}

----

==== `user.current-shell`

[source,bash]
----
user.current-shell () 
{ 
    /bin/ps -p $$ -o comm | tail -1 | sed -E 's/-//g'
}

----

==== `user.current-shell-init-file`

[source,bash]
----
user.current-shell-init-file () 
{ 
    declare -a shell_files=($(util.shell-init-files user.current-shell))
    .user.pick-shell-init-file "${shell_files[@]}"
}

----

==== `user.finger.name`

[source,bash]
----
user.finger.name () 
{ 
    [[ -n $(which finge) ]] && finger "${USER}" | head -1 | sedx 's/.*Name: //g'
}

----

==== `user.first`

[source,bash]
----
user.first () 
{ 
    user | tr '\n' ' ' | ruby -ne 'puts $_.split(/ /).first.capitalize'
}

----

==== `user.gitconfig.email`

[source,bash]
----
user.gitconfig.email () 
{ 
    if [[ -s ${HOME}/.gitconfig ]]; then
        grep email "${HOME}/.gitconfig" | sedx 's/.*=\s?//g'
    fi
}

----

==== `user.gitconfig.name`

[source,bash]
----
user.gitconfig.name () 
{ 
    if [[ -s ${HOME}/.gitconfig ]]; then
        grep name "${HOME}/.gitconfig" | sedx 's/.*=\s?//g'
    fi
}

----

==== `user.host`

[source,bash]
----
user.host () 
{ 
    local host=
    host=$(user.my.reverse-ip)
    [[ -z ${host} ]] && host=$(user.my.ip)
    printf "${host}"
}

----

==== `user.login-shell`

[source,bash]
----
user.login-shell () 
{ 
    basename "$(user.login-shell-path)"
}

----

==== `user.login-shell-init-file`

[source,bash]
----
user.login-shell-init-file () 
{ 
    declare -a shell_files=($(util.shell-init-files))
    .user.pick-shell-init-file "${shell_files[@]}"
}

----

==== `user.login-shell-path`

[source,bash]
----
user.login-shell-path () 
{ 
    if [[ -n $(command -v finger 2>/dev/null) ]]; then
        finger "${USER}" | grep Shell: | sed 's/^.*Shell: //g'
    else
        if grep -q "${USER}" /etc/passwd 2> /dev/null; then
            grep "${USER}" /etc/passwd | sed 's/.*://g'
        else
            command -v "$(user.current-shell)"
        fi
    fi
}

----

==== `user.my.ip`

[source,bash]
----
user.my.ip () 
{ 
    dig +short myip.opendns.com @resolver1.opendns.com
}

----

==== `user.my.reverse-ip`

[source,bash]
----
user.my.reverse-ip () 
{ 
    nslookup "$(user.my.ip)" | grep 'name =' | sedx 's/.*name = //g'
}

----

==== `user.pairs.email`

[source,bash]
----
user.pairs.email () 
{ 
    [[ ! -s "${bashmatic_git_pairs}" || -z "$1" ]] && return
    local username="$(user.pairs.username "$1")"
    local domain="$(grep domain "${bashmatic_git_pairs}" | sed 's/.*domain://g' | tr -d ' ')"
    [[ -n ${username} && -n "${domain}" ]] || { 
        error "Couldn't determine username or domain from ${bashmatic_git_pairs} file for input ${bldwht}$*"
        return 1
    }
    echo "${username}@${domain}"
}

----

==== `user.pairs.firstname`

[source,bash]
----
user.pairs.firstname () 
{ 
    [[ ! -s "${bashmatic_git_pairs}" || -z "$1" ]] && return
    grep -i "$1" "${bashmatic_git_pairs}" | head -1 | awk '{print $2}' | tr -d ';'
}

----

==== `user.pairs.lastname`

[source,bash]
----
user.pairs.lastname () 
{ 
    [[ ! -s "${bashmatic_git_pairs}" || -z "$1" ]] && return
    grep -i "$1" "${bashmatic_git_pairs}" | head -1 | awk '{print $3}' | tr -d ';'
}

----

==== `user.pairs.set-file`

[source,bash]
----
user.pairs.set-file () 
{ 
    [[ -s "$1" ]] || { 
        error "Please pass a valid path to the .pairs file, typically in your home. You passed: [$1]"
        return 1
    }
    export bashmatic_git_pairs="$1"
}

----

==== `user.pairs.username`

[source,bash]
----
user.pairs.username () 
{ 
    [[ ! -s "${bashmatic_git_pairs}" || -z "$1" ]] && return
    grep -i "$1" "${bashmatic_git_pairs}" | head -1 | awk '{print $4}' | tr -d ';'
}

----

==== `user.username`

[source,bash]
----
user.username () 
{ 
    echo "${USER:-$(whoami)}"
}

----


=== Module `util`

==== `is-func`

[source,bash]
----
is-func () 
{ 
    is.a-function "$@"
}

----

==== `pause`

[source,bash]
----
pause () 
{ 
    sleep "${1:-1}"
}

----

==== `pause.long`

[source,bash]
----
pause.long () 
{ 
    sleep "${1:-10}"
}

----

==== `pause.medium`

[source,bash]
----
pause.medium () 
{ 
    sleep "${1:-0.3}"
}

----

==== `pause.short`

[source,bash]
----
pause.short () 
{ 
    sleep "${1:-0.1}"
}

----

==== `sedx`

[source,bash]
----
sedx () 
{ 
    [[ -z ${bashmatic__sed_command} ]] && sedx.cache-command
    ${bashmatic__sed_command} "$@"
}

----

==== `sedx.cache-command`

[source,bash]
----
sedx.cache-command () 
{ 
    local sed_path="$(util.ensure-gnu-sed)"
    local sed_command="${sed_path} -r -e "
    export bashmatic__sed_command="${sed_command}"
}

----

==== `util.append-to-init-files`

[source,bash]
----
util.append-to-init-files () 
{ 
    local string="$1"
    local search="${2:-$1}"
    is_installed=
    declare -a shell_files=($(util.shell-init-files))
    for init_file in "${shell_files[@]}"
    do
        file="${init_file}"
        [[ -f ${file} && -n $(grep "${search}" ${file}) ]] && { 
            is_installed=${file}
            break
        }
    done
    if [[ -z "${is_installed}" ]]; then
        for init_file in "${shell_files[@]}"
        do
            file="${init_file}"
            [[ -f ${file} ]] && { 
                echo "${string}" >> "${file}"
                is_installed="${file}"
                break
            }
        done
    fi
    printf "${is_installed}"
}

----

==== `util.arch`

[source,bash]
----
util.arch () 
{ 
    echo -n "${AppCurrentOS}-$(uname -m)-$(uname -p)" | tr 'A-Z' 'a-z'
}

----

==== `util.call-if-function`

[source,bash]
----
util.call-if-function () 
{ 
    local func="$1"
    shift
    util.is-a-function "${func}" && { 
        ${func} "$@"
    }
}

----

==== `util.checksum.files`

[source,bash]
----
util.checksum.files () 
{ 
    cat $* | shasum | awk '{print $1}'
}

----

==== `util.checksum.stdin`

[source,bash]
----
util.checksum.stdin () 
{ 
    shasum | awk '{print $1}'
}

----

==== `util.dev-setup.update`

[source,bash]
----
util.dev-setup.update () 
{ 
    run "rm -f ${BASHMATIC_HOME}/bin/.dev-setup"
    run "dev-setup -N -h > /tmp/a"
    run "mv /tmp/a ${BASHMATIC_HOME}/bin/.dev-setup"
    run "cd ${BASHMATIC_HOME} && git add bin/.dev-setup"
    run "cd -"
}

----

==== `util.ensure-gnu-sed`

[source,bash]
----
util.ensure-gnu-sed () 
{ 
    local sed_path
    local gsed_path
    local os
    sed_path="$(command -v sed 2>/dev/null)"
    os="$(uname -s)"
    case ${os} in 
        Darwin)
            gsed_path="$(command -v gsed 2>/dev/null)"
            if [[ -z "${gsed_path}" ]]; then
                echo
                output.constrain-screen-width 100
                h3 "Please wait while we install gnu-sed using Brew..." "It's a required dependency for many key features." 1>&2
                ( [[ $(brew.package.is-installed gnu-sed) == "false" ]] && brew install gnu-sed ) 1>&2 > /dev/null
                hash -r 2> /dev/null
                gsed_path="$(command -v gsed 2>/dev/null)"
                [[ -z ${gsed_path} && -x /usr/local/bin/gsed ]] && gsed_path="/usr/local/bin/gsed"
            fi
            [[ -n "${gsed_path}" && -x "${gsed_path}" ]] || { 
                error "Can't find GNU sed even after installation." 1>&2
                return 2
            }
            sed_path="${gsed_path}"
        ;
        Linux)
            sed_path="$(which sed)"
        ;
        *)
            echo "Operating system \"${os}\" is not supported." 1>&2
            return 2
        ;
    esac
    output.unconstrain-screen-width
    echo -n "${sed_path}"
}

----

==== `util.functions-matching`

[source,bash]
----
util.functions-matching () 
{ 
    local prefix="${1}"
    local extra_command=${2:-"cat"}
    set | ${GrepCommand} "^${prefix}" | sedx 's/[\(\)]//g;' | tr -d ' ' | tr '\n' ' '
}

----

==== `util.functions-matching.diff`

[source,bash]
----
util.functions-matching.diff () 
{ 
    for e in $(util.functions-matching "${1}")
    do
        echo "${e/${1}/}"
    done
}

----

==== `util.functions-starting-with`

[source,bash]
----
util.functions-starting-with () 
{ 
    local prefix="${1}"
    local extra_command=${2:-"cat"}
    set | ${GrepCommand} '^[^ ].* \(\) $' | ${GrepCommand} "^${prefix}" | sedx 's/[\(\)]//g;' | ${extra_command} | tr '\n ' ' '
}

----

==== `util.functions-starting-with-csv`

[source,bash]
----
util.functions-starting-with-csv () 
{ 
    local prefix="$1"
    util.functions-starting-with "${prefix}" | sedx "s/${prefix/./\\.}//g; s/\s+(\w)/, \1/g;"
}

----

==== `util.functions-starting-with-lines`

[source,bash]
----
util.functions-starting-with-lines () 
{ 
    local prefix="${1}"
    local extra_command=${2:-"cat"}
    set | ${GrepCommand} '^[^ ].* \(\) $' | ${GrepCommand} "^${prefix}" | sedx 's/[\(\)]//g;' | ${extra_command}
}

----

==== `util.generate-password`

[source,bash]
----
util.generate-password () 
{ 
    local len=${1:-32}
    local val=$(($(date '+%s') - 100000 * $RANDOM))
    [[ ${val:0:1} == "-" ]] && val=${val/-//}
    printf "$(echo ${val} | shasum -a 512 | awk '{print $1}' | base64 | head -c "${len}")"
}

----

==== `util.i-to-ver`

[source,bash]
----
util.i-to-ver () 
{ 
    version=${1}
    /usr/bin/env ruby -e "ver='${version}'; printf %Q{%d.%d.%d}, ver[1..2].to_i, ver[3..5].to_i, ver[6..8].to_i"
}

----

==== `util.install-direnv`

[source,bash]
----
util.install-direnv () 
{ 
    [[ -n $(which direnv) ]] || brew.install.package direnv
    local init_file=
    local init_file=$(util.append-to-init-files 'eval "$(direnv hook bash)"; export DIRENV_LOG_FORMAT=' 'direnv hook')
    if [[ -f ${init_file} ]]; then
        info: "direnv init has been appended to ${bldylw}${init_file}..."
    else
        error: "direnv init could not be appended"
    fi
    eval "$(direnv hook bash)"
}

----

==== `util.invoke-if-function`

[source,bash]
----
util.invoke-if-function () 
{ 
    local namespace="$1"
    shift
    local action="$1"
    shift
    local func="${namespace}.${action}"
    util.is-a-function "${func}" || return 255
    ${func} "$@"
}

----

==== `util.is-a-function`

[source,bash]
----
util.is-a-function () 
{ 
    is.a-function "$@"
}

----

==== `util.is-numeric`

[source,bash]
----
util.is-numeric () 
{ 
    is.numeric "$1"
}

----

==== `util.is-variable-defined`

[source,bash]
----
util.is-variable-defined () 
{ 
    local var_name="$1"
    [[ -n ${!var_name+x} ]]
}

----

==== `util.lines-in-folder`

[source,bash]
----
util.lines-in-folder () 
{ 
    local folder=${1:-'.'}
    find "${folder}" -type f -exec wc -l {} \; | awk 'BEGIN{a=0}{a+=$1}END{print a}'
}

----

==== `util.random-number`

[source,bash]
----
util.random-number () 
{ 
    local limit="${1:-"1000000"}"
    printf $(((RANDOM % ${limit})))
}

----

==== `util.remove-from-init-files`

[source,bash]
----
util.remove-from-init-files () 
{ 
    local search="${1}"
    local backup_extension="${2}"
    [[ -z ${backup_extension} ]] && backup_extension="$(epoch).backup"
    [[ -z ${search} ]] && return
    declare -a shell_files=($(util.shell-init-files))
    local temp_holder=$(mktemp)
    for init_file in "${shell_files[@]}"
    do
        run.config.detail-is-enabled && inf "verifying file ${init_file}..."
        file="${init_file}"
        if [[ -f ${file} && -n $(grep "${search}" "${file}") ]]; then
            run.config.detail-is-enabled && ui.closer.ok:
            local matches=$(grep -c "${search}" "${file}")
            run.config.detail-is-enabled && info "file ${init_file} matches with ${bldylw}${matches} matches"
            run "grep -v \"${search}\" ${file} > ${temp_holder}"
            if [[ -n "${backup_extension}" ]]; then
                local backup="${file}.${backup_extension}"
                run.config.detail-is-enabled && info "backup file will created in ${bldylw}${backup}"
                [[ -n "${do_backup_changes}" ]] && "mv ${file} ${backup}"
            fi
            run "cp -v ${temp_holder} ${file}"
        else
            run.config.detail-is-enabled && ui.closer.not-ok:
        fi
    done
    return "${LibRun__LastExitCode}"
}

----

==== `util.rot13`

[source,bash]
----
util.rot13 () 
{ 
    local value="$*"
    echo "$value" | util.rot13-stdin
}

----

==== `util.rot13-stdin`

[source,bash]
----
util.rot13-stdin () 
{ 
    ruby -e 'puts STDIN.read.
  tr(
    "0123456789",
    "5678901234").
  tr(
    "abcdefghijklmnopqrstuvwxyz",
    "nopqrstuvwxyzabcdefghijklm").
  tr(
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    "NOPQRSTUVWXYZABCDEFGHIJKLM")'
}

----

==== `util.shell-init-files`

[source,bash]
----
util.shell-init-files () 
{ 
    local shell_function="${1:-"user.login-shell"}"
    local shell_name=$(${shell_function})
    if [[ ${shell_name} == "bash" ]]; then
        echo "${HOME}/.bash_profile ${HOME}/.bash_login ${HOME}/.bashrc ${HOME}/.profile"
    else
        if [[ ${shell_name} == "zsh" ]]; then
            echo "${HOME}/.zshrc"
        else
            error "Shell ${shell_name} is not supported."
            return 1
        fi
    fi
}

----

==== `util.ver-to-i`

[source,bash]
----
util.ver-to-i () 
{ 
    version=${1}
    echo "${version}" | awk 'BEGIN{FS="."}{ printf "1%02d%03.3d%03.3d", $1, $2, $3}'
}

----

==== `util.whats-installed`

[source,bash]
----
util.whats-installed () 
{ 
    declare -a hb_aliases=($(alias | ${GrepCommand} 'hb\..*=' | sedx 's/alias//g; s/=.*$//g'))
    h2 "Installed app aliases:" ' ' "${hb_aliases[@]}"
    h2 "Installed DB Functions:"
    info "hb.db  [ ms | r1 | r2 | c ]"
    info "hb.ssh <server-name-substring>, eg hb.ssh web"
}

----

==== `watch.command`

[source,bash]
----
watch.command () 
{ 
    [[ -z "$1" ]] && return 1
    trap "return 1" SIGINT
    while true; do
        clear
        hr.colored "${txtblu}"
        printf " â¯ Command: ${bldgrn}$*${clr}  â€¢  ${txtblu}$(date)${clr}  â€¢  Refresh: ${bldcyn}${LibUtil__WatchRefreshSeconds}${clr}\n"
        hr.colored "${txtblu}"
        eval "$*"
        hr.colored "${txtblu}"
        printf "To change refresh rate run ${bldylw}watch.set-refresh <seconds>${clr}\n\n\n"
        sleep "${LibUtil__WatchRefreshSeconds}"
    done
}

----

==== `watch.ls-al`

[source,bash]
----
watch.ls-al () 
{ 
    while true; do
        ls -al
        sleep "${LibUtil__WatchRefreshSeconds}"
        clear
    done
}

----

==== `watch.set-refresh`

[source,bash]
----
watch.set-refresh () 
{ 
    export LibUtil__WatchRefreshSeconds="${1:-"0.5"}"
}

----


=== Module `vim`

==== `gvim.off`

[source,bash]
----
gvim.off () 
{ 
    vim.gvim-off
}

----

==== `gvim.on`

[source,bash]
----
gvim.on () 
{ 
    vim.gvim-on
}

----

==== `vim.gvim-off`

[source,bash]
----
vim.gvim-off () 
{ 
    vim.setup
    [[ "${EDITOR}" == "vim" ]] && return 0
    local regex_from='^export EDITOR=.*$'
    local regex_to='export EDITOR=vim'
    file.gsub "${LibVim__initFile}" "${regex_from}" "${regex_to}"
    file.gsub "${LibVim__initFile}" '^gvim.on$' 'gvim.off'
    ${GrepCommand} -q "${regex_from}" ${LibVim__initFile} || echo "${regex_to}" >> ${LibVim__initFile}
    ${GrepCommand} -q "^gvim\.o" ${LibVim__initFile} || echo "gvim.off" >> ${LibVim__initFile}
    eval "
    [[ -n '${DEBUG}' ]] && set -x
    export EDITOR=${LibVim__editorGvimOff}
    unalias ${LibVim__editorVi} 2>/dev/null
    unalias ${LibVim__editorGvimOff} 2>/dev/null
  "
}

----

==== `vim.gvim-on`

[source,bash]
----
vim.gvim-on () 
{ 
    vim.setup
    [[ "${EDITOR}" == "gvim" ]] && return 0
    local regex_from='^export EDITOR=.*$'
    local regex_to='export EDITOR=gvim'
    file.gsub "${LibVim__initFile}" "${regex_from}" "${regex_to}"
    file.gsub "${LibVim__initFile}" '^gvim.off$' 'gvim.on'
    ${GrepCommand} -q "${regex_from}" ${LibVim__initFile} || echo "${regex_to}" >> ${LibVim__initFile}
    ${GrepCommand} -q "^gvim\.o.*" ${LibVim__initFile} || echo "gvim.on" >> ${LibVim__initFile}
    eval "
    [[ -n '${DEBUG}' ]] && set -x
    export EDITOR=${LibVim__editorGvimOn}
    alias ${LibVim__editorVi}=${LibVim__editorGvimOn}
    alias ${LibVim__editorGvimOff}=${LibVim__editorGvimOn}
  "
}

----

==== `vim.setup`

[source,bash]
----
vim.setup () 
{ 
    export LibVim__initFile="${HOME}/.bash_profile"
    export LibVim__editorVi="vi"
    export LibVim__editorGvimOn="gvim"
    export LibVim__editorGvimOff="vim"
}

----


=== Module `yaml`

==== `yaml-diff`

[source,bash]
----
yaml-diff () 
{ 
    yaml.diff "$@"
}

----

==== `yaml-dump`

[source,bash]
----
yaml-dump () 
{ 
    yaml.dump "$@"
}

----

==== `yaml.diff`

[source,bash]
----
yaml.diff () 
{ 
    local f1="$1"
    shift
    local f2="$1"
    shift
    [[ -f "$f1" && -f "$f2" ]] || { 
        h2 "USAGE: ${bldylw}yaml-diff file1.yml file2.yml [ ydiff-options ]"
        return 1
    }
    [[ -n $(which ${BashMatic__DiffTool}) ]] || brew.package.install ${BashMatic__DiffTool}
    local t1="/tmp/${RANDOM}.$(basename ${f1}).$$.yml"
    local t2="/tmp/${RANDOM}.$(basename ${f2}).$$.yml"
    yaml.expand-aliases "$f1" > "$t1"
    yaml.expand-aliases "$f2" > "$t2"
    run.set-next show-output-on
    hr
    run "ydiff $* ${t1} ${t2}"
    hr
    run "rm -rf ${t1} ${t2}"
}

----

==== `yaml.dump`

[source,bash]
----
yaml.dump () 
{ 
    local f1="$1"
    shift
    [[ -f "$f1" ]] || { 
        h2 "USAGE: ${bldylw}yaml-dump file.yml"
        return 1
    }
    [[ -n $(which ${BashMatic__DiffTool}) ]] || brew.package.install ${BashMatic__DiffTool}
    local t1="/tmp/${RANDOM}.$(basename ${f1}).$$.yml"
    yaml.expand-aliases "$f1" > "$t1"
    vim "$t1"
    run "rm -rf ${t1}"
}

----

==== `yaml.expand-aliases`

[source,bash]
----
yaml.expand-aliases () 
{ 
    ruby -e "require 'yaml'; require 'json'; puts YAML.dump(JSON.parse(JSON.pretty_generate(YAML.load(File.read('${1}')))))"
}

----


=== Module `zsh`



== Copyright



Â© 2020 Konstantin Gredeskoul, All rights reserved, MIT License.