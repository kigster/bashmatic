= Bashmatic Functions Index
:allow-uri-read:
:doctype: book
:sectnums:
:showtitle:
:toc:
:toclevels: 5
:icons: font

== Bashmatic Modules

* xref:#module-.audio[.audio]
* xref:#module-7z[7z]
* xref:#module-array[array]
* xref:#module-asciidoc[asciidoc]
* xref:#module-audio[audio]
* xref:#module-aws[aws]
* xref:#module-bashit[bashit]
* xref:#module-bashmatic[bashmatic]
* xref:#module-brew[brew]
* xref:#module-caller[caller]
* xref:#module-color[color]
* xref:#module-config[config]
* xref:#module-db[db]
* xref:#module-db_cli[db_cli]
* xref:#module-db_rails[db_rails]
* xref:#module-db_top[db_top]
* xref:#module-deploy[deploy]
* xref:#module-dir[dir]
* xref:#module-docker[docker]
* xref:#module-dropbox[dropbox]
* xref:#module-file[file]
* xref:#module-file-helpers[file-helpers]
* xref:#module-flatten[flatten]
* xref:#module-ftrace[ftrace]
* xref:#module-gem[gem]
* xref:#module-git[git]
* xref:#module-github[github]
* xref:#module-gpg[gpg]
* xref:#module-is[is]
* xref:#module-jemalloc[jemalloc]
* xref:#module-json[json]
* xref:#module-maths[maths]
* xref:#module-net[net]
* xref:#module-nvm[nvm]
* xref:#module-openssl[openssl]
* xref:#module-osx[osx]
* xref:#module-output[output]
* xref:#module-output-admonitions[output-admonitions]
* xref:#module-output-boxes[output-boxes]
* xref:#module-output-repeat-char[output-repeat-char]
* xref:#module-output-utils[output-utils]
* xref:#module-package[package]
* xref:#module-path[path]
* xref:#module-pdf[pdf]
* xref:#module-pg[pg]
* xref:#module-pids[pids]
* xref:#module-pipe[pipe]
* xref:#module-progress-bar[progress-bar]
* xref:#module-repositories[repositories]
* xref:#module-ruby[ruby]
* xref:#module-run[run]
* xref:#module-runtime[runtime]
* xref:#module-runtime-config[runtime-config]
* xref:#module-sedx[sedx]
* xref:#module-serial[serial]
* xref:#module-set[set]
* xref:#module-shasum[shasum]
* xref:#module-shdoc[shdoc]
* xref:#module-shell-set[shell-set]
* xref:#module-ssh[ssh]
* xref:#module-subshell[subshell]
* xref:#module-sym[sym]
* xref:#module-text[text]
* xref:#module-time[time]
* xref:#module-trap[trap]
* xref:#module-url[url]
* xref:#module-usage[usage]
* xref:#module-user[user]
* xref:#module-util[util]
* xref:#module-video[video]
* xref:#module-vim[vim]
* xref:#module-yaml[yaml]
* xref:#module-yarn[yarn]
* xref:#module-zsh[zsh]

== List of Bashmatic Functions


=== Module `.audio`


=== Module `7z`

==== `7z.a`

[source,bash]
----
7z.a () 
{ 
    7z.zip "$@"
}

----

==== `7z.install`

[source,bash]
----
7z.install () 
{ 
    [[ -n $(which 7z) ]] || run "brew install p7zip"
    [[ -n $(which 7z) ]] || { 
        error "7z is not found after installation"
        return 1
    }
    return 0
}

----

==== `7z.unzip`

[source,bash]
----
7z.unzip () 
{ 
    7z.install
    local archive="$1"
    [[ -f ${archive} ]] || archive="${archive}.tar.7z"
    [[ -f ${archive} ]] || { 
        error "Neither $1 nor ${archive} were found."
        return 1
    }
    info "Unpacking archive ${txtylw}${archive}$(txt-info), total of $(file.size "${archive}") bytes."
    run.set-next show-output-on
    run "7za x -so ${archive} | tar xfv -"
}

----

==== `7z.x`

[source,bash]
----
7z.x () 
{ 
    7z.unzip "$@"
}

----

==== `7z.zip`

[source,bash]
----
7z.zip () 
{ 
    local folder="$1"
    shift
    7z.install
    local archive="${folder}"
    [[ -f "${folder}" || -d "${folder}" ]] && archive="$(basename "${folder}" | sed -E 's/\./-/g').tar.7z"
    [[ -f ${archive} ]] && { 
        run.set-next on-decline-return
        run.ui.ask "File ${archive} already exists. Press Y to remove it and continue." || return 1
        run "rm -f ${archive}"
    }
    local -a flags=
    local -a args=
    for arg in $@
    do
        if [[ ${arg:0:1} == "-" ]]; then
            flags=(${flags[@]} "${arg}")
        else
            args=(${args[@]} "${arg}")
        fi
    done
    printf "${bldgrn}"
    printf "${args[*]}\n"
    printf "${bldylw}"
    set +e
    local command="tar cf - ${folder} ${args[*]} | 7za a ${flags[*]} -si -bd ${archive}"
    run.print-command "${command}"
    eval "${command}"
    local code=$?
    printf "${clr}"
    if [[ ${code} -eq 0 ]]; then
        success "${archive} created."
    else
        error "Tar/7z Exited with code ${code}"
        return 1
    fi
}

----


=== Module `array`

==== `array.eval.in-groups-of`

[source,bash]
----
array.eval.in-groups-of () 
{ 
    local chunk="$1"
    shift
    local function="$1"
    shift
    local -a group
    for item in "$@"
    do
        index="$(( index + 1 ))"
        if [[ ${#group[@]} -eq ${chunk} ]]; then
            ${function} "${group[@]}"
            group=("${item}")
        else
            group=("${group[@]}" "${item}")
        fi
    done
    if [[ ${#group[@]} -gt 0 ]]; then
        ${function} "${group[@]}"
    fi
    return 0
}

----

==== `array.force-range`

[source,bash]
----
array.force-range () 
{ 
    local n="$1"
    is.numeric "${n}" || { 
        error "First argument to this function must be numeric, got ${n}" 1>&2
        return 1
    }
    shift
    [[ "${#@}" -gt 0 ]] || { 
        error "Please pass additional arguments to define min/max" 1>&2
        return 1
    }
    local min=$(array.min "$@")
    local max=$(array.max "$@")
    if [[ $n -lt $min ]]; then
        n=${min}
    else
        if [[ $n -gt ${max} ]]; then
            n=${max}
        else
            n=${n}
        fi
    fi
    printf -- "%d" "${n}"
}

----

==== `array.from.command`

[source,bash]
----
array.from.command () 
{ 
    local func="array.from.command.$(user.current-shell)"
    is.a-function "${func}" || return 1
    ${func} "$@"
}

----

==== `array.from.command.bash`

[source,bash]
----
array.from.command.bash () 
{ 
    local array_name="$1"
    shift
    local command="$*"
    local OFS="$IFS"
    eval "IFS=\$'\\n'; read -r -d '' -a ${array_name}  < <( bash -c \"${command}\" || true && printf '\0' ); export ${array_name} || true"
    export IFS="$OFS"
}

----

==== `array.from.command.zsh`

[source,bash]
----
array.from.command.zsh () 
{ 
    local array_name="$1"
    shift
    local command="$*"
    eval "declare -a ${array_name}"
    eval "${array_name}=(\"\${(@f)\$(command)}\"); export ${array_name}; true"
    return
}

----

==== `array.has-element`

[source,bash]
----
array.has-element () 
{ 
    local search="$1"
    shift
    local r="false"
    local e
    [[ "$*" =~ ${search} ]] || { 
        echo -n $r
        return 1
    }
    for e in "${@}"
    do
        [[ "$e" == "${search}" ]] && r="true"
    done
    echo -n $r
    [[ $r == "false" ]] && return 1
    return 0
}

----

==== `array.includes`

[source,bash]
----
array.includes () 
{ 
    local search="$1"
    [[ -z $search ]] && return 1
    shift
    [[ "$*" =~ "${search}" ]] || return 1
    for e in "${@}"
    do
        [[ "$e" == "${search}" ]] && { 
            return 0
        }
    done
    return 1
}

----

==== `array.includes-or-complain`

[source,bash]
----
array.includes-or-complain () 
{ 
    array.includes "$@" || { 
        element="$1"
        shift
        local -a output=()
        while true; do
            [[ -z "$1" ]] && break
            if [[ "$1" =~ " " ]]; then
                output=("${output[@]}" "$1")
            else
                output=("$1")
            fi
            shift
        done
        if [[ ${#output[@]} -gt 10 ]]; then
            error "Value ${element} must be one of the supplied values."
        else
            error "Value ${element} must be one of the supplied values:" "${output[@:0:10]}"
        fi
        echo
        return 0
    }
    return 1
}

----

==== `array.includes-or-exit`

[source,bash]
----
array.includes-or-exit () 
{ 
    array.includes-or-complain "$@" || exit 1
}

----

==== `array.join`

[source,bash]
----
array.join () 
{ 
    local sep="$1"
    shift
    local lines="$1"
    if [[ ${lines} == true || ${lines} == false ]]; then
        shift
    else
        lines=false
    fi
    local elem
    local len="$#"
    local last_index=$(( len - 1 ))
    local index=0
    for elem in "$@"
    do
        if ${lines}; then
            printf "${sep}%s\n" "${elem}"
        else
            printf "%s" "${elem}"
            [[ ${index} -lt ${last_index} ]] && printf '%s' "${sep}"
        fi
        index=$(( index + 1 ))
    done
}

----

==== `array.max`

[source,bash]
----
array.max () 
{ 
    local max="$1"
    shift
    for v in "$@"
    do
        is.numeric "$v" || continue
        [[ ${v} -gt ${max} ]] && max="$v"
    done
    printf -- "%d" "${max}"
}

----

==== `array.min`

[source,bash]
----
array.min () 
{ 
    local min="$1"
    shift
    for v in "$@"
    do
        is.numeric "$v" || continue
        [[ ${v} -lt ${min} ]] && min="$v"
    done
    printf -- "%d" "${min}"
}

----

==== `array.sort`

[source,bash]
----
array.sort () 
{ 
    local IFS_previous="${IFS}"
    export IFS=''
    printf "%s\n" "$@" | sort | tr '\n' ' ' | sed 's/ $//g'
    IFS="${IFS_previous}"
}

----

==== `array.sort-numeric`

[source,bash]
----
array.sort-numeric () 
{ 
    local IFS_previous="${IFS}"
    export IFS=''
    printf "%s\n" "$@" | sort -n | tr '\n' ' ' | sed 's/ $//g'
    IFS="${IFS_previous}"
}

----

==== `array.to.bullet-list`

[source,bash]
----
array.to.bullet-list () 
{ 
    array.join ' â€¢ ' true "$@"
}

----

==== `array.to.csv`

[source,bash]
----
array.to.csv () 
{ 
    array.join ', ' false "$@"
}

----

==== `array.to.piped-list`

[source,bash]
----
array.to.piped-list () 
{ 
    array.join ' | ' false "$@"
}

----

==== `array.uniq`

[source,bash]
----
array.uniq () 
{ 
    local IFS_previous="${IFS}"
    IFS=''
    printf "%s\n" "$@" | sort -u | tr '\n' ' ' | sed 's/ $//g'
    IFS="${IFS_previous}"
}

----


=== Module `asciidoc`

==== `asciidoc.rouge-themes`

[source,bash]
----
asciidoc.rouge-themes () 
{ 
    gem.install rouge
    info "Available themes:"
    local -a themes=($(ruby -e 'require :rouge.to_s; puts Rouge::Theme.registry.keys.sort.join ?\n'))
    array.to.bullet-list "${themes[@]}"
    echo
    info "To specify a theme in your *.adoc file, put this at the top:"
    info "${bldlyw}:source-highlighter: ${bldgrn}rouge"
    info "${bldlyw}:rouge-style: ${bldgrn}monokai"
}

----


=== Module `audio`

==== `Ã¦.mp3`

[source,bash]
----
Ã¦.mp3 () 
{ 
    audio.make.mp3 "$@"
}

----

==== `audio.dir.mp3-to-wav`

[source,bash]
----
audio.dir.mp3-to-wav () 
{ 
    local from="$1"
    local to="$2"
    run "cd \"${from}\""
    trap "return 1" INT
    while read -d '' filename; do
        audio.file.mp3-to-wav "${filename}" "${to}" < /dev/null
    done < <(find . -type f -name "*.mp3" -print0)
    run "cd -"
}

----

==== `audio.dir.rename-karaoke-wavs`

[source,bash]
----
audio.dir.rename-karaoke-wavs () 
{ 
    audio.dir.rename-wavs karaoke "$@"
}

----

==== `audio.dir.rename-wavs`

[source,bash]
----
audio.dir.rename-wavs () 
{ 
    local format="$1"
    shift
    local func=".audio.${format}.format"
    is.a-function "${func}" || { 
        error "Format not recognized: ${format}" "usage: audio.dir.rename-wavs <renaming-scheme> [ optional-dir ]"
        return 1
    }
    local dir="$1"
    local pwd="$(pwd -P)"
    if [[ -n "${dir}" ]]; then
        [[ ! -d "${dir}" ]] && { 
            error "First argument is either blank (current directory)" "or the folder where *.wav files to be renamed are."
            return 1
        }
        cd "${dir}" || exit
    fi
    local nfile
    for file in $(ls -1 '*.wav')
    do
        n="$(.audio.karaoke.format "${file}" | sed 's/â€”/_/g')"
        h1 "${file}" "${n}"
        run "mv -vn \"${file}\" \"${n}\""
    done
    run "cd \"${pwd}\""
}

----

==== `audio.file.frequency`

[source,bash]
----
audio.file.frequency () 
{ 
    local file="$1"
    [[ -z $(command -V mdls) ]] && return 1
    local frequency=$(mdls "${file}" | grep kMDItemAudioSampleRate | sed 's/.*= //g')
    [[ -z ${frequency} ]] && frequency=48000
    local kHz=$(maths.eval "${frequency} / 1000.0" 0)
    printf "${kHz}"
}

----

==== `audio.file.mp3-to-wav`

[source,bash]
----
audio.file.mp3-to-wav () 
{ 
    local from="${1/.\//}"
    local destination="$2"
    if [[ -z ${destination} ]]; then
        destination="$(dirname "${from}")"
    else
        destination="${destination}/$(dirname "${from}")"
    fi
    local to="${destination}/$(basename "${from/.mp3/.wav}")"
    if [[ ${from} =~ ".mp3" ]]; then
        h.blue "Source:      ${from}"
        cursor.up 1
        h.green "Destination: ${to}"
        [[ -f "${to}" ]] && { 
            info: "File already converted."
            return 0
        }
        run "mkdir -p \"${destination}\""
        run.set-next show-output-on
        run "lame --decode \"${from}\" \"${to}\""
    else
        error "File ${from} is not an MP3 file."
        return 1
    fi
}

----

==== `audio.m4a.to.mp3`

[source,bash]
----
audio.m4a.to.mp3 () 
{ 
    local file="$1"
    [[ -z "${file}" ]] && return 0
    [[ -f "${file}" ]] || { 
        error "File does not exist: ${file}"
        return 1
    }
    local output="${file/\.m4a/.mp3}"
    [[ -s ${output} ]] && { 
        info "${file} has already been converted... Skipping."
        return 0
    }
    h1 "From: ${bldylw}${file} " "To:   ${bldblu}${output}"
    command -v ffmpeg > /dev/null || video.install.dependencies
    local cmd="ffmpeg -i \"${file}\" -codec:a libmp3lame -qscale:a 1 \"${output}\""
    h2 "${cmd}"
    run "${cmd}"
}

----

==== `audio.m4as.to.mp3s`

[source,bash]
----
audio.m4as.to.mp3s () 
{ 
    folder="${1:-"."}"
    info "Converting the following files:"
    find "${folder}" -name '*.m4a'
    hr
    echo
    info "Ctrl-C to abort."
    echo
    find "${folder}" -name '*.m4a' -exec bash -c 'source ~/.bashmatic/init.sh; audio.m4a.to.mp3 "{}"' \
}

----

==== `audio.make.mp3`

[source,bash]
----
audio.make.mp3 () 
{ 
    local file="$1"
    shift
    local nfile="$2"
    shift
    set +e
    [[ -n "$(command -V lame)" ]] || brew.package.install lame
    local default_options=" -m s -b 320 "
    [[ -n "${file}" ]] || { 
        audio.make.mp3.usage && return 1
    }
    [[ -s "${file}" ]] || { 
        error "File '${file}' does not exist."
        audio.make.mp3.usage && return 2
    }
    [[ -z ${nfile} ]] && nfile="$(echo "${file}" | sedx 's/\.(wav|aiff?)$/\.mp3/g')"
    local khz=$(audio.file.frequency "${file}")
    h2 "'$(basename "${file}")' â€”â¯ ${txtylw}${nfile}${txtgrn}, sample rate: ${khz:-'Unknown'}kHz"
    info "lame ${default_options} $* '${file}' '${nfile}'"
    run.set-next show-output-on abort-on-error
    run "lame ${default_options}  $* '${file}' '${nfile}'"
    hr
    success "MP3 file ${nfile} is $(file.size.mb "${nfile}")Mb"
}

----

==== `audio.make.mp3.usage`

[source,bash]
----
audio.make.mp3.usage () 
{ 
    usage-box "audio.wav-to-mp3 [ file.wav | file.aif | file.aiff ] [ file.mp3 ] Â© Convert a RAW PCM Audio to highest quality MP3" "You can pass additional flags to ${txtylw}lame" "" "Just run ${txtylw}lame --longhelp for more info." "" "Default Flags: ${default_options}" ""
}

----

==== `audio.make.mp3s`

[source,bash]
----
audio.make.mp3s () 
{ 
    local dir="${1:-"."}"
    local kHz="${2:-"48"}"
    local first="$(find "${dir}" -type f -a \( -name "*.aif*" -o -name "*.wav" \) -print | head -1)"
    h3 "Converting WAV and AIF files to MP3 in ${txtylw}${dir}."
    if [[ -z ${first} ]]; then
        error "No AIFF or WAV files in the folder ${bldgrn}${dir}"
        return 1
    fi
    inf "Determining audio sampling rate (will apply the same rate to all files)... "
    kHz=$(audio.file.frequency "${first}")
    printf "${bldgrn} â€” ${kHz}kHz"
    ok:
    SAVEIFS=$IFS
    run.set-all show-command-on show-output-off abort-on-error
    find "${dir}" -type f -a \( -name "*.aif*" -o -name "*.wav" \) -print0 | while read -d '' file; do
        local fn=$(ascii-clean "${file}")
        mp3=$(echo "${file}" | sedx 's/\.(wav|aiff?)$/.mp3/g')
        inf "checking ${txtylw}${file} $(txt-info) ... "
        if [[ -f "${mp3}" && -z "${FORCE}" ]]; then
            printf "${bldgrn} OK, already converted. Use FORCE=1 to overwrite. ${clr}"
            ok:
            continue
        fi
        printf "${txtcyn} Transcoding...${clr}"
        ui.closer.kind-of-ok:
        inf "â¯ ${txtylw}lame --silent -m s -b 320  \"${file}\""
        trap _term SIGINT
        lame --silent -m s -b 320 "${fn}" & child_pid=$!
        wait "$child_pid"
        code=$?
        if [[ ${code} -ne 0 ]]; then
            ui.closer.not-ok:
            info "${bakred}${bldwht}  ERROR: lame exited with an error code ${code}. Aborting!  "
            [[ -f "${mp3}" ]] && { 
                info "NOTE: removing unfinished MP3 file ${mp3}."
                rm -f "${mp3}" 1>&2 > /dev/null
            }
            break
        else
            ok:
        fi
    done
    success 'All done.'
}

----


=== Module `aws`

==== `aws.ec2`

[source,bash]
----
aws.ec2 () 
{ 
    local cmd="$1"
    local command="$cmd"
    case $command in 
        list | show | ls)
            __utf_table "$(aws ec2 describe-instances --query 'Reservations[*].Instances[*].{name: Name, instance_id: InstanceId, ip_address: PrivateIpAddress, state: State.Name}' --output table 2> /dev/null)"
            return $?
        ;
        *)
            error "Invalid Command: ${cmd}"
            return 1
        ;
    esac
}

----

==== `aws.rds.hostname`

[source,bash]
----
aws.rds.hostname () 
{ 
    local name=${1}
    [[ -z $(which jq) ]] && out=$(brew.install.package jq 2> /dev/null > /dev/null)
    [[ -z $(which aws) ]] && out=$(brew.install.package awscli 2> /dev/null > /dev/null)
    [[ -n ${name} ]] && aws rds describe-db-instances | jq '.[][].Endpoint.Address' | sedx 's/"//g' | ${GrepCommand} "^${name}\."
    [[ -z ${name} ]] && aws rds describe-db-instances | jq '.[][].Endpoint.Address' | sedx 's/"//g'
}

----

==== `aws.s3.upload`

[source,bash]
----
aws.s3.upload () 
{ 
    local pathname="$1"
    shift
    local skip_file_modification="$1"
    [[ -n ${skip_file_modification} ]] && skip_file_modification=true
    [[ -z ${skip_file_modification} ]] && skip_file_modification=false
    if [[ -z "${LibAws__DefaultUploadBucket}" || -z "${LibAws__DefaultUploadFolder}" ]]; then
        error "Required AWS S3 configuration is not defined." "Please set variables: ${bldylw}LibAws__DefaultUploadFolder" "and ${bldylw}LibAws__DefaultUploadBucket" "before using this function."
        return 1
    fi
    if [[ ! -f "${pathname}" ]]; then
        error "Local file was not found: ${bldylw}${pathname}"
        return 1
    fi
    local file=$(basename "${pathname}")
    local remote_file="${file}"
    local year=$(file.last-modified-year "${pathname}")
    local date=$(file.last-modified-date "${pathname}")
    [[ -z ${year} ]] && year=$(date +'%Y')
    [[ -z ${date} ]] && date=$(today)
    ${skip_file_modification} || { 
        [[ "${remote_file}" =~ "${date}" ]] && remote_file=$(echo "${remote_file}" | sedx "s/[_\.-]?${date}[_\.-]//g")
        [[ "${remote_file}" =~ "${date}" ]] || remote_file="${date}.${remote_file}"
    }
    remote_file=$(echo "${remote_file}" | sed -E 's/ /-/g;s/--+/-/g' | tr '[A-Z]' '[a-z]')
    local remote="s3://${LibAws__DefaultUploadBucket}/${LibAws__DefaultUploadFolder}/${year}/${remote_file}"
    run "aws s3 cp \"${pathname}\" \"${remote}\""
    if [[ ${LibRun__LastExitCode} -eq 0 ]]; then
        local remoteUrl="https://s3-${LibAws__DefaultRegion}.amazonaws.com/${LibAws__DefaultUploadBucket}/${LibAws__DefaultUploadFolder}/${year}/${remote_file}"
        [[ -n "${LibAws__ObjectUrlFile}" ]] && echo "${remoteUrl}" > "${LibAws__ObjectUrlFile}"
        echo
        info "NOTE: You should now be able to access your resource at the following URL:"
        hr
        info "${bldylw}${remoteUrl}"
        hr
    else
        error "AWS S3 upload failed with code ${LibRun__LastExitCode}"
    fi
    return "${LibRun__LastExitCode}"
}

----


=== Module `bashit`

==== `bashit-activate`

[source,bash]
----
bashit-activate () 
{ 
    local color
    local func
    export __bashmatic_bash_it_loaded=1
    bashit-install
    bashit-init
    bashit-colorscheme dark
    bashit-prompt-minimal
    while true; do
        local arg="$1"
        shift
        [[ -z "${arg}" ]] && break
        color="$(bashit-colorschemes | grep "${arg}")"
        if [[ -n "${color}" ]]; then
            bashit-colorscheme "${color}"
        else
            local func="bashit-prompt-${arg}"
            if is.a-function "${func}"; then
                ${func}
            else
                erroir "Unrecognized argument: [${arg}] is neither a color nor prompt type."
                return 1
            fi
        fi
    done
}

----

==== `bashit-colorscheme`

[source,bash]
----
bashit-colorscheme () 
{ 
    local scheme="$1"
    if [[ -z "${scheme}" ]]; then
        if [[ "${ITERM_PROFILE}" =~ "Light" || "${ITERM_PROFILE}" =~ "light" ]]; then
            export scheme=light
        else
            export scheme=dark
        fi
    else
        local theme="${BASH_IT}/colorschemes/${scheme}.colorscheme.bash"
        if [[ -f ${theme} ]]; then
            source "${theme}"
        else
            error "Color theme ${scheme} does not exist." 1>&2
        fi
    fi
}

----

==== `bashit-colorschemes`

[source,bash]
----
bashit-colorschemes () 
{ 
    find "${BASH_IT}/colorschemes" -type f -name '*.colorscheme.bash' 2> /dev/null | tr '\n' '\0' | xargs -0 -n1 basename | sed 's/\.colorscheme\.bash//g'
}

----

==== `bashit-init`

[source,bash]
----
bashit-init () 
{ 
    export BASH_IT="${HOME}/.bash_it"
    export BASH_IT_THEME="powerline"
    export BASH_IT_THEME="powerline-multiline"
    export BASH_IT_REMOTE="${__bashmatic_bash_it_remote}"
    source "${BASH_IT}/bash_it.sh"
    export GIT_HOSTING='git@git.domain.com'
    export SHORT_HOSTNAME="$(hostname -s)"
    export SHORT_TERM_LINE=true
    export BASH_IT_P4_DISABLED=true
    export SCM=git
    export SCM_CHECK=true
}

----

==== `bashit-install`

[source,bash]
----
bashit-install () 
{ 
    if [[ ! -d "${HOME}/.bash_it" && -n $(command -v git 2> /dev/null) ]]; then
        git clone -q "${__bashmatic_bash_it_source}" ~/.bash_it > /dev/null
    fi
    [[ -d ${HOME}/.bash_it ]] || return 1
}

----

==== `bashit-list-prompts`

[source,bash]
----
bashit-list-prompts () 
{ 
    regex="^bashit-prompt-([a-z0-9]*)"
    for f in $(set | grep -E "$regex")
    do
        [[ $f =~ $regex ]] && echo "${BASH_REMATCH[1]}"
    done
}

----

==== `bashit-prompt-aws`

[source,bash]
----
bashit-prompt-aws () 
{ 
    powerline.prompt.git.max
    powerline.prompt.left aws_profile scm cwd shlvl last_status
    powerline.prompt.right clock battery user_info hostname
}

----

==== `bashit-prompt-developer`

[source,bash]
----
bashit-prompt-developer () 
{ 
    powerline.prompt.git.max
    powerline.prompt.left go node ruby scm cwd shlvl last_status
    powerline.prompt.right clock battery user_info hostname
}

----

==== `bashit-prompt-gcloud`

[source,bash]
----
bashit-prompt-gcloud () 
{ 
    powerline.prompt.git.max
    powerline.prompt.left gcloud scm cwd shlvl last_status
    powerline.prompt.right clock battery user_info hostname
}

----

==== `bashit-prompt-k8s`

[source,bash]
----
bashit-prompt-k8s () 
{ 
    powerline.prompt.git.max
    powerline.prompt.left k8s_context scm cwd shlvl last_status
    powerline.prompt.right clock battery user_info hostname
}

----

==== `bashit-prompt-minimal`

[source,bash]
----
bashit-prompt-minimal () 
{ 
    powerline.prompt.git.min
    powerline.prompt.left scm cwd last_status
    powerline.prompt.right go node ruby clock battery
}

----

==== `bashit-prompt-terraform`

[source,bash]
----
bashit-prompt-terraform () 
{ 
    powerline.prompt.git.max
    powerline.prompt.left terraform scm cwd shlvl last_status
    powerline.prompt.right clock battery user_info hostname
}

----

==== `bashit-refresh`

[source,bash]
----
bashit-refresh () 
{ 
    bashit-activate "$@"
}

----


=== Module `bashmatic`

==== `bashmatic.auto-update`

[source,bash]
----
bashmatic.auto-update () 
{ 
    ( unset -f _direnv_hook > /dev/null 2>&1
    [[ ${Bashmatic__Test} -eq 1 ]] && return 0
    local pwd="$(pwd -P)"
    cd "${BASHMATIC_HOME:="${HOME}/.bashmatic"}" || exit
    git.configure-auto-updates
    git.repo-is-clean || { 
        output.is-ssh || { 
            output.is-terminal && bashmatic.auto-update-error
            cd "${pwd}" > /dev/null || exit
            return 1
        }
    }
    git.update-repo-if-needed
    cd "${pwd}" > /dev/null || exit )
}

----

==== `bashmatic.auto-update-error`

[source,bash]
----
bashmatic.auto-update-error () 
{ 
    bashmatic.is-developer || return
    file.exists-and-newer-than "${__bashmatic_warning_notification}" 10 || return
    touch "${__bashmatic_warning_notification}"
    if [[ -f ${__bashmatic_auto_update_help_file} ]]; then
        cat "${__bashmatic_auto_update_help_file}" 1>&2
    else
        output.constrain-screen-width 60
        box.black-on-yellow "${bldwht}Warning! BASHMATIC_HOME contains local modifications." "Automatic update is disabled until git state is clean again." | tee -a "${__bashmatic_auto_update_help_file}" 1>&2
    fi
}

----

==== `bashmatic.bash.exit-unless-version-four-or-later`

[source,bash]
----
bashmatic.bash.exit-unless-version-four-or-later () 
{ 
    bashmatic.bash.version-four-or-later || { 
        error "Sorry, this functionality requires BASH version 4 or later."
        exit 1 > /dev/null
    }
}

----

==== `bashmatic.bash.version`

[source,bash]
----
bashmatic.bash.version () 
{ 
    echo "${BASH_VERSION:0:1}"
}

----

==== `bashmatic.bash.version-four-or-later`

[source,bash]
----
bashmatic.bash.version-four-or-later () 
{ 
    [[ $(bashmatic.bash.version) -gt 3 ]]
}

----

==== `bashmatic.cd-into`

[source,bash]
----
bashmatic.cd-into () 
{ 
    [[ -d ${BASHMATIC_HOME} ]] || return 1
    cd "${BASHMATIC_HOME}" || exit 1
}

----

==== `bashmatic.current-os`

[source,bash]
----
bashmatic.current-os () 
{ 
    printf "%s" "${BASHMATIC_OS}"
}

----

==== `bashmatic.debug-off`

[source,bash]
----
bashmatic.debug-off () 
{ 
    unset DEBUG
    unset BASHMATIC_DEBUG
    unset BASHMATIC_PATH_DEBUG
}

----

==== `bashmatic.debug-on`

[source,bash]
----
bashmatic.debug-on () 
{ 
    export DEBUG=1
    export BASHMATIC_DEBUG=1
    export BASHMATIC_PATH_DEBUG=1
}

----

==== `bashmatic.functions`

[source,bash]
----
bashmatic.functions () 
{ 
    bashmatic.functions-from '*.sh' "$@"
}

----

==== `bashmatic.functions-from`

[source,bash]
----
bashmatic.functions-from () 
{ 
    local pattern="${1}"
    [[ -n ${pattern} ]] && shift
    [[ -z ${pattern} ]] && pattern="[a-z]*.sh"
    cd "${BASHMATIC_HOME}/lib" > /dev/null || return 1
    local screen_width=$(screen.width.actual)
    if [[ -n $(echo "${pattern}" | eval "${GrepCommand} '\*$' ") || ! ${pattern} =~ \.sh$ ]]; then
        pattern="${pattern}.sh"
    fi
    eval "${GrepCommand} '^[_a-zA-Z0-9]+.*\(\)' ${pattern}" | sedx 's/^(lib\/)?.*\.sh://g' | sedx 's/^function //g' | sedx 's/\(\) *\{.*$//g' | /usr/bin/tr -d '()' | sedx '/^ *$/d' | eval "${GrepCommand} '^(_|\.)' -v" | sort | uniq | columnize "$@"
    cd - > /dev/null || return 1
}

----

==== `bashmatic.functions.output`

[source,bash]
----
bashmatic.functions.output () 
{ 
    bashmatic.functions-from 'output.sh' "$@"
}

----

==== `bashmatic.functions.runtime`

[source,bash]
----
bashmatic.functions.runtime () 
{ 
    bashmatic.functions-from 'run*.sh' "$@"
}

----

==== `bashmatic.is-developer`

[source,bash]
----
bashmatic.is-developer () 
{ 
    [[ ${BASHMATIC_DEVELOPER} -eq 1 || -f ${BASHMATIC_HOME}/.envrc.local ]]
}

----

==== `bashmatic.load-at-login`

[source,bash]
----
bashmatic.load-at-login () 
{ 
    local file="${1}"
    [[ -z ${file} ]] && file="$(user.login-shell-init-file)"
    grep -q -E 'BASHMATIC_HOME' "${file}" || { 
        { 
            echo "export BASHMATIC_HOME=\"${BASHMATIC_HOME:-"~/.bashmatic"}\""
            echo '[[ -f ${BASHMATIC_HOME}/init.sh ]] && source ${BASHMATIC_HOME}/init.sh'
            echo 'export PATH="${PATH}:${BASHMATIC_HOME}/bin"'
        } >> "${file}"
        source "${file}"
    }
}

----

==== `bashmatic.reload`

[source,bash]
----
bashmatic.reload () 
{ 
    __bashmatic.set-is-not-loaded
    [[ -f "${BASHMATIC_HOME}/.envrc.no-debug" ]] && source "${BASHMATIC_HOME}/.envrc.no-debug"
    source "${BASHMATIC_INIT}" --reload
}

----

==== `bashmatic.reload-debug`

[source,bash]
----
bashmatic.reload-debug () 
{ 
    __bashmatic.set-is-not-loaded
    source "${BASHMATIC_HOME}/.envrc.debug"
    source "${BASHMATIC_INIT}" --reload
}

----

==== `bashmatic.reset.cache`

[source,bash]
----
bashmatic.reset.cache () 
{ 
    unset load_cache
    bashmatic.bash.version-four-or-later && { 
        ${GLOBAL} -A load_cache
        load_cache=()
    }
    rm -f "${__bashmatic_library_last_sourced}"
}

----

==== `bashmatic.setup`

[source,bash]
----
bashmatic.setup () 
{ 
    [[ -z ${BashMatic__Downloader} && -n $(command -v curl) ]] && export BashMatic__Downloader="curl -fsSL --connect-timeout 5 "
    [[ -z ${BashMatic__Downloader} && -n $(command -v wget) ]] && export BashMatic__Downloader="wget -q -O --connect-timeout=5 - "
    if [[ ! -d "${BASHMATIC_LIB}" ]]; then
        .err "Unable to file BashMatic's library source folder â€” ${BASHMATIC_LIB}"
        return 1
    fi
    declare -a preload_modules=(time.sh output.sh output-utils.sh output-repeat-char.sh output-boxes.sh is.sh user.sh util.sh git.sh file.sh color.sh brew.sh)
    bashmatic.source "${preload_modules[@]}"
    bashmatic.shell-check || return 1
    bashmatic.source-dir "${BASHMATIC_LIB}"
    output.unconstrain-screen-width
    [[ -d ${BASHMATIC_HOME}/.git ]] && bashmatic.auto-update 1>&2 2> /dev/null
    return 0
}

----

==== `bashmatic.shell-check`

[source,bash]
----
bashmatic.shell-check () 
{ 
    local shell="$(user.current-shell)"
    if [[ "${shell}" =~ bash$ || "${shell}" =~ zsh$ ]]; then
        return 0
    else
        cat "${BASHMATIC_HOME}/.init.sh" 1>&2
        return 120
    fi
}

----

==== `bashmatic.source`

[source,bash]
----
bashmatic.source () 
{ 
    local __path="${BASHMATIC_LIB}"
    local file
    local total=0
    local files=0
    local last_loaded_at=0
    [[ -f ${__bashmatic_library_last_sourced} ]] && last_loaded_at=$(cat "${__bashmatic_library_last_sourced}")
    for file in "${@}"
    do
        local t1=$(millis)
        [[ "${file}" =~ "/" ]] || file="${__path}/${file}"
        bashmatic.bash.version-four-or-later && { 
            local cached_at=${load_cache[${file}]}
            cached_at=${cached_at:-0}
            local modified_at="$(file.last-modified-millis "${file}")"
            [[ ${modified_at} -le ${cached_at} && ${modified_at} -le ${last_loaded_at} ]] && { 
                is-debug && printf -- "${bldred} (cached)    ${txtgrn} â–¶ï¸Ž %s${clr}\n" "${file/\/*\//}"
                continue
            }
        }
        [[ -s "${file}" ]] || { 
            .err "Can't source file ${file} â€” fils is invalid."
            return 1
        }
        if [[ -n ${SOURCE_DEBUG} || ${DEBUG} -eq 1 ]]; then
            is-debug && printf -- "             ${txtylw} â–¶ï¸Ž %s${clr}" "${file/\/*\//}"
            source "${file}" > /dev/null
            is-debug && { 
                cursor.rewind -120
                local code=$?
                local t2=$(millis)
                local duration=$(( t2 - t1 ))
                total=$(( total + duration ))
                files=$(( files + 1 ))
            }
            bashmatic.bash.version-four-or-later && { 
                ((code)) || load_cache[${file}]=${t1}
            }
            is-debug && { 
                local color=${txtblu}
                [[ ${duration} -gt 20 ]] && color="${bldred}"
                printf "${color}${duration}ms [%3d]" "${code}"
                printf "\n"
                unset t1
                unset t2
            }
        else
            source "${file}"
        fi
    done
    bashmatic.bash.version-four-or-later && { 
        [[ ${#load_cache[@]} -gt 0 ]] && millis > "${__bashmatic_library_last_sourced}"
    }
    is-debug && printf "${files} sourced in, taking ${total}ms total.\n"
    return 0
}

----

==== `bashmatic.source-dir`

[source,bash]
----
bashmatic.source-dir () 
{ 
    local folder="${1}"
    local loaded=false
    local file
    unset files
    declare -a files
    eval "$(files.map.shell-scripts "${folder}" files)"
    if [[ ${#files[@]} -eq 0 ]]; then
        .err "No files were returned from files.map in " "\n  ${bldylw}${folder}"
        return 1
    fi
    local -a sources=()
    for file in "${files[@]}"
    do
        local n="$(basename "${file}")"
        [[ ${n:0:1} == . ]] && continue
        sources+=("${file}")
    done
    bashmatic.source "${sources[@]}"
    loaded=true
    unset files
    ${loaded} || { 
        .err "Unable to find BashMatic library folder with files:" "${BASHMATIC_LIB}"
        return 1
    }
    if [[ ${LoadedShown} -eq 0 ]]; then
        hr
        success "BashMatic was loaded! Happy Bashing :) "
        hr
        export LoadedShown=1
    fi
}

----

==== `bashmatic.version`

[source,bash]
----
bashmatic.version () 
{ 
    cat "$(dirname "${BASHMATIC_INIT}")/.version"
}

----


=== Module `brew`

==== `brew.binary`

[source,bash]
----
brew.binary () 
{ 
    brew.is-installed && command -v brew
}

----

==== `brew.cache-reset`

[source,bash]
----
brew.cache-reset () 
{ 
    if [[ "$1" == "cask" ]]; then
        rm -f "${LibBrew__CaskCacheList}"
    else
        if [[ "$2" == "package" ]]; then
            rm -f "${LibBrew__PackageCacheList}"
        else
            rm -f "${LibBrew__PackageCacheList}" "${LibBrew__CaskCacheList}"
        fi
    fi
}

----

==== `brew.cache-reset.delayed`

[source,bash]
----
brew.cache-reset.delayed () 
{ 
    ((BASH_IN_SUBSHELL)) || brew.cache-reset both
}

----

==== `brew.cask.all-installed`

[source,bash]
----
brew.cask.all-installed () 
{ 
    local -a installed_casks=($(brew.cask.list))
    for item in "$@"
    do
        array.includes "${item}" "${installed_casks[@]}" || return 1
    done
    return 0
}

----

==== `brew.cask.is-installed`

[source,bash]
----
brew.cask.is-installed () 
{ 
    if brew.cask.all-installed "$@"; then
        echo "true"
    else
        echo "false"
    fi
}

----

==== `brew.cask.list`

[source,bash]
----
brew.cask.list () 
{ 
    cache-or-command "${LibBrew__CaskCacheList}" 10 --cask -1
}

----

==== `brew.cask.tap`

[source,bash]
----
brew.cask.tap () 
{ 
    run "brew tap homebrew/cask-cask"
}

----

==== `brew.install`

[source,bash]
----
brew.install () 
{ 
    inf "Checking if a local brew command exists already ..." 1>&2
    if brew.is-installed; then
        ok:
        local brew=$(brew.binary)
        info "Excellent: an existing Homebrew Version: ${bldylw}$(${brew} --version 2> /dev/null | head -1) exists"
        run "${brew} update"
    else
        not-ok:
        info "Brew wasn't found â€” installing Homebrew, ${bldgrn}please wait..."
        hl.yellow "Please enter your SUDO password, if prompted:"
        sudo echo
        run "/bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
    fi
}

----

==== `brew.install.cask`

[source,bash]
----
brew.install.cask () 
{ 
    local cask=$1
    local force=
    local verbose=
    [[ -n "${opts_force}" ]] && force="--force"
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    local installed_app="$(osx.app.is-installed "${cask}")"
    inf "checking if cask is installed: ${bldylw}${cask}"
    brew.cask.all-installed "${cask}" && { 
        ok:
        return 0
    }
    if [[ -n "${installed_app}" && -z "${opts_force}" ]]; then
        ui.closer.ok:
        return 0
    else
        ui.closer.kind-of-ok:
        run "brew install --cask ${cask} ${force} ${verbose}"
        brew.cache-reset cask
    fi
}

----

==== `brew.install.package`

[source,bash]
----
brew.install.package () 
{ 
    local package="$1"
    local force=
    local verbose=
    local code
    [[ -n "${opts_force}" ]] && force="--force"
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    [[ -z "${opt_terse}" ]] && inf "brewing  ðŸ»   ${bldylw}${package}..."
    if brew.package.all-installed "${package}"; then
        [[ -z "${opt_terse}" ]] && ok:
        [[ -z "${opt_terse}" ]] || printf "${bldgrn}â—‹ "
        export LibRun__LastExitCode=0
    else
        if [[ -z "${opt_terse}" ]]; then
            ui.closer.kind-of-ok:
            run "brew install ${force} ${verbose} ${package}"
            code="${LibRun__LastExitCode}"
        else
            brew install ${force} ${verbose} "${package}" > /dev/null 2>&1
            code=$?
        fi
        brew.cache-reset package
        brew.package.all-installed "${package}" && code=0
        [[ -n ${force} ]] && { 
            run.set-next continue-on-error
            run "brew link --force --overwrite ${verbose} ${package}"
        }
        hash -r > /dev/null
        ((code)) && { 
            warning "Reinstalling ${package} as I couldn't find it after instal..."
            brew.reinstall.package "${package}"
        }
        export LibRun__LastExitCode=0
        if [[ "$(brew.package.is-installed "${package}")" == "true" ]]; then
            [[ -n "${opt_terse}" ]] && printf "\n ðŸŸ¢ "
        else
            [[ -n "${opt_terse}" ]] && printf "\n ðŸ”´ "
            export LibRun__LastExitCode=1
        fi
    fi
    return ${LibRun__LastExitCode}
}

----

==== `brew.install.packages`

[source,bash]
----
brew.install.packages () 
{ 
    local force=
    [[ -n "${opts_force}" ]] && force="--force"
    for package in "$@"
    do
        brew.install.package "${package}"
    done
}

----

==== `brew.is-installed`

[source,bash]
----
brew.is-installed () 
{ 
    command -v brew 2>&1 > /dev/null && return 0
    return 1
}

----

==== `brew.package.all-installed`

[source,bash]
----
brew.package.all-installed () 
{ 
    local -a installed_packages=($(brew.package.list))
    for item in "$@"
    do
        array.includes "${item}" "${installed_packages[@]}" || return 1
    done
    return 0
}

----

==== `brew.package.available-versions`

[source,bash]
----
brew.package.available-versions () 
{ 
    local package="$1"
    [[ -z "$1" ]] && return 1
    brew search "${package}@" | tr -d 'a-z@A-Z =>-+' | sed '/^$/d' | sort -nr | tr '\n' ' '
}

----

==== `brew.package.is-installed`

[source,bash]
----
brew.package.is-installed () 
{ 
    if brew.package.all-installed "$@"; then
        echo "true"
    else
        echo "false"
    fi
}

----

==== `brew.package.link`

[source,bash]
----
brew.package.link () 
{ 
    local package="${1}"
    shift
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    run "brew link --force --overwrite ${verbose} ${package} $*"
}

----

==== `brew.package.list`

[source,bash]
----
brew.package.list () 
{ 
    cache-or-command "${LibBrew__PackageCacheList}" 10 --formula -1
}

----

==== `brew.reinstall.package`

[source,bash]
----
brew.reinstall.package () 
{ 
    local package="${1}"
    local force=
    local verbose=
    [[ -n "${opts_force}" ]] && force="--force"
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    run "brew unlink --quiet ${package}"
    run "brew uninstall ${force} ${verbose} ${package}"
    brew.install.package "${package}"
}

----

==== `brew.reinstall.packages`

[source,bash]
----
brew.reinstall.packages () 
{ 
    local force=
    local result=0
    [[ -n "${opts_force}" ]] && force="--force"
    for package in "$@"
    do
        brew.uninstall.package "${package}"
        brew.install.package "${package}"
        local result=$?
    done
    return ${result}
}

----

==== `brew.relink`

[source,bash]
----
brew.relink () 
{ 
    local package"${1}"
    local verbose=
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    run "brew unlink --quiet ${package}"
    run "brew link --force --overwrite ${verbose} ${package}"
}

----

==== `brew.service.down`

[source,bash]
----
brew.service.down () 
{ 
    local svc="$1"
    run "brew services stop ${svc}"
}

----

==== `brew.service.restart`

[source,bash]
----
brew.service.restart () 
{ 
    local svc="$1"
    run "brew services restart ${svc}"
}

----

==== `brew.service.up`

[source,bash]
----
brew.service.up () 
{ 
    local svc="$1"
    run "brew services start ${svc}"
}

----

==== `brew.setup`

[source,bash]
----
brew.setup () 
{ 
    brew.upgrade
}

----

==== `brew.uninstall`

[source,bash]
----
brew.uninstall () 
{ 
    run.set-next show-output-on
    run "$(brew.binary) install --cask uninstallpkg"
}

----

==== `brew.uninstall.package`

[source,bash]
----
brew.uninstall.package () 
{ 
    local package=$1
    local force=
    local verbose=
    [[ -n "${opts_force}" ]] && force="--force"
    [[ -n "${opts_verbose}" ]] && verbose="--verbose"
    run.set-next continue-on-error
    run "brew unlink ${package} ${force} ${verbose}"
    run.set-next continue-on-error
    run "brew uninstall ${package} ${force} ${verbose}"
    brew.cache-reset.delayed
}

----

==== `brew.uninstall.packages`

[source,bash]
----
brew.uninstall.packages () 
{ 
    local force=
    [[ -n "${opts_force}" ]] && force="--force"
    for package in "$@"
    do
        brew.uninstall.package "${package}"
    done
}

----

==== `brew.upgrade`

[source,bash]
----
brew.upgrade () 
{ 
    brew.is-installed || brew.install
    local brew_cmd=$(command -v brew 2> /dev/null)
    if [[ -z ${brew_cmd} ]]; then
        warn "brew is not installed...., brew_command is blank..."
        return 1
    fi
    run "${brew_cmd} update --force"
    run "${brew_cmd} upgrade"
    run "${brew_cmd} cleanup -s"
}

----

==== `brew.upgrade.packages`

[source,bash]
----
brew.upgrade.packages () 
{ 
    brew.is-installed || brew.install
    [[ -z $1 ]] && { 
        error "usage: brew.upgrade.packages package1 package2 ..."
        return 1
    }
    run "brew upgrade $*"
}

----

==== `cache-or-command`

[source,bash]
----
cache-or-command () 
{ 
    local file="$1"
    shift
    local stale_minutes="$1"
    shift
    if file.exists-and-newer-than "${file}" "${stale_minutes}"; then
        if [[ -s "${file}" ]]; then
            cat "${file}"
            return 0
        fi
    fi
    is-dbg && info "REFRESHING CACHE with command: ${bldylw}brew list ${*} >${file}"
    brew list "$@" > "${file}"
    cat "${file}"
}

----

==== `package.install`

[source,bash]
----
package.install () 
{ 
    brew.install.packages "$@"
    hash -r 2> /dev/null
}

----

==== `package.is-installed`

[source,bash]
----
package.is-installed () 
{ 
    [[ "$(brew.package.is-installed "$@")" == "true" ]]
}

----

==== `package.uninstall`

[source,bash]
----
package.uninstall () 
{ 
    brew.uninstall.packages "$@"
}

----


=== Module `caller`

==== `caller.stack`

[source,bash]
----
caller.stack () 
{ 
    local index=${1:-"-1"}
    while true; do
        index=$((index + 1))
        caller ${index} 2>&1 > /dev/null || break
        local -a frame=($(caller ${index} | tr ' ' '\n'))
        printf "%3d [ %-40.40s ]: %s\n" ${index} "${frame[2]}:${frame[0]}" "${frame[1]}"
    done
}

----

==== `stack.frame`

[source,bash]
----
stack.frame () 
{ 
    caller.stack 0
}

----


=== Module `color`

==== `bold`

[source,bash]
----
bold () 
{ 
    .ansi 1 "$@"
}

----

==== `color.current-background`

[source,bash]
----
color.current-background () 
{ 
    printf "\e]11;?\a"
}

----

==== `color.disable`

[source,bash]
----
color.disable () 
{ 
    export clr='\e[0m'
    unset txtblk
    unset txtred
    unset txtgrn
    unset txtylw
    unset txtblu
    unset txtpur
    unset txtcyn
    unset txtwht
    unset bldblk
    unset bldred
    unset bldgrn
    unset bldylw
    unset bldblu
    unset bldpur
    unset bldcyn
    unset bldwht
    unset unkblk
    unset undred
    unset undgrn
    unset undylw
    unset undblu
    unset undpur
    unset undcyn
    unset undwht
    unset bakblk
    unset bakred
    unset bakgrn
    unset bakylw
    unset bakblu
    unset bakpur
    unset bakcyn
    unset bakwht
    unset txtrst
    unset italic
    unset bold
    unset strikethrough
    unset underlined
    unset white_on_orange
    unset white_on_yellow
    unset white_on_red
    unset white_on_pink
    unset white_on_salmon
    unset yellow_on_gray
    unset bg_blood
    unset bg_blue_on_gray
    unset bg_bright_green
    unset bg_dark_green
    unset bg_bright_red
    unset bg_deep_blue
    unset bg_deep_green
    unset bg_green_on_gray
    unset bg_grey
    unset bg_mustard
    unset bg_pink
    unset bg_sky_blue
    unset bg_yellow_on_gray
    unset fg_dark_red
    unset fg_bright_green
    unset fg_sky_blue
    unset fg_deep_green
    unset fg_doll
    unset fg_grey
    unset fg_light_green
    unset fg_mustard
    unset fg_mustard
    unset fg_pink
    unset fg_purr
    export BashMatic__ColorLoaded=0
}

----

==== `color.enable`

[source,bash]
----
color.enable () 
{ 
    export BashMatic__ColorLoaded=1
    export txtblk='\e[0;30m'
    export txtred='\e[0;31m'
    export txtgrn='\e[0;32m'
    export txtylw='\e[0;33m'
    export txtblu='\e[0;34m'
    export txtpur='\e[0;35m'
    export txtcyn='\e[0;36m'
    export txtwht='\e[0;37m'
    export bldblk='\e[1;30m'
    export bldred='\e[1;31m'
    export bldgrn='\e[1;32m'
    export bldylw='\e[1;33m'
    export bldblu='\e[1;34m'
    export bldpur='\e[1;35m'
    export bldcyn='\e[1;36m'
    export bldwht='\e[1;37m'
    export unkblk='\e[4;30m'
    export undred='\e[4;31m'
    export undgrn='\e[4;32m'
    export undylw='\e[4;33m'
    export undblu='\e[4;34m'
    export undpur='\e[4;35m'
    export undcyn='\e[4;36m'
    export undwht='\e[4;37m'
    export bakblk='\e[40m'
    export bakred='\e[41m'
    export bakgrn='\e[42m'
    export bakylw='\e[43m'
    export bakblu='\e[44m'
    export bakpur='\e[45m'
    export bakcyn='\e[46m'
    export bakwht='\e[47m'
    export txtrst='\e[0m'
    export rst='\e[0m'
    export clr='\e[0m'
    export bold='\e[1m'
    export italic='\e[3m'
    export underlined='\e[4m'
    export strikethrough='\e[9m'
    export inverse_on='\e[7m'
    export inverse_off='\e[27m'
    export default_bg='\e[49m'
    export default_fg='\e[39m'
    export black_on_orange="\e[48;5;208m\e[48;30;208m"
    export black_on_yellow="\e[48;5;11m\e[48;30;209m"
    export white_on_orange="\e[48;5;208m"
    export white_on_yellow="\e[48;5;214m"
    export white_on_red="\e[48;5;9m"
    export white_on_pink="\e[48;5;199m"
    export white_on_salmon="\e[48;5;196m"
    export yellow_on_gray="\e[38;5;220m\e[48;5;242m"
    export bg_blood="\e[41m"
    export bg_blue_on_gray="\e[90;7;42m"
    export bg_bright_green="\e[48;5;82m"
    export bg_dark_green="\e[48;5;82m"
    export bg_bright_red="\e[1;31m\e[48;5;196m"
    export bg_deep_blue="\e[48;5;37m"
    export bg_deep_green="\e[48;5;28m"
    export bg_green_on_gray="\e[90;7;102m"
    export bg_grey="\e[48;5;239m"
    export bg_mustard="\e[48;5;178m"
    export bg_pink="\e[48;5;89m"
    export bg_sky_blue="\e[48;5;39m"
    export bg_yellow_on_gray="\e[90;7;43m"
    export fg_dark_red="\e[38;5;88m"
    export fg_bright_green="\e[38;5;82m"
    export fg_sky_blue="\e[38;5;39m"
    export fg_deep_green="\e[38;5;28m"
    export fg_doll="\e[38;5;183m"
    export fg_grey="\e[38;5;239m"
    export fg_light_green="\e[38;5;108m"
    export fg_mustard="\e[38;5;178m"
    export fg_mustard="\e[38;5;178m"
    export fg_pink="\e[38;5;89m"
    export fg_purr="\e[38;5;219m"
    export BashMatic__ColorLoaded=1
    export bg_blood="\e[41m"
    export bg_blue_on_gray="\e[90;7;42m"
    export bg_bright_green="\e[48;5;82m"
    export bg_dark_green="\e[48;5;82m"
    export bg_bright_red="\e[1;31m\e[48;5;196m"
    export bg_deep_blue="\e[48;5;37m"
    export bg_deep_green="\e[48;5;28m"
    export bg_green_on_gray="\e[90;7;102m"
    export bg_grey="\e[48;5;239m"
    export bg_mustard="\e[48;5;178m"
    export bg_pink="\e[48;5;89m"
    export bg_sky_blue="\e[48;5;39m"
    export bg_yellow_on_gray="\e[90;7;43m"
    export fg_dark_red="\e[38;5;88m"
    export fg_bright_green="\e[38;5;82m"
    export fg_sky_blue="\e[38;5;39m"
    export fg_deep_green="\e[38;5;28m"
    export fg_doll="\e[38;5;183m"
    export fg_grey="\e[38;5;239m"
    export fg_light_green="\e[38;5;108m"
    export fg_mustard="\e[38;5;178m"
    export fg_mustard="\e[38;5;178m"
    export fg_pink="\e[38;5;89m"
    export fg_purr="\e[38;5;219m"
}

----

==== `error-text`

[source,bash]
----
error-text () 
{ 
    printf "${txtred}"
}

----

==== `italic`

[source,bash]
----
italic () 
{ 
    .ansi 3 "$@"
}

----

==== `red`

[source,bash]
----
red () 
{ 
    .ansi 31 "$@"
}

----

==== `reset-color`

[source,bash]
----
reset-color () 
{ 
    echo -en "${clr}"
}

----

==== `strikethrough`

[source,bash]
----
strikethrough () 
{ 
    .ansi 9 "$@"
}

----

==== `txt-err`

[source,bash]
----
txt-err () 
{ 
    printf "${clr}${bldylw}${bakred}"
}

----

==== `txt-info`

[source,bash]
----
txt-info () 
{ 
    printf "${clr}${txtblu}"
}

----

==== `txt-warn`

[source,bash]
----
txt-warn () 
{ 
    printf "${clr}${bldylw}"
}

----

==== `underline`

[source,bash]
----
underline () 
{ 
    .ansi 4 "$@"
}

----


=== Module `config`

==== `config.dig`

[source,bash]
----
config.dig () 
{ 
    local key="$1"
    local subkey="$2"
    local format="$(config.get-format)"
    local format_lower="$(config.get-format | tr '[:upper:]' '[:lower:]')"
    local rf="require '${format_lower}'; "
    local load_config="${rf}; def config; ${format}.load(File.read('${bashmatic__config_file}')); end"
    local interpreter="$(command -v ruby)"
    local script
    if [[ -z ${key} ]]; then
        script="${load_config}; ${rf} pp config"
    else
        if [[ -n ${subkey} ]]; then
            script="${load_config}; ${rf} puts config['${key}']['${subkey}']"
        else
            script="${load_config}; ${rf} pp config['${key}']"
        fi
    fi
    ${interpreter} -e "${script}" || { 
        error "ERROR while evaluating the following script with ruby $(ruby --version):" "${script}"
        return 1
    }
    return 0
}

----

==== `config.dig.pretty`

[source,bash]
----
config.dig.pretty () 
{ 
    local -a args
    local -a keys
    for a in "$@"
    do
        if [[ $a =~ ^- ]]; then
            args+=("$a")
        else
            keys+=("$a")
        fi
    done
    is-dbg && { 
        dbg "args: ${args[*]}"
        dbg "keys: ${keys[*]}"
    }
    local format=$(config.get-format)
    config.set-format JSON
    command -v jq > /dev/null || package.install.packages jq
    config.dig "${keys[@]}" | jq "${args[@]}" | tr -d '"'
    config.set-format "${format}"
    return 0
}

----

==== `config.get-file`

[source,bash]
----
config.get-file () 
{ 
    printf "%s" "${bashmatic__config_file}"
}

----

==== `config.get-format`

[source,bash]
----
config.get-format () 
{ 
    echo -n "${bashmatic__config_format}"
}

----

==== `config.set-file`

[source,bash]
----
config.set-file () 
{ 
    export bashmatic__config_file="$1"
    if [[ ${bashmatic__config_file} =~ \.yml$ || ${bashmatic__config_file} =~ \.yaml$ || ${bashmatic__config_file} =~ \.YML$ || ${bashmatic__config_file} =~ \.YAML$ ]]; then
        config.set-format yaml
    else
        if [[ ${bashmatic__config_file} =~ \.json$ || ${bashmatic__config_file} =~ \.JSON$ ]]; then
            config.set-format json
        else
            warning "File extension is not recognized." "Use config.set-format [json|yaml]" 1>&2
        fi
    fi
}

----

==== `config.set-format`

[source,bash]
----
config.set-format () 
{ 
    local format="${1^^}"
    if [[ "${format}" == "YAML" || "${format}" == "JSON" ]]; then
        export bashmatic__config_format="${format}"
    else
        error "Invalid format $1: only YAML or JSON is supported."
        return 1
    fi
}

----


=== Module `db`

==== `db.actions.connect`

[source,bash]
----
db.actions.connect () 
{ 
    db.psql.connect "$@"
}

----

==== `db.actions.connections`

[source,bash]
----
db.actions.connections () 
{ 
    db.config.connections
    echo
}

----

==== `db.actions.csv`

[source,bash]
----
db.actions.csv () 
{ 
    local dbname=${1}
    shift
    [[ -z ${dbname} ]] && return 1
    export flag_quiet=1
    db.psql.connect "${dbname}" -P border=0 -P fieldsep="," --csv -A -X -P pager=off -P footer=off -c "\"$*\""
}

----

==== `db.actions.data-dir`

[source,bash]
----
db.actions.data-dir () 
{ 
    db.psql.connect "$@" $(db.psql.args-data-only) -c "'show data_directory'"
}

----

==== `db.actions.db-settings-pretty`

[source,bash]
----
db.actions.db-settings-pretty () 
{ 
    db.psql.connect.db-settings-pretty "$@"
}

----

==== `db.actions.db-settings-toml`

[source,bash]
----
db.actions.db-settings-toml () 
{ 
    db.psql.connect.db-settings-toml "$@"
}

----

==== `db.actions.explain`

[source,bash]
----
db.actions.explain () 
{ 
    db.psql.explain "$@"
}

----

==== `db.actions.explain-analyze-json`

[source,bash]
----
db.actions.explain-analyze-json () 
{ 
    export _bashmatic_db_explain="${_bashmatic_db_explain_sql}"
    .db.actions.explain "$@"
}

----

==== `db.actions.explain-json`

[source,bash]
----
db.actions.explain-json () 
{ 
    export _bashmatic_db_explain="${_bashmatic_db_analyze_sql}"
    .db.actions.explain "$@"
}

----

==== `db.actions.list-indexes`

[source,bash]
----
db.actions.list-indexes () 
{ 
    db.psql.list-indexes "$@"
}

----

==== `db.actions.list-tables`

[source,bash]
----
db.actions.list-tables () 
{ 
    db.psql.list-tables "$@"
}

----

==== `db.actions.list-users`

[source,bash]
----
db.actions.list-users () 
{ 
    db.psql.list-users "$@"
}

----

==== `db.actions.pga`

[source,bash]
----
db.actions.pga () 
{ 
    local name="$1"
    command -v python3 > /dev/null || brew.install.packages python3
    command -v pg_activity > /dev/null || run "python3 -m pip install pg_activity psycopg2-binary"
    command -v pg_activity > /dev/null || { 
        local binary=$(find /usr/local/Cellar -type f -name 'pg_activity')
        run "ln -nfs ${binary} /usr/local/bin/pg_activity"
    }
    command -v pg_activity > /dev/null || { 
        error "Can't find pg_activity even after install + symlink".
        return 1
    }
    local args=$(db.psql.args.config "${name}")
    db.psql.args.config "${name}" > /dev/null
    pg_activity "${args}" --verbose-mode=1 --rds --no-app --no-database --no-user
}

----

==== `db.actions.run`

[source,bash]
----
db.actions.run () 
{ 
    db.psql.run "$@"
}

----

==== `db.actions.run-multiple`

[source,bash]
----
db.actions.run-multiple () 
{ 
    db.psql.run-multiple "$@"
}

----

==== `db.actions.set-max-query-len`

[source,bash]
----
db.actions.set-max-query-len () 
{ 
    db.config.set-max-query-len "$@"
}

----

==== `db.actions.table-locks`

[source,bash]
----
db.actions.table-locks () 
{ 
    db.psql.table-locks "$@"
}

----

==== `db.actions.table-locks-query`

[source,bash]
----
db.actions.table-locks-query () 
{ 
    db.psql.table-locks-query "$@"
}

----

==== `db.actions.table-settings-set`

[source,bash]
----
db.actions.table-settings-set () 
{ 
    db.psql.connect.table-settings-set "$@"
}

----

==== `db.actions.table-settings-show`

[source,bash]
----
db.actions.table-settings-show () 
{ 
    db.psql.connect.table-settings-show "$@"
}

----

==== `db.actions.top`

[source,bash]
----
db.actions.top () 
{ 
    db.top "$@"
}

----

==== `db.config.connections`

[source,bash]
----
db.config.connections () 
{ 
    ascii-clean "$(db.config.connections-list | awk '{print $1}')"
}

----

==== `db.config.connections-list`

[source,bash]
----
db.config.connections-list () 
{ 
    [[ -f ${bashmatic_db_config} ]] || return 2
    ruby.handle-missing
    gem.install colored2 > /dev/null
    __yaml_source="${bashmatic_db_config}" ruby <<RUBY
  require 'yaml'
  require 'colored2'
  h = YAML.load(File.read(ENV['__yaml_source']))
  h.each_pair do |name, params|
    printf "%50s â†’ %s@%s/%s\n",
      name.bold.yellow,
      params['username'].blue,
      params['host'].green,
      params['database'].cyan
  end
RUBY

}

----

==== `db.config.get-file`

[source,bash]
----
db.config.get-file () 
{ 
    echo "${bashmatic_db_config}"
}

----

==== `db.config.init`

[source,bash]
----
db.config.init () 
{ 
    export bashmatic_db_connection=(host database username password)
}

----

==== `db.config.init-max-query-len`

[source,bash]
----
db.config.init-max-query-len () 
{ 
    local w=$(screen.width.actual)
    local max_query_len
    max_query_len=$(( w - 20 ))
    max_query_len=$(array.force-range "${max_query_len}" 80 1000)
    ((flag_verbose)) && { 
        attention "Queries will be truncated to ${max_query_len} characters" 1>&2
    }
    printf "%d" "${max_query_len}"
}

----

==== `db.config.parse`

[source,bash]
----
db.config.parse () 
{ 
    local db="$1"
    [[ -z ${db} ]] && return 1
    [[ -f ${bashmatic_db_config} ]] || return 2
    db.config.init
    local -a script=("require 'yaml'; h = YAML.load(STDIN); ")
    for field in "${bashmatic_db_connection[@]}"
    do
        script+=("h.key?('${db}') && h['${db}'].key?('${field}') ? print(h['${db}']['${field}']) : print('null'); print ' '; ")
    done
    is.a-function ruby.handle-missing || source "${BASHMATIC_LIB}/ruby.sh"
    ruby.handle-missing
    ruby -e "${script[*]}" < "${bashmatic_db_config}"
}

----

==== `db.config.set-file`

[source,bash]
----
db.config.set-file () 
{ 
    [[ -s "$1" ]] || return 1
    export bashmatic_db_config="$1"
}

----

==== `db.datetime`

[source,bash]
----
db.datetime () 
{ 
    date '+%Y%m%d-%H%M%S'
}

----

==== `db.pg.local.num-procs`

[source,bash]
----
db.pg.local.num-procs () 
{ 
    /bin/ps -ef | /bin/grep "[p]ostgres" | wc -l | awk '{print $1}'
}

----

==== `db.postgres.version`

[source,bash]
----
db.postgres.version () 
{ 
    command -v postgres > /dev/null || return 1
    postgres --version | sed -E 's/[^0-9.]//g'
}

----

==== `db.psql.args`

[source,bash]
----
db.psql.args () 
{ 
    if [[ -z "${bashmatic_db_database}" || -z "${bashmatic_db_host}" ]]; then
        if [[ -n "$1" ]]; then
            db.psql.args.config "$1"
        else
            error "Unable to determine DB connection parameters"
            return 1
        fi
    else
        export PGPASSWORD="${bashmatic_db_password}"
        printf -- "-U ${bashmatic_db_username} -h ${bashmatic_db_host} ${bashmatic_db_database}"
    fi
}

----

==== `db.psql.args-data-only`

[source,bash]
----
db.psql.args-data-only () 
{ 
    printf -- "%s" "-t --no-align --pset footer -q -X --tuples-only"
}

----

==== `db.psql.args.config`

[source,bash]
----
db.psql.args.config () 
{ 
    local output="$(db.config.parse "$1")"
    local -a params
    [[ -z ${output} || "${output}" =~ "null" ]] && { 
        section.red 65 "Unknown database connection â€” ${bldylw}$1." 1>&2
        info "The following are connections defined in ${bldylw}${bashmatic_db_config/${HOME}/\~}:\n" 1>&2
        for c in $(db.config.connections)
        do
            info " â€¢ ${c}" 1>&2
        done
        echo 1>&2
        exit 1
    }
    params=($(db.config.parse "$1"))
    local dbhost
    local dbname
    local dbuser
    local dbpass
    dbhost=${params[0]}
    dbname=${params[1]}
    dbuser=${params[2]}
    dbpass=${params[3]}
    export PGPASSWORD="${dbpass}"
    printf -- "-U ${dbuser} -h ${dbhost} -d ${dbname}"
}

----

==== `db.psql.args.localhost`

[source,bash]
----
db.psql.args.localhost () 
{ 
    printf -- "-U postgres -h localhost $*"
}

----

==== `db.psql.args.maintenance`

[source,bash]
----
db.psql.args.maintenance () 
{ 
    db.psql.args.localhost "--maintenance-db=postgres $*"
}

----

==== `db.psql.connect`

[source,bash]
----
db.psql.connect () 
{ 
    local dbname="$1"
    shift
    if [[ -z ${dbname} ]]; then
        h1 "USAGE: db.connect connection-name" "WHERE: connection-name is defined by your ${bldylw}${bashmatic_db_config}${clr} file." 1>&2
        return 0
    fi
    export __psql_stderr="$(file.temp)"
    cp /dev/null "${__psql_stderr}"
    local tempfile=$(mktemp)
    db.psql.args.config "${dbname}" > "${tempfile}"
    local -a args=($(cat "${tempfile}"))
    [[ -n "${psql_extra_args[*]}" ]] && args+=("${psql_extra_args[@]}")
    rm -f "${tempfile}" > /dev/null
    [[ ${flag_quiet} -eq 0 ]] && { 
        printf "${txtpur}export PGPASSWORD=[reducted]${clr}\n" 1>&2
        printf "${txtylw}$(which psql) ${args[*]}${clr}\n" 1>&2
        ( hr
        echo ) 1>&2
    }
    set +e
    is-verbose && echo
    if [[ ${action} == "run" ]]; then
        print-cli "psql ${args[*]} --echo-errors $*"
        psql "${args[@]}" --echo-errors "$@" 2> "${__psql_stderr}"
        local code=$?
        [[ ${code} -ne 0 || -s "${__psql_stderr}" ]] && db.psql.report-error "${args[@]}" "$@"
    else
        print-cli "psql ${args[*]} --echo-errors $*"
        eval "psql ${args[*]} --echo-errors $*"
        local code=$?
    fi
    return ${code}
}

----

==== `db.psql.connect.db-settings-pretty`

[source,bash]
----
db.psql.connect.db-settings-pretty () 
{ 
    db.psql.connect "$@" -A -X -q -c "\"show all\"" | grep -v 'rows)' | sort | awk "BEGIN{FS=\"|\"}{ printf(\"%-40.40s %-30.30s ## %s\n\", \$1, \$2, \$3) }" | sedx '/##\s*$/d' | GREP_COLOR="1;32" grep -E -C 1000 -i --color=always -e '^([^ ]*)' | GREP_COLOR="3;0;34" grep -E -C 1000 -i --color=always -e '##.*$|$'
}

----

==== `db.psql.connect.db-settings-toml`

[source,bash]
----
db.psql.connect.db-settings-toml () 
{ 
    db.psql.connect.just-data "$1" -c "\"show all\"" | awk 'BEGIN{FS="|"}{printf "%s=%s\n", $1, $2}' | sort
}

----

==== `db.psql.connect.just-data`

[source,bash]
----
db.psql.connect.just-data () 
{ 
    local dbname="$1"
    shift
    db.psql.connect "${dbname}" $(db.psql.args-data-only) "$@"
}

----

==== `db.psql.connect.table-settings-set`

[source,bash]
----
db.psql.connect.table-settings-set () 
{ 
    local dbname="$1"
    shift
    local table="$1"
    shift
    local setting="$1"
    shift
    local value="$1"
    shift
    [[ -z ${setting} || -z ${value} ]] && { 
        error "Either setting or value are not defined." 1>&2
        return 1
    }
    info "Setting ${setting} = ${value} on table ${table}...."
    db.psql.connect "${dbname}" $(db.psql.args-data-only) -c "ALTER TABLE \"${table}\" SET (${setting} = ${value});"
}

----

==== `db.psql.connect.table-settings-show`

[source,bash]
----
db.psql.connect.table-settings-show () 
{ 
    local dbname="$1"
    shift
    local table="$1"
    shift
    db.psql.connect "${dbname}" $(db.psql.args-data-only) -c "SELECT relname, reloptions FROM pg_class WHERE relname='${table}';"
}

----

==== `db.psql.db-settings`

[source,bash]
----
db.psql.db-settings () 
{ 
    psql "$*" -X -q -c "\"show all\"" | sort | awk '{ printf("%s=%s\n", $1, $3) }' | sed -E 's/[()\-]//g;/name=setting/d;/^[-+=]*$/d;/^[0-9]*=$/d'
}

----

==== `db.psql.explain`

[source,bash]
----
db.psql.explain () 
{ 
    local dbname="$1"
    shift
    db.psql.connect "${dbname}" -t -A -X --pset border=0 -c "'explain $*'"
}

----

==== `db.psql.list-indexes`

[source,bash]
----
db.psql.list-indexes () 
{ 
    local dbname="$1"
    shift
    db.psql.connect "${dbname}" $(db.psql.args-data-only) -c '\\di' | awk 'BEGIN{FS="|"}{print $2}'
}

----

==== `db.psql.list-tables`

[source,bash]
----
db.psql.list-tables () 
{ 
    local dbname="$1"
    shift
    db.psql.connect "${dbname}" $(db.psql.args-data-only) -c '\\dt' | awk 'BEGIN{FS="|"}{print $2}'
}

----

==== `db.psql.list-users`

[source,bash]
----
db.psql.list-users () 
{ 
    local dbname="$1"
    shift
    db.psql.connect "${dbname}" $(db.psql.args-data-only) -c '\\du' | awk 'BEGIN{FS="|"}{print $2}'
}

----

==== `db.psql.report-error`

[source,bash]
----
db.psql.report-error () 
{ 
    local -a argv=("$@")
    [[ -z "${__psql_stderr}" ]] && return 0
    [[ -s "${__psql_stderr}" ]] || return 0
    error "Error running command: ""${bldylw}psql ${argv[*]}"
    printf -- "${txtred}$(cat "${__psql_stderr}" | sed -E 's/^/   /g')${clr}\n"
    hr
    rm -f "${__psql_stderr}"
    unset __psql_stderr
}

----

==== `db.psql.run`

[source,bash]
----
db.psql.run () 
{ 
    local dbname="$1"
    shift
    local query="$1"
    shift
    db.psql.connect.just-data "${dbname}" -c "${query}" "@"
}

----

==== `db.psql.run-multiple`

[source,bash]
----
db.psql.run-multiple () 
{ 
    local dbname="$1"
    shift
    local commands
    for arg in "$@"
    do
        if [[ ${arg} =~ \" ]]; then
            commands="${commands} -c '$(printf "%s" "${arg}")'"
        else
            commands="${commands} -c \"$(printf "%s" "${arg}")\""
        fi
    done
    echo "${commands}" > /tmp/a
    db.psql.connect "${dbname}" -t -A -X --pset border=0 "${commands}"
}

----

==== `db.psql.table-locks`

[source,bash]
----
db.psql.table-locks () 
{ 
    local db="$1"
    shift
    local table="$1"
    shift
    local file="$(.db.locks.generate-sql "${table}")"
    db.psql.connect "${db}" "$*" -X -x --pset=pager -q -f "${file}" | GREP_COLOR=41 grep --color=always -E "(${table:-"table_name.*$"}|$)"
    [[ -f "${file}" ]] && rm -f "${file}"
}

----

==== `db.psql.table-locks-query`

[source,bash]
----
db.psql.table-locks-query () 
{ 
    local db="$1"
    shift
    local table="$1"
    shift
    local file="$(.db.locks.generate-sql "${table}")"
    printf "\n${txtgrn}"
    cat "${file}"
    printf "\n${clr}"
    [[ -f "${file}" ]] && rm -f "${file}"
}

----

==== `db.psql.version`

[source,bash]
----
db.psql.version () 
{ 
    command -v psql > /dev/null || return 1
    psql --version | sed -E 's/[^0-9.]//g'
}

----

==== `db.wait-until-db-online`

[source,bash]
----
db.wait-until-db-online () 
{ 
    local db="${1}"
    inf 'waiting for the database to come up...'
    while true; do
        out=$(psql -c "select count(*) from pg_stat_user_tables" "$(db.psql.args "${db}")" 2>&1)
        code=$?
        [[ ${code} == 0 ]] && break
        [[ ${code} == 1 ]] && break
        sleep 1
        [[ ${out} =~ 'does not exist' ]] && break
    done
    ui.closer.ok:
    return 0
}

----

==== `is-quiet`

[source,bash]
----
is-quiet () 
{ 
    ((flag_quiet))
}

----

==== `is-verbose`

[source,bash]
----
is-verbose () 
{ 
    ((flag_verbose))
}

----

==== `print-cli`

[source,bash]
----
print-cli () 
{ 
    is-verbose || return
    notice "Running command line:"
    cursor.up 2
    notice "${itablk}$*"
}

----


=== Module `db_cli`

==== `db.actions.commands`

[source,bash]
----
db.actions.commands () 
{ 
    db.commands-list
}

----

==== `db.cli-setup`

[source,bash]
----
db.cli-setup () 
{ 
    db.refresh.actions
    color.enable > /dev/null
    output.constrain-screen-width 110
    if [[ $(screen.width) -lt 110 ]]; then
        error "Please resize your terminal to have at last 110 columns."
        return 1
    fi
}

----

==== `db.commands-list`

[source,bash]
----
db.commands-list () 
{ 
    h5 "Available Commands"
    source "${BASHMATIC_LIB}/util.sh"
    db.refresh.actions
    printf "${bldgrn}"
    array.to.bullet-list "${db_actions[@]}" | sed 's/^/     /g'
    echo
    hr
    echo
    exit 0
}

----

==== `db.connections-list`

[source,bash]
----
db.connections-list () 
{ 
    h4 "Available Database Connections"
    local -a connections
    connections=($(db.actions.connections))
    printf "${bldblu}"
    array.to.bullet-list "${connections[@]}" | sed 's/^/     /g'
    echo
    hr
    echo
    exit 0
}

----

==== `db.examples`

[source,bash]
----
db.examples () 
{ 
    h2 EXAMPLES "${txtblu}${italic}# List available connection names" "${bldylw}db --connections" " " "${txtblu}${italic}# List available sub-commands" "${bldylw}db --commands" " " "${txtblu}${italic}# Connect to the database named 'staging.core' using psql" "${bldylw}db connect staging.core" " " "${txtblu}${italic}# Show 'db top' for up to 3 databases at once:" "${bldylw}db top prod.core prod.replica1 prod.replica2" " " "${txtblu}${italic}# Use 'pg_activity' to show db top for one connection:" "${bldylw}db pga prod.core" " " "${txtblu}${italic}# Show all settings currently active on production DB in TOML/ini format:" "${txtblu}${italic}# and suppress the header with -q:" "${bldylw}db db-settings-toml prod.core -q" " " "${txtblu}${italic}# Run a query with the default output" "${bldylw}db run -q prod.core 'select relname,n_live_tup from pg_stat_user_tables order by n_live_tup desc'" " " "${txtblu}${italic}# Run the same query, but this time output in a CSV format" "${txtblu}${italic}# NOTE: majority of the flags are passed to the ${bldgrn}psql${clr}${txtblu}${italic} to format the output," "${txtblu}${italic}#       except -q is consumed by the script and turns off the script header." "${txtblu}${italic}#       While -P flag is equivalent to \pset in psql session." "${bldylw}export query='select relname,n_live_tup from pg_stat_user_tables order by n_live_tup desc'" "${bldylw}db run staging.core \"\${query} limit 10\" -q -AX -P pager=0 -P fieldsep=, -P footer=off" " " "${txtblu}${italic}NOTE: read more about psql formatting options via \pset and --pset flags:" "${txtblu}${italic}      ${undgrn}https://bit.ly/psql-pset"
}

----

==== `db.main`

[source,bash]
----
db.main () 
{ 
    declare -a psql_extra_args
    export psql_extra_args=()
    [[ -z "$*" ]] && { 
        db.usage
        return
    }
    while :; do
        case $1 in 
            -h | --help)
                shift
                db.usage
                return
            ;
            -e | --examples)
                shift
                db.examples
                return
            ;
            -c | --connections)
                shift
                db.connections-list
                return
            ;
            -q | --quiet)
                shift
                export flag_quiet=1
            ;
            -v | --verbose)
                shift
                export flag_verbose=1
            ;
            -C | --commands)
                shift
                h3 "Valid actions are:" "${db_actions[@]}"
                exit 0
            ;
            -f | --filter)
                shift
                [[ "$1" =~ "%" ]] && { 
                    error "The filter expression is automatically wrapped in '%<expression>%'," "so â€” no need to add '%' yourself."
                    exit 1
                }
                export flag_filter_active="$1"
                shift
            ;
            -w | --width)
                shift
                is.numeric "$1" || { 
                    error "Argument to -w | --width must be a number, dear."
                    exit 1
                }
                export flag_width="$1"
                shift
            ;
            [a-z]*)
                [[ -n ${action} ]] && break
                export action="$1"
                shift
                array.includes "${action}" "${db_actions[@]}" || { 
                    error "Invalid Command" "${action}"
                    db.commands-list
                    return 1
                }
                export func="db.actions.${action}"
            ;
            --)
                shift
                export psql_extra_args=("$@")
                while (($#)); do
                    shift
                done
            ;
            *)
                [[ -z "$1" ]] && break
                error "Unknown flag $1 â€”â€” if it's intended for psql, please add -- before it."
                return 2
            ;
        esac
    done
    is.a-function "${func}" || { 
        error "Invalid action ${action}!"
        db.usage
        return 3
    }
    ${func} "$@"
}

----

==== `db.refresh.actions`

[source,bash]
----
db.refresh.actions () 
{ 
    export db_actions=($(util.functions-matching.diff db.actions.))
}

----

==== `db.usage`

[source,bash]
----
db.usage () 
{ 
    local config="~/$(basename $(dirname "${bashmatic_db_config}"))/$(basename "${bashmatic_db_config}")"
    usage-box "db [global flags] command [command flags] connection [-- psql flags] Â© Performs one of many supported actions against PostgreSQL" "-q / --quiet" "Suppress the colorful header messages" "-v / --verbose" "Show additional output" "-n / --dry-run" "Only print commands, but do not run them" "â”œGLOBAL FLAGS:" " " "-w / --width WIDTH" "Use specified screen width instead of automatic." "-f / --filter REGEX" "Defaults to 'idle', but can be set" " " "to remove some active queries from the view." "-C / --commands" "List all sub-commands to the db script" "-c / --connections" "List all available database connections" "-e / --examples" "Show script usage examples" "-h / --help" "Show this help screen" " " " " "â”œSUMMARY:" " " " " "This tool uses a list of database connections defined in the" " " "YAML file that must be installed at: ${bldylw}${config}" " " " "
}

----


=== Module `db_rails`

==== `db.rails.schema.checksum`

[source,bash]
----
db.rails.schema.checksum () 
{ 
    if [[ -d db/migrate ]]; then
        find db/migrate -type f -ls | awk '{printf("%10d-%s\n",$7,$11)}' | sort | shasum | awk '{print $1}'
    else
        local schema=$(db.rails.schema.file)
        [[ -s ${schema} ]] || error "can not find Rails schema in either ${RAILS_SCHEMA_RB} or ${RAILS_SCHEMA_SQL}"
        [[ -s ${schema} ]] && shasum.sha-only "${schema}"
    fi
}

----

==== `db.rails.schema.file`

[source,bash]
----
db.rails.schema.file () 
{ 
    if [[ -f "${RAILS_SCHEMA_RB}" && -f "${RAILS_SCHEMA_SQL}" ]]; then
        if [[ "${RAILS_SCHEMA_RB}" -nt "${RAILS_SCHEMA_SQL}" ]]; then
            printf "${RAILS_SCHEMA_RB}"
        else
            printf "${RAILS_SCHEMA_SQL}"
        fi
    else
        if [[ -f "${RAILS_SCHEMA_RB}" ]]; then
            printf "${RAILS_SCHEMA_RB}"
        else
            if [[ -f "${RAILS_SCHEMA_SQL}" ]]; then
                printf "${RAILS_SCHEMA_SQL}"
            fi
        fi
    fi
}

----


=== Module `db_top`

==== `db.top`

[source,bash]
----
db.top () 
{ 
    local dbname
    local width_min=90
    local height_min=30
    local width=$(screen.width)
    local height=$(screen.height)
    if [[ "$1" == "-l" || "$1" == "--list" ]]; then
        db.config.connections
        echo
        return
    fi
    output.unconstrain-screen-width
    if [[ ${width} -lt ${width_min} || ${height} -lt ${height_min} ]]; then
        error "Your screen is too small for db.top."
        info "Minimum required screen dimensions are ${width_min} columns, ${height_min} rows."
        info "Your screen is ${bldred}${width}x${height}."
        return
    fi
    local -a connections_arguments
    local -a connections_names
    local -a connections_passwords
    local code=0
    local i=0
    local arguments
    local tof="$(mktemp -d "${TMPDIR:-/tmp/}.XXXXXXXXXXXX")/.db.top.$$"
    cp /dev/null "${tof}" > /dev/null
    for connection in "$@"
    do
        db.psql.args.config "${connection}" > /dev/null || return 1
        db.psql.args "${connection}" > "${tof}"
        arguments="$(cat "${tof}" | tr -d '\n')"
        connections_arguments+=("${arguments}")
        connections_names+=("${connection}")
        connections_passwords+=("${PGPASSWORD}")
        i=$((i + 1))
    done
    if [[ ${#connections_names[@]} -eq 0 ]]; then
        h1 "${bldgrn}USAGE: db.top db1 db2 ... " "   EG: db.top prod-master prod-replica1 prod-replica2"
        return 1
    fi
    ((BASH_IN_SUBSHELL)) && { 
        trap "clear" TERM
        trap "clear" EXIT
    }
    local interval=${bashmatic_db_top_refresh:-1}
    local num_dbs=${#connections_names[@]}
    h1 "Refreshing activity for ${num_dbs} databases..."
    while true; do
        local index=0
        rm -f "${tof}.errors"
        cp /dev/null "${tof}"
        local screen_height=$(screen.height)
        for dbname in "${connections_names[@]}"
        do
            local percent_total_height
            local percent_total_height_next
            percent_total_height=$(.db.top.vertical-offset "${num_dbs}" ${index})
            percent_total_height_next=$(.db.top.vertical-offset "${num_dbs}" $((index + 1)))
            local vertical_shift=$((percent_total_height * screen_height / 100))
            local vertical_shift_next=$((percent_total_height_next * screen_height / 100))
            local height=$((vertical_shift_next - vertical_shift - 7))
            cursor.at.y ${vertical_shift} >> "${tof}"
            [[ -n ${BASHMATIC_DEBUG} ]] && { 
                .output.set-indent 0
                info "CURRENT â¯${bldylw} % = ${percent_total_height}, %++ = ${percent_total_height_next}" >> "${tof}"
                h1 -- "Database: ${dbname}" "PSQL arguments:" "${connections_arguments[${index}]}" >> "${tof}"
            }
            .db.top.connection "${tof}" "${dbname}" "${connections_passwords[${index}]}" "${height}" "${connections_arguments[${index}]}"
            index=$((index + 1))
        done
        clear
        if [[ -s "${tof}.errors" ]]; then
            error "ERROR running psql with args: ${bldylw}${connections_arguments[${index}]}"
            printf "${bldred}"
            cat "${tof}.errors"
            printf "${clr}\n"
            h3 "Output:"
            cat "${tof}"
            code=111
            break
        else
            .output.set-indent 0
            hl.green "DbTopÂ© v1.1.0 Â© 2016-2022 Konstantin Gredeskoul â€¢ Â© All Rights Reserved â€¢ MIT License â€”â€” "
            cat "${tof}"
            cursor.at.y $(($(.output.screen-height) + 1))
            printf "${bldwht}Press Ctrl-C to quit.${clr}"
            code=0
        fi
        sleep "${interval}"
    done
    return ${code}
}

----

==== `db.top.set-refresh`

[source,bash]
----
db.top.set-refresh () 
{ 
    export bashmatic_db_top_refresh="$1"
}

----


=== Module `deploy`

==== `deploy.slack`

[source,bash]
----
deploy.slack () 
{ 
    local original_text="$*"
    [[ -z ${LibDeploy__SlackHookUrl} ]] && return 1
    local text=$(echo "${original_text}" | sed -E 's/"/\"/g' | sed -E "s/'/\'/g")
    local json="{\"text\": \"$text\"}"
    local slack_url="${LibDeploy__SlackHookUrl}"
    [[ ${LibRun__DryRun} -eq ${False} ]] && { 
        if ${LibDeploy__NoSlack}; then
            hl.green "${original_text}"
        else
            curl -s -d "payload=$json" "${slack_url}" > /dev/null
            if [[ $? -eq 0 ]]; then
                info: "sent to Slack: [${text}]"
            else
                warning: "error sending to Slack, is your SLACK_URL set?"
            fi
        fi
    }
    [[ ${LibRun__DryRun} -eq ${True} ]] && run "send to slack [${text}]"
}

----

==== `deploy.slack-ding`

[source,bash]
----
deploy.slack-ding () 
{ 
    deploy.slack "<!here> $@"
}

----

==== `deploy.validate-vpn`

[source,bash]
----
deploy.validate-vpn () 
{ 
    .deploy.check-vpn "$@" || .deploy.vpn-error "$@"
}

----


=== Module `dir`

==== `dir.count-slashes`

[source,bash]
----
dir.count-slashes () 
{ 
    local dir="${1}"
    echo "${dir}" | sed 's/[^/]//g' | tr -d '\n' | wc -c | tr -d ' '
}

----

==== `dir.expand-dir`

[source,bash]
----
dir.expand-dir () 
{ 
    local dir="${1}"
    if [[ "${dir:0:1}" != "/" && "${dir:0:1}" != "~" ]]; then
        dir="$(pwd)/${dir}"
    else
        if [[ "${dir:0:1}" == "~" ]]; then
            dir="${HOME}/${dir:1:1000}"
        fi
    fi
    printf -- "%s" "${dir}"
}

----

==== `dir.is-a-dir`

[source,bash]
----
dir.is-a-dir () 
{ 
    local dir="${1}"
    [[ -d "${dir}" ]]
}

----

==== `dir.rsync-to`

[source,bash]
----
dir.rsync-to () 
{ 
    local from="$1"
    shift
    local to="$1"
    shift
    [[ -d ${from} ]] || { 
        error "usage: dir.rsync-to [ from-dir ] [ enclosing-to-dir ]" "Directory ${from} does not exist."
        return 1
    }
    [[ -d ${to} ]] || { 
        error "usage: dir.rsync-to [ from-dir ] [ enclosing-to-dir ]" "Directory ${to} does not exist."
        return 1
    }
    command -v rsync > /dev/null || package.install rsync
    h3 "Starting RSync: [${from} â€”> ${to}]"
    local flags="avht"
    run.ui.ask "Do you want do delete files in ${to} that don't match files in ${from}?"
    rsync -avht "${from}" "${to}"
}

----

==== `dir.short-home`

[source,bash]
----
dir.short-home () 
{ 
    local dir="$1"
    printf -- "%s" "${dir}" | sed -E "s#${HOME}#~#g"
}

----

==== `dir.with-file`

[source,bash]
----
dir.with-file () 
{ 
    local file="$1"
    local dir="${2:-$(pwd -P)}"
    if [[ ${dir:0:1} != "/" ]]; then
        dir="$(pwd -P)/${dir}"
    fi
    local _d="${dir}"
    while true; do
        local try="${_d}/${file}"
        [[ -f "${try}" ]] && { 
            echo "${_d}"
            return 0
        }
        _d="$(dirname "${_d}")"
        if [[ "${_d}" == "/" || "${_d}" == "" ]]; then
            [[ -f "${_d}/${file}" ]] || { 
                echo "No file ${file} was found in the path." 1>&2
                return 1
            }
            echo "${_d}"
            exit 0
        fi
    done
    return 2
}

----


=== Module `docker`

==== `docker.abort-if-down`

[source,bash]
----
docker.abort-if-down () 
{ 
    local should_exit="${1:-true}"
    inf 'Checking if Docker is running...'
    docker ps 2> /dev/null > /dev/null
    code=$?
    if [[ ${code} == 0 ]]; then
        ui.closer.ok:
    else
        ui.closer.not-ok:
        error "docker ps returned ${code}, is Docker running?"
        [[ "${should_exit}" == "true" ]] && exit 127
        return 127
    fi
}

----

==== `docker.actions.build`

[source,bash]
----
docker.actions.build () 
{ 
    docker.build.container "$@"
}

----

==== `docker.actions.clean`

[source,bash]
----
docker.actions.clean () 
{ 
    .docker.exec "docker-compose rm"
}

----

==== `docker.actions.pull`

[source,bash]
----
docker.actions.pull () 
{ 
    local tag=${1:-'latest'}
    .docker.check-repo "${2}" || return 1
    .docker.exec "docker pull ${AppDockerRepo}:${tag}"
}

----

==== `docker.actions.push`

[source,bash]
----
docker.actions.push () 
{ 
    local tag=${1:-$(.docker.next-version)}
    .docker.check-repo "${2}" || return 1
    docker.actions.tag latest
    [[ -n ${tag} ]] && docker.actions.tag "${tag}"
    .docker.check-repo || return 1
    .docker.exec docker push "${AppDockerRepo}:${tag}"
    [[ ${tag} != 'latest' ]] && .docker.exec docker push "${AppDockerRepo}:latest"
}

----

==== `docker.actions.setup`

[source,bash]
----
docker.actions.setup () 
{ 
    setup.docker
    docker.pull
    docker.build
}

----

==== `docker.actions.start`

[source,bash]
----
docker.actions.start () 
{ 
    .docker.exec "docker-compose start"
}

----

==== `docker.actions.stop`

[source,bash]
----
docker.actions.stop () 
{ 
    .docker.exec "docker-compose stop"
}

----

==== `docker.actions.tag`

[source,bash]
----
docker.actions.tag () 
{ 
    local tag=${1}
    [[ -z ${tag} ]] && return 1
    .docker.check-repo "${2}" || return 1
    .docker.exec docker tag "${AppDockerRepo}" "${AppDockerRepo}:${tag}"
}

----

==== `docker.actions.up`

[source,bash]
----
docker.actions.up () 
{ 
    .docker.exec "docker-compose up"
}

----

==== `docker.actions.update`

[source,bash]
----
docker.actions.update () 
{ 
    docker.build
    docker.push
}

----

==== `docker.build.container`

[source,bash]
----
docker.build.container () 
{ 
    .docker.check-repo "${1}" || return 1
    local tag=${AppDockerRepo}
    .docker.exec "docker build -m 3G -c 4 --pull -t ${tag} . $*"
}

----

==== `docker.containers.clean`

[source,bash]
----
docker.containers.clean () 
{ 
    local -a args=("$@")
    run "docker rm $(docker ps -q -a) ${args[*]}"
}

----

==== `docker.image.inspect`

[source,bash]
----
docker.image.inspect () 
{ 
    run.set-next show-output-on
    local jq=" | jq"
    [[ -z $(command -v jq) ]] && jq=
    run "docker image inspect ${*} $jq"
}

----

==== `docker.image.rm`

[source,bash]
----
docker.image.rm () 
{ 
    run "docker image rm ${*}"
}

----

==== `docker.images-named`

[source,bash]
----
docker.images-named () 
{ 
    local name="${1}"
    local func="${2}"
    docker.abort-if-down false || return 127
    hl.subtle "Processing Docker images matching ${name} with function ${func}..."
    local images="$(docker images | grep "^${name}" | sed 's/  */ /g' | cut -d ' ' -f 3 | tr '\n' ' ')"
    ${func} "${images}"
}

----

==== `docker.images.clean`

[source,bash]
----
docker.images.clean () 
{ 
    local name=${1:-"<none>"}
    docker.images-named "${name}" "docker.image.rm"
}

----

==== `docker.images.inspect`

[source,bash]
----
docker.images.inspect () 
{ 
    local name=${1:-"<none>"}
    docker.images-named "${name}" "docker.image.inspect"
}

----

==== `docker.last-version`

[source,bash]
----
docker.last-version () 
{ 
    .docker.check-repo "${1}" || return 1
    [[ -z ${AppDockerRepo} ]] && { 
        error "usage: docker.last-version organization/reponame:version"
        return 1
    }
    .docker.last-version "$@"
}

----

==== `docker.next-version`

[source,bash]
----
docker.next-version () 
{ 
    .docker.check-repo "${1}" || return 1
    [[ -z ${AppDockerRepo} ]] && { 
        error "usage: docker.next-version [ organization/repo-name:version ]"
        return 1
    }
    .docker.next-version "$@"
}

----

==== `docker.set-repo`

[source,bash]
----
docker.set-repo () 
{ 
    [[ -n "$1" ]] && export AppDockerRepo="$1"
}

----


=== Module `dropbox`

==== `dropbox.unignore`

[source,bash]
----
dropbox.unignore () 
{ 
    local file="$(path.absolute "$1")"
    util.os
    case "${BASHMATIC_OS}" in 
        darwin)
            run "xattr -d com.dropbox.ignored \"${file}\""
        ;
        linux)
            run "attr -r com.dropbox.ignored \"${file}\""
        ;
    esac
}

----


=== Module `file`

==== `dir.find`

[source,bash]
----
dir.find () 
{ 
    find . -name "*$1*" -type d -print
}

----

==== `dir.temp`

[source,bash]
----
dir.temp () 
{ 
    local dir="$(file.temp)/$$/${RANDOM/284/_-=}"
    mkdir -p "${dir}" 2> /dev/null
    [[ -n ${BASHMATIC_DEBUG} ]] && { 
        info "temporary folder is: ${dir}"
        inf "it exists?  "
        [[ -d ${dir} ]] && ok:
        [[ -d ${dir} ]] || not-ok:
    }
    printf "%s" "${dir}"
    trap "rm -rf ${dir}" EXIT
}

----

==== `file.ask.if-exists`

[source,bash]
----
file.ask.if-exists () 
{ 
    local file="$1"
    shift
    local message="$*"
    [[ -z "${message}" ]] && message="File ${file} exists. Overwrite?"
    if [[ -f ${file} ]]; then
        run.set-next on-decline-return
        run.ui.ask "${message}" || return 1
    fi
    return 0
}

----

==== `file.count.lines`

[source,bash]
----
file.count.lines () 
{ 
    [[ -f "$1" ]] || return 1
    wc -l "$1" | awk '{print $1}' | tr -d '\n'
}

----

==== `file.count.words`

[source,bash]
----
file.count.words () 
{ 
    [[ -f "$1" ]] || return 1
    wc -w "$1" | awk '{print $1}' | tr -d '\n'
}

----

==== `file.exists-and-newer-than`

[source,bash]
----
file.exists-and-newer-than () 
{ 
    local file="${1}"
    shift
    local minutes="${1}"
    shift
    if [[ -n "$(find "${file}" -mmin -"${minutes}" -print 2> /dev/null)" ]]; then
        return 0
    else
        return 1
    fi
}

----

==== `file.extension`

[source,bash]
----
file.extension () 
{ 
    local filename="$1"
    printf "${filename##*.}"
}

----

==== `file.extension.remove`

[source,bash]
----
file.extension.remove () 
{ 
    local filename="$1"
    printf "${filename%.*}"
}

----

==== `file.extension.replace`

[source,bash]
----
file.extension.replace () 
{ 
    local ext="$1"
    shift
    [[ -z "$1" ]] && { 
        info "USAGE: file.extension.replace <new-extension> file1 file2 ... "
        return 1
    }
    ext=".$(echo "${ext}" | tr -d '.')"
    local first=true
    for file in "$@"
    do
        ${first} || printf " "
        printf "%s%s" "$(file.strip.extension "${file}")" "${ext}"
        first=false
    done
}

----

==== `file.find`

[source,bash]
----
file.find () 
{ 
    find . -name "*$1*" -type f -print
}

----

==== `file.first-is-newer-than-second`

[source,bash]
----
file.first-is-newer-than-second () 
{ 
    [[ "$1" -nt "$2" ]]
}

----

==== `file.gsub`

[source,bash]
----
file.gsub () 
{ 
    local file="$1"
    shift
    local find="$1"
    shift
    local replace="$1"
    shift
    local
    runtime_options="$*"
    [[ ! -s "${file}" || -z "${find}" || -z "${replace}" ]] && { 
        error "Invalid usage of file.sub â€” " "USAGE: file.gsub <file>    <find-regex>        <replace-regex>" "EG:    file.gsub ~/.bashrc '^export EDITOR=vi' 'export EDITOR=gvim'"
        return 1
    }
    ${GrepCommand} -q "${find}" "${file}" || return 0
    [[ -z "${runtime_options}" ]] || run.set-next "${runtime_options}"
    run "sed -i'' -E -e 's/${find}/${replace}/g' \"${file}\""
}

----

==== `file.install-with-backup`

[source,bash]
----
file.install-with-backup () 
{ 
    local source="$1"
    shift
    if [[ ! -f "${source}" ]]; then
        error "file ${source} can not be found"
        return 1
    fi
    local dest="$1"
    shift
    [[ -z ${dest} ]] && { 
        error "usage: file.install-with-backup <source> <dest> [ bak | folder ]"
        return 1
    }
    local backup_strategy="${1:-"bak"}"
    shift
    local backup_fn=".file.backup.strategy.${backup_strategy}"
    is.a-function "${backup_fn}" || { 
        error "Invalid backup method '${backup_strategy}': supported are: 'bak' and 'folder'"
        return 1
    }
    if [[ -f "${dest}" ]]; then
        if [[ -z $(diff "${dest}" "${source}" 2>&1) ]]; then
            info: "The two files ${source} and ${dest} are identical."
            return 0
        else
            if [[ ${LibFile__ForceOverwrite} -eq 1 ]]; then
                info "file ${dest} already exists, but overwrite flag was set, so overwriting."
                run.set-next show-output-on
                run "cp -v \"${source}\" \"${dest}\""
                return 0
            else
                info "creating a backup of ${dest}..."
                ${backup_fn} "${dest}" && { 
                    success "File ${dest} has been backed up."
                }
            fi
        fi
    fi
    run "mkdir -p $(dirname "${dest}")"
    run.set-next show-output-on
    run "cp -v ${source} ${dest}"
}

----

==== `file.last-modified-date`

[source,bash]
----
file.last-modified-date () 
{ 
    stat -f "%Sm" -t "%Y-%m-%d" "$1"
}

----

==== `file.last-modified-millis`

[source,bash]
----
file.last-modified-millis () 
{ 
    echo -n "$(/usr/bin/stat -f %m "$1")000"
}

----

==== `file.last-modified-year`

[source,bash]
----
file.last-modified-year () 
{ 
    stat -f "%Sm" -t "%Y" "$1"
}

----

==== `file.list.filter-existing`

[source,bash]
----
file.list.filter-existing () 
{ 
    for file in "$@"
    do
        [[ -f "${file}" ]] && echo "${file}"
    done
}

----

==== `file.list.filter-non-empty`

[source,bash]
----
file.list.filter-non-empty () 
{ 
    for file in "$@"
    do
        [[ -s "${file}" ]] && echo "${file}"
    done
}

----

==== `file.normalize-files`

[source,bash]
----
file.normalize-files () 
{ 
    trap 'return 1' INT
    run.set-all abort-on-error
    local file
    local counter=0
    for file in "$@"
    do
        [[ -f "${file}" ]] || { 
            error "File '${file}' does not exist, continue."
            continue
        }
        local new_name="$(file.print-normalized-name "${file}")"
        [[ "${file}" == "${new_name}" ]] && continue
        local dir_name="$(dirname "${new_name}")"
        [[ -n ${dir_name} ]] && { 
            [[ -d ${dir_name} ]] || run "mkdir -p \"${dir_name}\""
        }
        if run.config.is-dry-run; then
            info "mv -v \"${file}\" \"${new_name}\""
        else
            run.set-next show-output-on
            run "mv -fv \"${file}\" \"${new_name}\""
            counter=$(( counter + 1 ))
        fi
    done
    hr
    inf "Total of ${counter} files have been renamed."
    return
}

----

==== `file.print-normalized-name`

[source,bash]
----
file.print-normalized-name () 
{ 
    local file="$1"
    echo "${file}" | tr '[:upper:]' '[:lower:]' | sed -E 's/ /-/g; s/[^A-Za-z0-9.\-]/-/g; s/---+/--/g'
}

----

==== `file.size`

[source,bash]
----
file.size () 
{ 
    util.os
    if [[ ${BASHMATIC_OS} =~ linux ]]; then
        stat -c %s "$1"
    else
        file.stat "$1" st_size
    fi
}

----

==== `file.size.gb`

[source,bash]
----
file.size.gb () 
{ 
    local file="$1"
    shift
    local s=$(file.size "${file}")
    local gb=$(echo $((s / 10 / 1024 / 1024 )) | sedx 's/([0-9][0-9])$/.\1/g')
    printf "%.1f Gb" "${gb}"
}

----

==== `file.size.mb`

[source,bash]
----
file.size.mb () 
{ 
    local file="$1"
    shift
    local s=$(file.size "${file}")
    local mb=$(echo $((s / 10/ 1024)) | sedx 's/([0-9][0-9])$/.\1/g')
    printf "%.2f MB" "${mb}"
}

----

==== `file.source-if-exists`

[source,bash]
----
file.source-if-exists () 
{ 
    local file
    for file in "$@"
    do
        [[ -f "${file}" ]] && source "${file}"
    done
}

----

==== `file.stat`

[source,bash]
----
file.stat () 
{ 
    local file="$1"
    local field="$2"
    [[ -f ${file} ]] || { 
        error "file ${file} is not found. Usage: file.stat <filename> <stat-field-name>"
        info "eg: ${bldylw}file.stat README.md st_size"
        return 1
    }
    [[ -n ${field} ]] || { 
        error "Second argument field is required."
        info "eg: ${bldylw}file.stat README.md st_size"
        return 2
    }
    eval "$(stat -s "${file}" | tr ' ' '\n' | sed 's/^/local /g')"
    echo "${!field}"
}

----

==== `file.strip.extension`

[source,bash]
----
file.strip.extension () 
{ 
    file.extension.remove "$@"
}

----

==== `file.temp`

[source,bash]
----
file.temp () 
{ 
    local host="${HOST:-${HOSTNAME:-$(hostname)}}"
    local user="${USER:-"$(whoami)"}"
    local temp_file_pattern=".bashmatic.${host}.${user}.${*/ /}"
    local n="$(epoch)"
    local t=$((n % 99991))
    local file="/tmp/${temp_file_pattern}${n}$$${t}${RANDOM}${RANDOM}"
    find "$(dirname "${file}")" -maxdepth 1 -type f -name "${temp_file_pattern}*" -mtime +1 -delete > /dev/null 2>&1
    echo "${file}"
}

----

==== `files.find`

[source,bash]
----
files.find () 
{ 
    local folder="$1"
    local pattern="${2}"
    [[ -z ${folder} || -z ${pattern} ]] && { 
        echo "usage: files.find <folder> <pattern>" 1>&2
        return 1
    }
    find "$1" -name "${pattern}"
}

----

==== `files.map`

[source,bash]
----
files.map () 
{ 
    local folder="${1}"
    local pattern="${2}"
    local array="${3}"
    local -a files
    if bashmatic.bash.version-four-or-later; then
        mapfile -t files < <(files.find "${folder}" "${pattern}")
    else
        files=()
        while IFS='' read -r line; do
            files+=("$line")
        done < <(files.find "${folder}" "${pattern}")
    fi
    if [[ -n ${array} ]]; then
        printf "%s" "unset ${array}; declare -a ${array}; ${array}=(${files[*]}); export ${array}"
    else
        printf "%s" "${files[*]}"
    fi
}

----

==== `files.map.shell-scripts`

[source,bash]
----
files.map.shell-scripts () 
{ 
    files.map "$1" '*.sh' "$2"
}

----

==== `ls.gb`

[source,bash]
----
ls.gb () 
{ 
    du -g -d 1 "$@" | sort -rn
}

----

==== `ls.mb`

[source,bash]
----
ls.mb () 
{ 
    du -m -d 1 "$@" | sort -rn
}

----


=== Module `file-helpers`


=== Module `flatten`

==== `flatten-file`

[source,bash]
----
flatten-file () 
{ 
    local path="$1"
    local dest="${2}"
    [[ ${dest[-1]} == "/" ]] && dest="${dest:0:-1}"
    errors=()
    [[ -f "${path}" ]] || errors+=("File [${path}] was not found.")
    [[ -d "${dest}" ]] || errors+=("Directory [${dest}] does not exist.")
    [[ ${#errors[@]} -eq 0 ]] || { 
        error "${errors[@]}" 1>&2
        return 1
    }
    local target
    local space=" "
    local enclosing="$(dirname "$(dirname "${path}")")"
    target="$(echo "$(dirname "${path}")"â€”"$(basename "${path}")" | sed -E "s/[${space}_]/-/g;")"
    target="${dest} ${bldred}${target/${enclosing/\/}}"
    if ((flag_verbose)); then
        inf "COPY: ${bldgrn}\"${path}\" âž” [${bldylw}\"${target}${bldgrns}\"]" 1>&2
    else
        printf "${txtblu}" 1>&2
    fi
    local command="cp -v \"${path}\" ${bldylw}\"${target}\""
    printf -- "${command}"
    return 0
}

----


=== Module `ftrace`

==== `ftrace-in`

[source,bash]
----
ftrace-in () 
{ 
    local func=$1
    shift
    local args="$*"
    [[ -z ${TraceON} ]] && return
    export __LibTrace__StackLevel=$(( ${__LibTrace__StackLevel} + 1 ))
    printf "    %*s ${bldylw}%s${bldblu}(%s)${clr}\n" ${__LibTrace__StackLevel} ' ' "${func}" "${args}" 1>&2
}

----

==== `ftrace-off`

[source,bash]
----
ftrace-off () 
{ 
    unset TraceON
}

----

==== `ftrace-on`

[source,bash]
----
ftrace-on () 
{ 
    export TraceON=true
}

----

==== `ftrace-out`

[source,bash]
----
ftrace-out () 
{ 
    local func=$1
    shift
    local code=$1
    shift
    local msg="$*"
    [[ -z ${TraceON} ]] && return
    local color="${bldgrn}"
    [[ ${code} -ne 0 ]] && color="${bldred}"
    printf "    %*s ${bldylw}%s() ${color} âžœ  %d %s\n\n" ${__LibTrace__StackLevel} ' ' "${func}" "${code}" "${msg}" 1>&2
    export __LibTrace__StackLevel=$(( ${__LibTrace__StackLevel} - 1 ))
}

----


=== Module `gem`

==== `g-i`

[source,bash]
----
g-i () 
{ 
    gem.install "$@"
}

----

==== `g-u`

[source,bash]
----
g-u () 
{ 
    gem.uninstall "$@"
}

----

==== `gem.cache-installed`

[source,bash]
----
gem.cache-installed () 
{ 
    gem.configure-cache
    if [[ ! -s "${LibGem__GemListCache}" || -z "$(find "${LibGem__GemListCache}" -mmin -30 2> /dev/null)" ]]; then
        gem list > "${LibGem__GemListCache}" > /dev/null
    fi
}

----

==== `gem.cache-refresh`

[source,bash]
----
gem.cache-refresh () 
{ 
    ( gem.configure-cache
    gem.clear-cache
    gem.cache-installed ) > /dev/null
}

----

==== `gem.cache-reset`

[source,bash]
----
gem.cache-reset () 
{ 
    gem.cache-refresh
}

----

==== `gem.changelog-generate`

[source,bash]
----
gem.changelog-generate () 
{ 
    local project="$1"
    [[ -z ${project} ]] && { 
        error "usage: gem.changelog-generate username/repo"
        return 1
    }
    local user
    local repo
    user="${project/\/*/}"
    repo="${project/*\//}"
    gem.install github_changelog_generator
    [[ -z ${GITHUB_TOKEN} ]] && { 
        error "Please set GITHUB_TOKEN to avoid hitting 50 reqs/minute API limit."
        exit 1
    }
    run "github_changelog_generator --project ${repo} --user ${user} -t ${GITHUB_TOKEN} --no-verbose"
    ls -al CHANGELOG.md
}

----

==== `gem.clear-cache`

[source,bash]
----
gem.clear-cache () 
{ 
    rm -f "${LibGem__GemListCache}" > /dev/null
}

----

==== `gem.configure-cache`

[source,bash]
----
gem.configure-cache () 
{ 
    export LibGem__GemListCacheBase="${BASHMATIC_TEMP}/.gem/gem.list"
    export LibGem__GemListCache=
    export LibGem__GemInstallFlags=" -N --force --quiet "
    local ruby_version=$(ruby.numeric-version)
    export LibGem__GemListCache="${LibGem__GemListCacheBase}.${ruby_version}"
    local dir=$(dirname "${LibGem__GemListCache}")
    [[ -d ${dir} ]] || mkdir -p "${dir}" > /dev/null
}

----

==== `gem.ensure-gem-version`

[source,bash]
----
gem.ensure-gem-version () 
{ 
    local gem=$1
    local gem_version=$2
    [[ -z ${gem} || -z ${gem_version} ]] && return
    gem.cache-installed
    if [[ -z $(grep "${gem} (${gem_version}) < ${LibGem__GemListCache}") ]]; then
        gem.uninstall "${gem}"
        gem.install "${gem}" "${gem_version}"
    else
        info "gem ${gem} version ${gem_version} is already installed."
    fi
}

----

==== `gem.gemfile.bundler-version`

[source,bash]
----
gem.gemfile.bundler-version () 
{ 
    [[ -f Gemfile.lock ]] && grep -A2 BUNDLED Gemfile.lock | tail -1 | tr -d ' '
}

----

==== `gem.gemfile.version`

[source,bash]
----
gem.gemfile.version () 
{ 
    local gem=$1
    local gemfile="${2:-"Gemfile.lock"}"
    [[ -z ${gem} ]] && return
    [[ -f ${gemfile} ]] || { 
        error "Can't find Gemfile ${gemfile} in the current directory" 1>&2
        return 1
    }
    grep -E -e " ${gem} \([0-9]" "${gemfile}" | awk '{print $2}' | sed 's/[()]//g'
}

----

==== `gem.global.latest-version`

[source,bash]
----
gem.global.latest-version () 
{ 
    local gem="$1"
    [[ -z ${gem} ]] && return
    declare -a versions=($(gem.global.versions "${gem}"))
    local max=0
    local max_version=${versions[0]}
    for v in "${versions[@]}"
    do
        vi=$(util.ver-to-i "${v}")
        if [[ ${vi} -gt ${max} ]]; then
            max=${vi}
            max_version="${v}"
        fi
    done
    printf "%s" "${max_version}"
}

----

==== `gem.global.versions`

[source,bash]
----
gem.global.versions () 
{ 
    local gem=$1
    [[ -z ${gem} ]] && return
    gem.cache-installed
    grep -E -e "^${gem} " < "${LibGem__GemListCache}" | sedx "s/^${gem} //g;s/[(),]//g"
}

----

==== `gem.install`

[source,bash]
----
gem.install () 
{ 
    .gem.verify-name "$@" || return 1
    local gem_name="$1"
    local gem_version="$2"
    local gem_version_flags=
    local gem_version_name=
    gem_version=${gem_version:-$(gem.version "${gem_name}")}
    if [[ -z ${gem_version} ]]; then
        gem_version_name=latest
        gem_version_flags=
    else
        gem_version_name="${gem_version}"
        gem_version_flags="--version ${gem_version}"
    fi
    if gem.is-installed "${gem_name}" "${gem_version}"; then
        info: "gem ${bldylw}${gem_name} (${bldgrn}${gem_version_name}${bldylw})${txtblu} is already installed"
    else
        info "installing ${bldylw}${gem_name} ${bldgrn}(${gem_version_name})${txtblu}..."
        run "gem install ${gem_name} ${gem_version_flags} ${LibGem__GemInstallFlags}"
        if [[ ${LibRun__LastExitCode} -eq 0 ]]; then
            rbenv rehash > /dev/null 2> /dev/null
            gem.cache-refresh
        else
            error "Unable to install gem ${bldylw}${gem_name}"
        fi
        return "${LibRun__LastExitCode}"
    fi
}

----

==== `gem.is-installed`

[source,bash]
----
gem.is-installed () 
{ 
    local gem=$1
    local version=$2
    gem.cache-installed > /dev/null
    if [[ -z ${version} ]]; then
        grep -q -E -e "^${gem} \(" "${LibGem__GemListCache}"
    else
        grep -E -e "^${gem} \(" "${LibGem__GemListCache}" | grep -E -q -e "${version}"
    fi
}

----

==== `gem.remote.version`

[source,bash]
----
gem.remote.version () 
{ 
    [[ -z "$1" ]] && return
    gem search "$1" --remote -e | sedx "s/^${1} //g; s/[(),]//g"
}

----

==== `gem.uninstall`

[source,bash]
----
gem.uninstall () 
{ 
    .gem.verify-name "$@" || return 1
    local gem_name=$1
    local gem_version=$2
    gem.is-installed "${gem_name}" "${gem_version}" || { 
        info "gem ${bldylw}${gem_name}${txtblu} is not installed"
        return
    }
    local gem_flags="-x -I --force"
    if [[ -z ${gem_version} ]]; then
        gem_flags="${gem_flags} -a"
    else
        gem_flags="${gem_flags} --version ${gem_version}"
    fi
    run "gem uninstall ${gem_name} ${gem_flags}"
    gem.clear-cache
    return "${LibRun__LastExitCode}"
}

----

==== `gem.version`

[source,bash]
----
gem.version () 
{ 
    local gem="$1"
    local default="$2"
    [[ -z ${gem} ]] && return
    local version
    [[ -f Gemfile.lock ]] && version=$(gem.gemfile.version "${gem}")
    if [[ -z ${version} ]]; then
        if gem.is-installed "${gem}"; then
            version=$(gem.global.latest-version "${gem}")
        else
            version=$(gem.remote.version "${gem}")
        fi
    fi
    [[ -z ${version} && -n ${default} ]] && version=${default}
    printf "%s" "${version}"
}

----


=== Module `git`

==== `git.branch.current`

[source,bash]
----
git.branch.current () 
{ 
    git rev-parse --abbrev-ref HEAD
}

----

==== `git.cfg.get`

[source,bash]
----
git.cfg.get () 
{ 
    local section="global"
    if [[ "$1" == "local" || "$1" == "global" ]]; then
        section="$1"
        shift
    fi
    local command="get"
    local cmd
    if [[ -z "$*" ]]; then
        cmd="git config --${section} --list"
    else
        if [[ "$*" =~ ^[a-z\.]*$ ]]; then
            for token in "$@"
            do
                cmd="git config --${section} --${command} ${token}"
            done
        else
            cmd="git config --${section} --get-all '$*'"
        fi
    fi
    h1 "${cmd}"
    eval "${cmd}"
}

----

==== `git.cfgu`

[source,bash]
----
git.cfgu () 
{ 
    [[ -z $1 ]] && { 
        git config --global -l
        return
    }
    if [[ -n $2 ]]; then
        rm -f ~/.gitconfig.lock
        git config --global --replace-all user."$1" "$2"
    else
        if [[ $1 =~ - ]]; then
            git config --global "$1"
        else
            git config --global user."$1"
        fi
    fi
}

----

==== `git.commits.last.message`

[source,bash]
----
git.commits.last.message () 
{ 
    git log --pretty=format:"%s" -1
}

----

==== `git.commits.last.sha`

[source,bash]
----
git.commits.last.sha () 
{ 
    git log --pretty=format:"%H" -1
}

----

==== `git.config.kigster`

[source,bash]
----
git.config.kigster () 
{ 
    [[ $(git.cfgu name) == "Konstantin Gredeskoul" && $(git.cfgu email) == "kigster@gmail.com" ]] && return 0
    git.cfgu name "Konstantin Gredeskoul"
    git.cfgu email "kigster@gmail.com"
}

----

==== `git.configure-auto-updates`

[source,bash]
----
git.configure-auto-updates () 
{ 
    export LibGit__StaleAfterThisManyHours="${LibGit__StaleAfterThisManyHours:-"1"}"
    export LibGit__LastUpdateTimestampFile="${BASHMATIC_TEMP}/.config/$(echo "${USER}" | shasum.sha-only-stdin)"
    mkdir -p "$(dirname "${LibGit__LastUpdateTimestampFile}")"
}

----

==== `git.current-branch`

[source,bash]
----
git.current-branch () 
{ 
    git branch --no-color | grep -F "*" | cut -f 2 -d " "
}

----

==== `git.generate-changelog`

[source,bash]
----
git.generate-changelog () 
{ 
    [[ -z ${GITHUB_TOKEN} ]] && { 
        error "Please set GITHUB_TOKEN to avoid hitting 50 reqs/minute API limit."
        return 1
    }
    git.is-valid-repo || return 2
    gem.install github_changelog_generator
    local -a remote_parts
    remote_parts=($(git.parse-remote "$(git.remote)"))
    local user=${remote_parts[3]}
    local repo=${remote_parts[4]}
    local host=${remote_parts[2]}
    [[ ${host} =~ github.com ]] || { 
        error "Can only generate changelog for Github Repos at the moment, sorry."
        return 1
    }
    run "rm -f CHANGELOG.md"
    run "github_changelog_generator --project ${repo/\.git/} --user ${user} -t ${GITHUB_TOKEN} --no-verbose"
    [[ -s "CHANGELOG.md" ]] || { 
        error "CHANGELOG.md has not been generated."
        return 1
    }
    success "CHANGELOG.md is ready."
    return 0
}

----

==== `git.is-it-time-to-update`

[source,bash]
----
git.is-it-time-to-update () 
{ 
    local last_update_at=$(git.last-update-at)
    local second_since_update=$(git.seconds-since-last-pull "${last_update_at}")
    local update_period_seconds=$((LibGit__StaleAfterThisManyHours * 60 * 60))
    [[ ${second_since_update} -gt ${update_period_seconds} ]]
}

----

==== `git.is-valid-repo`

[source,bash]
----
git.is-valid-repo () 
{ 
    if [[ ! -d .git ]]; then
        error "Please run this script at the root of your project / git repo." 1>&2
        return 1
    fi
}

----

==== `git.last-update-at`

[source,bash]
----
git.last-update-at () 
{ 
    git.configure-auto-updates
    local file="${1:-"${LibGit__LastUpdateTimestampFile}"}"
    local last_update=0
    if [[ ${LibGit__ForceUpdate} -eq 0 && -f ${file} ]]; then
        last_update="$(cat "$file" | tr -d '\n')"
    else
        last_update=0
    fi
    printf "%d" ${last_update}
}

----

==== `git.local-vs-remote`

[source,bash]
----
git.local-vs-remote () 
{ 
    local upstream=${1:-'@{u}'}
    local local_repo=$(git rev-parse @)
    local remote_repo=$(git rev-parse "$upstream")
    local base=$(git merge-base @ "$upstream")
    if [[ -n ${BASHMATIC_DEBUG} ]]; then
        printf "
      pwd         = $(pwd)
      remote      = $(git.remotes)
      base        = ${base}
      upstream    = ${upstream}
      local_repo  = ${local_repo}
      remote_repo = ${remote_repo}
    "
    fi
    local result=
    if [[ "${local_repo}" == "${remote_repo}" ]]; then
        result="ok"
    else
        if [[ "${local_repo}" == "${base}" ]]; then
            result="behind"
        else
            if [[ "${remote_repo}" == "${base}" ]]; then
                result="ahead"
            else
                result="diverged"
            fi
        fi
    fi
    printf '%s' ${result}
    [[ ${result} == "ok" ]] && return 0
    return 1
}

----

==== `git.open.current`

[source,bash]
----
git.open.current () 
{ 
    local url=$(git.repo.current)
    info "git.open() -> ${bldylw}${url}"
    open -a 'Google Chrome' "${url}"
}

----

==== `git.open.repo`

[source,bash]
----
git.open.repo () 
{ 
    local url=$(git.repo)
    info "git.open.repo() -> ${bldylw}${url}"
    open -a 'Google Chrome' "${url}"
}

----

==== `git.parse-remote`

[source,bash]
----
git.parse-remote () 
{ 
    local url="${1:-$(git.remote)}"
    local re="^(https|git)(:\/\/|@)([^\/:]+)[\/:]([^\/:]+)\/(.+)(\.git)?$"
    [[ $url =~ $re ]] || { 
        error "git remote [${url}] does not match regualar expression." 1>&2
        return 1
    }
    local protocol="${BASH_REMATCH[1]}"
    local separator="${BASH_REMATCH[2]}"
    local hostname="${BASH_REMATCH[3]}"
    local user="${BASH_REMATCH[4]}"
    local repo="${BASH_REMATCH[5]}"
    printf "%s %s %s %s %s\n" "${protocol}" "${separator}" "${hostname}" "${user}" "${repo}"
}

----

==== `git.quiet`

[source,bash]
----
git.quiet () 
{ 
    [[ -n ${LibGit__QuietUpdate} ]]
}

----

==== `git.remote`

[source,bash]
----
git.remote () 
{ 
    if git.remotes | grep -q "git@"; then
        git.remotes | egrep "git@" | sort | head -1
    else
        git.remotes | sort | head -1
    fi
}

----

==== `git.remotes`

[source,bash]
----
git.remotes () 
{ 
    git remote -v | awk '{print $2}' | uniq
}

----

==== `git.repo`

[source,bash]
----
git.repo () 
{ 
    local url=$(git remote get-url origin | sed -E 's/git@/https:\/\//g;s/com:/com\//g')
    printf -- "%s" "${url}"
}

----

==== `git.repo-is-clean`

[source,bash]
----
git.repo-is-clean () 
{ 
    local repo="${1:-${BASHMATIC_HOME:="${HOME}/.bashmatic"}}"
    cd "${repo}" > /dev/null
    if [[ -z $(git status -s) ]]; then
        cd - > /dev/null
        return 0
    else
        cd - > /dev/null
        return 1
    fi
}

----

==== `git.repo.current`

[source,bash]
----
git.repo.current () 
{ 
    local url="$(git.repo)"
    local current_branch="$(git.branch.current)"
    local readme="README.md"
    for file in README.md README README.txt README.adoc CHANGELOG.md
    do
        if [[ -s "${file}" ]]; then
            export readme="${file}"
            break
        fi
    done
    local full_url="${url}/blob/${current_branch}/${readme}"
    printf -- "%s" "${full_url}"
}

----

==== `git.repo.latest-local-tag`

[source,bash]
----
git.repo.latest-local-tag () 
{ 
    git tag -l | sort | tail -1
}

----

==== `git.repo.latest-remote-tag`

[source,bash]
----
git.repo.latest-remote-tag () 
{ 
    local repo_url="$1"
    git ls-remote --tags --sort="v:refname" "${repo_url}" | grep -E \-v '(latest|stable)' | grep -E -v '\^{}' | tail -1 | awk 'BEGIN{FS="/"}{print $3}'
}

----

==== `git.repo.next-local-tag`

[source,bash]
----
git.repo.next-local-tag () 
{ 
    local tag=$(git.repo.latest-local-tag)
    [[ -z ${tag} ]] && tag="0.0.0"
    ruby -e "prefix='${tag}'.gsub(/^([^\d]+).*/, '\1'); version='${tag}'.gsub(/[^\d.]/, '').split(/\./).map(&:to_i); version[2]+=1; puts \"#{prefix}#{version.join('.')}\""
}

----

==== `git.repo.remote-to-git@`

[source,bash]
----
git.repo.remote-to-git@ () 
{ 
    local f=".git/config"
    if [[ -f "$f" ]]; then
        grep -q "url = git@" "$f" && { 
            info "The repo is already using git@ syntax for the remote."
            return 0
        }
        cat "${f}" | sed -E 's#url = https://github\.com/([^/]*)/#url = git@github\.com:\1/#g' > "${f}.ssh"
        mv "${f}" "${f}.https"
        cd .git
        ln -nfs config.ssh config
        cd - > /dev/null
        hr
        info "Created an ssh version of .git/config file, and symlinked it:"
        ls -l .git/config*
        info "Your new remote:"
        info $(grep "git@" "${f}")
        hr
    fi
}

----

==== `git.save-last-update-at`

[source,bash]
----
git.save-last-update-at () 
{ 
    echo $(epoch) > "${LibGit__LastUpdateTimestampFile}"
}

----

==== `git.seconds-since-last-pull`

[source,bash]
----
git.seconds-since-last-pull () 
{ 
    local last_update="$1"
    local now=$(epoch)
    printf $((now - last_update))
}

----

==== `git.squash`

[source,bash]
----
git.squash () 
{ 
    local number="${1}"
    is.numeric "${number}" || { 
        info "USAGE: git.squash <number> # of commits to go back"
        return
    }
    run "git reset --soft HEAD~${number}"
    info "We've squashed down ${number} commits locally."
    info "Now, you must commit this squash, and likely force push."
}

----

==== `git.sync`

[source,bash]
----
git.sync () 
{ 
    local dir="$(pwd -P)"
    cd "${BASHMATIC_HOME}" > /dev/null
    git.repo-is-clean || { 
        output.is-ssh || warning "${BASHMATIC_HOME} has locally modified files." "Please commit or stash them to allow auto-upgrade to function as designed." 1>&2
        cd "${dir}" > /dev/null
        return 1
    }
    if is-debug; then
        git.update-repo-if-needed
    else
        git.update-repo-if-needed 1>&2 > /dev/null
    fi
    cd "${dir}" > /dev/null
    return 0
}

----

==== `git.sync-dirs`

[source,bash]
----
git.sync-dirs () 
{ 
    local pattern="${1:-'*'}"
    set -e
    run.set-all abort-on-error
    for dir in $(find . -type d -maxdepth 1 -name "${pattern}*")
    do
        hl.yellow-on-gray "syncing [$dir]..."
        cd "$dir" > /dev/null
        run "git pull --rebase"
        cd - > /dev/null
    done
}

----

==== `git.sync-remote`

[source,bash]
----
git.sync-remote () 
{ 
    git.is-it-time-to-update || return 0
    if git.quiet; then
        ( git remote update && git fetch ) 2>&1 > /dev/null
    else
        run "git remote update && git fetch"
    fi
    local git_status="$(git.local-vs-remote)"
    if [[ ${git_status} == "behind" ]]; then
        git.quiet || run "git pull --rebase"
        git.quiet && git pull --rebase 2>&1 > /dev/null
    else
        if [[ ${git_status} != "ahead" ]]; then
            git.save-last-update-at
        else
            if [[ ${git_status} != "ok" ]]; then
                error "Report $(pwd) is ${status} compared to the remote." "Please fix manually to continue."
                return 1
            fi
        fi
    fi
    git.save-last-update-at
    return 0
}

----

==== `git.update-repo-if-needed`

[source,bash]
----
git.update-repo-if-needed () 
{ 
    git.is-it-time-to-update && git.sync-remote
}

----

==== `git.upstream`

[source,bash]
----
git.upstream () 
{ 
    local this_branch=$(git.current-branch)
    this_branch=${this_branch:-main}
    run.set-next show-output-on
    run "git branch --set-upstream-to=origin/${this_branch} ${this_branch}"
}

----


=== Module `github`

==== `github.clone`

[source,bash]
----
github.clone () 
{ 
    test -n "$1" && github.validate && run "git clone git@github.com:$(github.org)/$1"
}

----

==== `github.org`

[source,bash]
----
github.org () 
{ 
    local namespace="$1"
    if [[ -z ${namespace} ]]; then
        git config --global --get user.github
    else
        git config --global --unset user.github
        git config --global --add user.github "${namespace}"
    fi
}

----

==== `github.setup`

[source,bash]
----
github.setup () 
{ 
    local namespace="$(github.org)"
    if [[ -z "${namespace}" ]]; then
        unset GITHUB_ORG
        run.ui.ask-user-value GITHUB_ORG "Please enter the name of your Github Organization:" || return 1
        github.org "${GITHUB_ORG}"
        echo
        h2 "Your github organization was saved in your ~/.gitconfig file." "To change it in the future, run: ${bldylw}github.org ${blgrn}new-organization"
        echo
    fi
    github.org > /dev/null
}

----

==== `github.validate`

[source,bash]
----
github.validate () 
{ 
    inf "Validating Github Configuration..."
    if github.org > /dev/null; then
        ok:
        return 0
    else
        not-ok:
        github.setup
        return $?
    fi
}

----


=== Module `gpg`

==== `gpg.install`

[source,bash]
----
gpg.install () 
{ 
    [[ -z ${BASHMATIC_OS} ]] && util.os
    gpg.install-deps
    case "${BASHMATIC_OS}" in 
        darwin)
            brew.install.packages "gnupg"
        ;
        linux)
            run "sudo apt-get install gnupg -yyq"
        ;
    esac
}

----

==== `gpg.install-deps`

[source,bash]
----
gpg.install-deps () 
{ 
    [[ -z ${BASHMATIC_OS} ]] && util.os
    case "${BASHMATIC_OS}" in 
        darwin)
            brew.install.packages "coreutils gawk gnu-sed git curl gzip"
        ;
        linux)
            run "sudo apt-get install -yqq bash gnupg2 git tar xz-utils coreutils gawk grep sed"
            run "sudo apt-get install -yqq gzip bzip lzip file jq curl"
        ;
    esac
}

----

==== `gpg.key-for-github`

[source,bash]
----
gpg.key-for-github () 
{ 
    [[ -z ${BASHMATIC_OS} ]] && util.os
    if ! command -v gpg > /dev/null; then
        gpg.install
    fi
    local -a info=($(gpg.name-and-email))
    local name="${info[0]}"
    local email="${info[1]}"
    local -a keys=($(gpg.my-keys))
    if [[ ${#keys[@]} -gt 0 ]]; then
        gpg.my-keys
        return 0
    fi
    local key_spec="$(mktemp)"
    echo "%echo Generating a basic OpenPGP key
Key-Type: 1
Key-Length: 4096
Name-Real: ${name}
Name-Email: ${email}
Expire-Date: 0
%no-protection
%commit
%echo done
" > "${key_spec}"
    cat "${key_spec}"
    gpg --batch --gen-key "${key_spec}" > /dev/null
}

----

==== `gpg.my-keys`

[source,bash]
----
gpg.my-keys () 
{ 
    local -a info=($(gpg.name-and-email))
    local name="${info[0]}"
    local email="${info[1]}"
    declare -a keys=($(gpg --list-secret-keys --keyid-format=long | grep -B 3 -E "^uid *\[ultimate\] ${name}.*$" | grep -E '^sec' | cut -d '/' -f 2 | sed 's/ .*$//g'))
    if [[ ${#keys[@]} -gt 0 ]]; then
        printf "\n${bldylw}Your GPG keys are:${clr}\n" 1>&2
        echo "${keys[*]}" | tr ' ' "\n"
        local len=${#keys[@]}
        local index
        while true; do
            if [[ -n ${index} && ${index} -ge 0 && ${index} -lt ${#keys[@]} ]]; then
                local key_id="${keys[${index}]}"
                printf -- "Key ID is ${bldylw}${key_id}\n\n"
                run "git config --global user.signingkey ${key_id}"
                gpg --armor --export "${key_id}" | pbcopy
                gpg --armor --export "${key_id}"
                printf -- "${clr}NOTE: ${bldylw}the key is now in your clipboard${clr}.\n\n"
                printf -- "${clr}NOTE: gpg key for your ~/.gitconfig is ${bldgrn}${key_id}\n\n"
                hr
                return $?
            else
                [[ -n ${index} ]] && printf "${bldred}Invalid answer, expecting a number between 1 and ${len}.${clr}\n"
                run.ui.ask-user-value index "Which key would you like to print [1-${len}]? ${clr}"
                index=$(( index - 1  ))
            fi
        done
    else
        echo "No gpg keys found matching name ${name}." 1>&2
        return 1
    fi
    return 0
}

----

==== `gpg.name-and-email`

[source,bash]
----
gpg.name-and-email () 
{ 
    local name="$(git config --global --get user.name)"
    local email="$(git config --global --get user.email)"
    [[ -z ${name} ]] && run.ui.ask-user-value name "Your full name:"
    [[ -z ${email} ]] && run.ui.ask-user-value email "Your full Email:"
    echo "${name}" "${email}"
}

----


=== Module `is`

==== `is-validations`

[source,bash]
----
is-validations () 
{ 
    util.functions-matching.diff is\\. | sedx 's/^/is./g'
}

----

==== `is.a-command`

[source,bash]
----
is.a-command () 
{ 
    is.command "$@"
}

----

==== `is.a-directory`

[source,bash]
----
is.a-directory () 
{ 
    [[ -d "${1}" ]]
}

----

==== `is.a-function`

[source,bash]
----
is.a-function () 
{ 
    if [[ -n $1 ]] && typeset -f "$1" > /dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

----

==== `is.a-function.invoke`

[source,bash]
----
is.a-function.invoke () 
{ 
    local func="$1"
    shift
    is.a-function "${func}" && eval "${func} \"$@\""
}

----

==== `is.a-non-empty-array`

[source,bash]
----
is.a-non-empty-array () 
{ 
    local var_name="$1"
    local -a array
    echo "array=( \"\${${var_name}[@]}\" )"
    eval "array=( \"\${${var_name}[@]}\" )"
    [[ -n ${array[*]} && ${var_name} =~ ^[0-9a-zA-Z_]+$ && ${#array[@]} -gt 0 ]]
}

----

==== `is.a-non-empty-file`

[source,bash]
----
is.a-non-empty-file () 
{ 
    [[ -s "${1}" ]]
}

----

==== `is.a-script`

[source,bash]
----
is.a-script () 
{ 
    bashmatic.detect-subshell
    [[ ${BASH_IN_SUBSHELL} -eq 1 ]]
}

----

==== `is.a-variable`

[source,bash]
----
is.a-variable () 
{ 
    local var_name="$1"
    local shell="$(user.current-shell)"
    case $shell in 
        bash)
            [[ -n ${var_name} && ${var_name} =~ ^[0-9a-zA-Z_]+$ && -n ${!var_name+x} ]] && return 0
        ;
        zsh)
            eval "[[ -v ${var_name} ]]" && return 0
        ;
        *)
            return 1
        ;
    esac
}

----

==== `is.alias`

[source,bash]
----
is.alias () 
{ 
    alias "$1" 2> /dev/null
}

----

==== `is.an-empty-file`

[source,bash]
----
is.an-empty-file () 
{ 
    [[ ! -s "${1}" ]]
}

----

==== `is.an-existing-file`

[source,bash]
----
is.an-existing-file () 
{ 
    [[ -f "${1}" ]]
}

----

==== `is.an-integer`

[source,bash]
----
is.an-integer () 
{ 
    is.integer "$@"
}

----

==== `is.blank`

[source,bash]
----
is.blank () 
{ 
    [[ -z "${1}" ]]
}

----

==== `is.command`

[source,bash]
----
is.command () 
{ 
    command -v "$1" > /dev/null
}

----

==== `is.empty`

[source,bash]
----
is.empty () 
{ 
    is.blank "$@"
}

----

==== `is.integer`

[source,bash]
----
is.integer () 
{ 
    [[ $1 =~ ^[+-]?[0-9]+$ ]]
}

----

==== `is.missing`

[source,bash]
----
is.missing () 
{ 
    ! is.command "$@"
}

----

==== `is.non.zero`

[source,bash]
----
is.non.zero () 
{ 
    [[ $1 -ne 0 ]]
}

----

==== `is.not-a-blank-var`

[source,bash]
----
is.not-a-blank-var () 
{ 
    local var="$1"
    [[ -n "${!var}" ]]
}

----

==== `is.not-blank`

[source,bash]
----
is.not-blank () 
{ 
    [[ -n "${1}" ]]
}

----

==== `is.numeric`

[source,bash]
----
is.numeric () 
{ 
    [[ $1 =~ ^[+-]?([0-9]+([.][0-9]*)?|\.[0-9]+)$ ]]
}

----

==== `is.sourced-in`

[source,bash]
----
is.sourced-in () 
{ 
    bashmatic.detect-subshell
    [[ ${BASH_IN_SUBSHELL} -eq 0 ]]
}

----

==== `is.variable`

[source,bash]
----
is.variable () 
{ 
    is.a-variable "$@"
}

----

==== `is.zero`

[source,bash]
----
is.zero () 
{ 
    [[ $1 -eq 0 ]]
}

----

==== `unless`

[source,bash]
----
unless () 
{ 
    ! __is.validation.error "${2}" "${1}" __is.validation.ignore-error "${@:3}"
}

----

==== `validations.add-error`

[source,bash]
----
validations.add-error () 
{ 
    local error="$1"
    local value="$2"
    is.not-blank "${error}" && is.not-blank "${value}" && { 
        export Bashmatic__IsErrors+=("${error}")
        export Bashmatic__IsValues+=("${value}")
    }
}

----

==== `validations.begin`

[source,bash]
----
validations.begin () 
{ 
    export Bashmatic__IsErrors=()
    export Bashmatic__IsValues=()
    export Bashmatic__IsSessionName="$1"
}

----

==== `validations.end`

[source,bash]
----
validations.end () 
{ 
    validations.print-errors "$@"
    validations.begin ""
}

----

==== `validations.print-errors`

[source,bash]
----
validations.print-errors () 
{ 
    local error_count="${#Bashmatic__IsErrors}"
    ((error_count)) || return 0
    is.not-blank "${Bashmatic__IsSessionName}" && hl.salmon "Reporing errors for ${Bashmatic__IsSessionName}"
    for i in $(seq 1 "${error_count}")
    do
        local error=${Bashmatic__IsErrors[$((i - 1))]}
        local value=${Bashmatic__IsValues[$((i - 1))]}
        error "${error}" "Invalid value: ${value}"
    done
    return "${error_count}"
}

----

==== `whenever`

[source,bash]
----
whenever () 
{ 
    __is.validation.error "${2}" "${1}" __is.validation.report-error "${@:3}"
}

----


=== Module `jemalloc`

==== `jm.check`

[source,bash]
----
jm.check () 
{ 
    local JM_Quiet=false
    local JM_Ruby=false
    local JM_Stats=false
    while :; do
        case $1 in 
            -q | --quiet)
                shift
                export JM_Quiet=true
            ;
            -r | --ruby)
                shift
                export JM_Ruby=true
            ;
            -s | --stats)
                shift
                export JM_Stats=true
                exit $?
            ;
            -h | -\? | --help)
                shift
                jm.usage
                exit 0
            ;
            --)
                shift
                break
            ;
            *)
                break
            ;
        esac
    done
    ${JM_Ruby} && { 
        jm.ruby.report
        exit 0
    }
    ${JM_Quiet} && { 
        jm.jemalloc.detect-quiet
        code=$?
        exit ${code}
    }
    ${JM_Stats} && { 
        jm.jemalloc.stats
        exit 0
    }
    jm.jemalloc.detect-loud
}

----

==== `jm.jemalloc.detect-loud`

[source,bash]
----
jm.jemalloc.detect-loud () 
{ 
    jm.jemalloc.detect-quiet
    local code=$?
    local local_ruby=$(jm.ruby.detect)
    printf "${ColorBlue}Checking if ruby ${ColorYellow}${local_ruby}${ColorBlue} is linked with jemalloc... \n\n "
    if [[ ${code} -eq 0 ]]; then
        printf " âœ… ${ColorGreen} â€”Â jemalloc was detected.\n"
    else
        printf " ðŸš« ${ColorRed} â€” jemalloc was not detected.\n"
    fi
    printf "${ColorReset}\n"
    return ${code}
}

----

==== `jm.jemalloc.detect-quiet`

[source,bash]
----
jm.jemalloc.detect-quiet () 
{ 
    MALLOC_CONF=stats_print:true ruby -e "exit" 2>&1 | grep -q "jemalloc statistics"
    return $?
}

----

==== `jm.jemalloc.stats`

[source,bash]
----
jm.jemalloc.stats () 
{ 
    jm.jemalloc.detect-quiet || { 
        printf "No Jemalloc was found for the curent ruby $(jm.ruby.detect)\n"
        return 1
    }
    MALLOC_CONF=stats_print:true ruby -e "exit" 2>&1 | less -S
}

----

==== `jm.ruby.detect`

[source,bash]
----
jm.ruby.detect () 
{ 
    local ruby_loc
    if [[ -n $(which rbenv) ]]; then
        ruby_loc=$(rbenv versions | grep '*' | awk '{print $2}')
        [[ -n ${ruby_loc} ]] && ruby_loc="(rbenv) ${ruby_loc}"
    else
        ruby_loc="$(which ruby) $(ruby -e 'puts "#{RUBY_VERSION} (#{RUBY_PLATFORM})"')"
    fi
    printf "%s" "${ruby_loc}"
}

----

==== `jm.ruby.report`

[source,bash]
----
jm.ruby.report () 
{ 
    printf "Ruby version being tested:\n  â†’  ${ColorBlue}$(which ruby) ${ColorYellow}$(jm.ruby.detect)${ColorReset}\n"
}

----

==== `jm.usage`

[source,bash]
----
jm.usage () 
{ 
    printf "
${ColorBlue}USAGE:${ColorReset}
  $(basename "$0") [ -q/--quiet ]
                 [ -r/--ruby  ]
                 [ -s/--stats ]
                 [ -h/--help  ]

${ColorBlue}DESCRIPTION:${ColorReset}
  Determines whether the currently defined in the PATH ruby
  interpreter is linked with libjemalloc memory allocator.

${ColorBlue}OPTIONS${ColorReset}
  -q/--quiet        Do not print output, exit with 1 if no jemalloc
  -r/--ruby         Print which ruby is currently in the PATH
  -s/--stats        Print the jemalloc stats
  -h/--help         This page.
%s
" ""
    exit 0
}

----


=== Module `json`

==== `json.begin-array`

[source,bash]
----
json.begin-array () 
{ 
    [[ -n "$1" ]] && json.begin-key "$1"
    echo " ["
}

----

==== `json.begin-hash`

[source,bash]
----
json.begin-hash () 
{ 
    [[ -n "$1" ]] && json.begin-key "$1"
    echo "{"
}

----

==== `json.begin-key`

[source,bash]
----
json.begin-key () 
{ 
    if [[ -n "$1" ]]; then
        printf "\"${1}\": "
    fi
}

----

==== `json.end-array`

[source,bash]
----
json.end-array () 
{ 
    printf "]"
    [[ "$1" == "true" ]] && printf ","
    echo
}

----

==== `json.end-hash`

[source,bash]
----
json.end-hash () 
{ 
    printf "}"
    [[ "$1" == "true" ]] && printf ","
    echo
}

----

==== `json.file-to-array`

[source,bash]
----
json.file-to-array () 
{ 
    json.begin-array "$1"
    cat "$2" | tr -d '\r' | tr -d '\015' | sed 's/^/"/g;s/$/",/g' | tail -r | awk -F, '{if (FNR!=1) print; else print $1} ' | tail -r
    json.end-array "$3"
}

----


=== Module `maths`

==== `maths.eval`

[source,bash]
----
maths.eval () 
{ 
    local __math_chars=(!Â²Â³Â¹Â¼Â½Â¾Ã—Ã·Î Î£â°â±â´âµâ¶â·â¸â¹â¿â…“â…”â…•â…–â…—â…˜â…™â…šâ…›â…œâ…â…žâˆ…âˆˆâˆ‰âˆšâˆ›âˆœâˆžâˆ©âˆªâˆ¿âŠ‚âŠƒâŸŒÏ„ð›•ðœð‰ðžƒðž½à¥¦à¥§à¥¨à¥©à¥ªà¥«à¥¬à¥­à¥®à¥¯â„¯ðžð‘’ð’†ð–¾ð—²ð˜¦ð™šðšŽï½…Ï€Ï–ð›‘ð›¡ðœ‹ðœ›ð…ð•ð¿ðžðž¹ðŸ‰ð¢ð‘–ð’Šð’¾ð“²ð”¦ð•šð–Žð—‚ð—¶ð˜ªð™žðš’)
    local -a __math_chars_array=($(echo "${__math_chars}" | sedx 's/(.)/\1 /g'))
    local __math_chars_array
    [[ -z "$1" ]] && { 
        output.set-max-width 100
        output.set-min-width 40
        usage-box "maths.eval 'expression' [ floating precitions [ total width ] Â© Computes a mathematical expression with UTF support" "Example 1." "maths.eval 'âˆš(57)*â…“Ã—(sin(Ï€Ã·(1.3)))' => 1.66882" "Example 2." "maths.eval '5!Ã—(ï½…)' => 326.19382" "Special Characters:" "" " 0 through 23" "${__math_chars_array[*]:0:24}" "24 through 48" "${__math_chars_array[*]:24:24}" "48 through 72" "${__math_chars_array[*]:48:24}" "72 through 96" "${__math_chars_array[*]:72:24}"
        info "NOTE: ensure to use () brackets to group items you want to compute."
        info "NOTE: if in doubt, add more brackets :) "
        output.reset-min-max-width
        return 0
    }
    gem.install unicode_math > /dev/null
    local expression="$1"
    shift
    local output_precision="${1:-"5"}"
    shift
    local output_width="${1}"
    local ruby_script="require 'unicode_math'; printf('%${output_width}.${output_precision}f', (Math.module_eval { ${expression} }))"
    ruby_script="$(echo "${ruby_script}" | sedx 's/ ?(Ã—|Ã·|!)/\.\1/g')"
    local temp_file
    temp_file="$(mktemp)"
    ruby -r 'unicode_math' -e "${ruby_script}" 2> "${temp_file}"
    local code="$?"
    [[ ${code} -ne 0 ]] && { 
        error "Unable to perform an arithmetic expression:" "${bldylw}${ruby_script}" 1>&2
        info "Error: \n${bldylw}$(cat "${temp_file}")"
        return 1
    }
    rm -f "${temp_file}"
    return 0
}

----


=== Module `net`

==== `net.fast-scan`

[source,bash]
----
net.fast-scan () 
{ 
    local subnet="${1:-"$(net.local-subnet)"}"
    local out=$(mktemp)
    run.set-next show-output-on
    local colored=/tmp/colored.$$
    run "sudo nmap --min-parallelism 15 -O --host-timeout 5 -F ${subnet} > ${out}"
    run "echo 'printf \"' > ${colored}"
    cat "${out}" | sed -E "s/Nmap scan report for (.*)$/\n\${bldylw}Nmap scan report for \1\${clr}\n/g" >> ${colored}
    run "echo '\"' >> ${colored}"
    bash ${colored}
}

----

==== `net.is-host-port-protocol-open`

[source,bash]
----
net.is-host-port-protocol-open () 
{ 
    local host="$1"
    local port="$2"
    local protocol="${3:-"tcp"}"
    local command="nmap"
    [[ ${protocol} =~ udp ]] && command="sudo nmap -sU"
    command -v nmap > /dev/null || brew.install.package nmap 1>&2
    ${command} -Pn -p "${port}" "${host}" 2>&1 | ascii-pipe | grep -q -E "${port}/${protocol} open "
}

----

==== `net.local-net`

[source,bash]
----
net.local-net () 
{ 
    ifconfig -a | grep inet | grep broadcast | awk '{print $2}' | awk 'BEGIN{FS="."}{printf "%d.%d.%d.%s", $1, $2, $3, "0/24"}'
}

----

==== `net.local-subnet`

[source,bash]
----
net.local-subnet () 
{ 
    local subnet="$(ifconfig -a | grep inet | grep broadcast | grep -v 'inet 169' | grep -v 'inet 127' | awk '{print $2}' | cut -d '.' -f 1,2,3 | sort | uniq | head -1).0/24"
    printf '%s' "${subnet}"
}

----


=== Module `nvm`

==== `node.install.pin.version`

[source,bash]
----
node.install.pin.version () 
{ 
    local node_version="${1:-${node_version}}"
    if is.command volta; then
        volta install "node@${node_version}"
        volta pin "node@${node_version}"
    else
        nvm.activate
    fi
}

----

==== `nvm.activate`

[source,bash]
----
nvm.activate () 
{ 
    is.an-existing-file .nvmrc && { 
        export node_version=$(cat .nvmrc | tr -d 'v')
        info "Detected node version ${node_version}"
    }
    nvm.load
}

----

==== `nvm.detect`

[source,bash]
----
nvm.detect () 
{ 
    for dir in "${__bashmatic_nvm_dirs[@]}"
    do
        nvm.is-valid-dir "${dir}" && { 
            export NVM_DIR="${dir}"
            source "${NVM_DIR}/nvm.sh"
            return 0
        }
    done
    return 1
}

----

==== `nvm.install`

[source,bash]
----
nvm.install () 
{ 
    h.blue "Installing nvm_.."
    local temp="/tmp/nvm_$$"
    ( curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh 2> /dev/null | bash 2> /dev/null ) | grep NVM_DIR > "${temp}"
    source "${temp}"
    rm -f "${temp}"
    return 0
}

----

==== `nvm.is-valid-dir`

[source,bash]
----
nvm.is-valid-dir () 
{ 
    [[ -z $1 ]] && return 1
    local d="$1"
    [[ -d "${d}" && -s "${d}/nvm.sh" ]]
}

----

==== `nvm.load`

[source,bash]
----
nvm.load () 
{ 
    nvm.detect || nvm.install
    is.a-function nvm || { 
        [[ -s "$NVM_DIR/nvm.sh" ]] && source "$NVM_DIR/nvm.sh"
        [[ -s "$NVM_DIR/bash_completion" ]] && source "$NVM_DIR/bash_completion"
    }
    [[ -f .nvmrc ]] && { 
        nvm use > /dev/null 2>&1 || { 
            h3 "NVM must install Node version $(cat .nvmrc), please wait..."
            run "nvm install && nvm use"
        }
    }
}

----

==== `nvm.use`

[source,bash]
----
nvm.use () 
{ 
    [[ -f .nvmrc ]] || return 1
    is.a-function nvm || nvm.load
    local node_version="$(cat .nvmrc | head -1)"
    info "Activating NodeJS ${bldred}${node_version}..."
    nvm use "${node_version}" && return 0
    warning "No version ${node_version} was detected, installing"
    run.set-next show-output-on
    run "nvm install ${node_version}"
    nvm use "${node_version}" && return 0
    error "Unable to install node version ${node_version}"
    return 1
}

----


=== Module `openssl`

==== `openssl.certs.generate-csr`

[source,bash]
----
openssl.certs.generate-csr () 
{ 
    local domain="${1:-"domain"}"
    local subject="${2:-"${default_certificate_info}"}${domain}"
    local server="${domain/\*/star}"
    hl.desc "Generating CSR + Private Key for domain [${domain}]"
    set -e
    openssl req -new -newkey rsa:4096 -nodes -keyout "${server}.key" -out "${server}.csr" -subj "${subject}"
    pbcopy < "${server}.csr"
    success "CSR is now in the file ${server}.csr and your clipboard."
    set +e
    .openssl.certs.print-generated "${server}.csr" 2> /dev/null
    return 0
}

----


=== Module `osx`

==== `afp.servers`

[source,bash]
----
afp.servers () 
{ 
    osx.local-servers afp
}

----

==== `bashmatic-set-fqdn`

[source,bash]
----
bashmatic-set-fqdn () 
{ 
    osx.set-fqdn "$@"
}

----

==== `bashmatic-term`

[source,bash]
----
bashmatic-term () 
{ 
    open "$(bashmatic-term-program)"
}

----

==== `bashmatic-term-program`

[source,bash]
----
bashmatic-term-program () 
{ 
    if [[ -d /Applications/iTerm.app ]]; then
        printf '%s' /Applications/iTerm.app
    else
        if [[ -d /Applications/Utilities/Terminal.app ]]; then
            printf '%s' /Applications/Utilities/Terminal.app
        else
            printf '%s' "echo 'No TERMINAL application found'"
        fi
    fi
}

----

==== `change-underscan`

[source,bash]
----
change-underscan () 
{ 
    set +
    local amount_percentage="$1"
    if [[ -z "${amount_percentage}" ]]; then
        printf "%s\n\n" "USAGE: change-underscan percent"
        printf "%s\n" "   eg: change-underscan   5  # underscan by 5%"
        printf "%s\n" "   eg: change-underscan -10  # overscan by 10%"
        return -1
    fi
    local file="/var/db/.com.apple.iokit.graphics"
    local backup="/var/db/.com.apple.iokit.graphics.bak.$(date '+%F.%X')"
    local new_value=$(ruby - "puts (10000.0 + 10000.0 * ${amount_percentage}.to_f / 100.0).to_i")
    h1 'This utility allows you to change underscan/overscan' 'on monitors that do not offer that option via GUI.'
    run.ui.ask "Continue?"
    info "Great! First we need to identify your monitor."
    hl.yellow "Please make sure that the external monitor is plugged in."
    run.ui.ask "Is it plugged in?"
    info "Making a backup of your current graphics settings..."
    inf "Please enter your password, if asked: "
    set -
    bash -c 'set -  ; sudo ls -1 > /dev/null; set +  '
    ok
    run "sudo rm -f \"${backup}\""
    export LibRun__AbortOnError=${True}
    run "sudo cp -v \"${file}\" \"${backup}\""
    h2 "Now: please change the resolution ${bldylw}on the problem monitor." "NOTE: it's ${italic}not important what resolution you choose," "as long as it's different than what you had previously..." "Finally: exit Display Preferences once you changed resolution."
    run "open /System/Library/PreferencePanes/Displays.prefPane"
    run.ui.ask "Have you changed the resolution and exited Display Prefs? "
    local line=$(sudo diff "${file}" "${backup}" 2> /dev/null | head -1 | /usr/bin/env ruby -ne 'puts $_.to_i')
    [[ -n ${BASHMATIC_DEBUG} ]] && info "diff line is at ${line}"
    value=
    if [[ "${line}" -gt 0 ]]; then
        line_pscn_key=$(($line - 4))
        line_pscn_value=$(($line - 3))
        ( awk "NR==${line_pscn_key}{print;exit}" "${file}" | grep -q pscn ) && { 
            value=$(awk "NR==${line_pscn_value}{print;exit}" "${file}" | awk 'BEGIN{FS="[<>]"}{print $3}')
            [[ -n ${BASHMATIC_DEBUG} ]] && info "current value is ${value}"
        }
    else
        error "It does not appear that anything changed, sorry."
        return -1
    fi
    h2 "Now, please unplug the problem monitor temporarily..."
    run.ui.ask "...and press Enter to continue "
    if [[ -n ${value} && ${value} -ne ${new_value} ]]; then
        export LibRun__AbortOnError=${True}
        run "sudo sed -i.backup \"${line_pscn_value}s/${value}/${new_value}/g\" \"${file}\""
        echo
        h2 "Congratulations!" "Your display underscan value has been changed."
        info "Previous Value â€” ${bldpur}${value}"
        info "New value:     â€” ${bldgrn}${new_value}"
        hr
        info "${bldylw}IMPORTANT!"
        info "You must restart your computer for the settings to take affect."
        echo
        run.ui.ask "Should I reboot your computer now? "
        info "Very well, rebooting!"
        run "sudo reboot"
    else
        warning "Unable to find the display scan value to change. "
        info "Could it be that you haven't restarted since your last run?"
        echo
        info "Feel free to edit file directly, using:"
        info "eg: ${bldylw}vim ${file} +${line_pscn_value}"
    fi
}

----

==== `cookie-dump`

[source,bash]
----
cookie-dump () 
{ 
    osx.cookie-dump "$@"
}

----

==== `http.servers`

[source,bash]
----
http.servers () 
{ 
    osx.local-servers http
}

----

==== `https.servers`

[source,bash]
----
https.servers () 
{ 
    osx.local-servers https
}

----

==== `osx.app.is-installed`

[source,bash]
----
osx.app.is-installed () 
{ 
    local app="$1"
    shift
    /bin/ls -1 /Applications ~/Applications | grep -E '\.app$' | sort -u | grep "$@" -E -i "${app}|${app/*-/}"
}

----

==== `osx.cookie-dump`

[source,bash]
----
osx.cookie-dump () 
{ 
    local file="$1"
    local tmp
    if [[ ! -s ${file} ]]; then
        tmp=$(mktemp)
        file=${tmp}
        pbpaste > "${file}"
        local size=$(file.size "${file}")
        if [[ ${size} -lt 4 ]]; then
            error "Pasted data is too small to be a valid cookie?"
            info "Here is what we got in your clipboard:\n\n$(cat "${file}")\n"
            return 1
        fi
    fi
    if [[ -s ${file} ]]; then
        cat "${file}" | tr '; ' '\n' | sed '/^$/d' | awk 'BEGIN{FS="="}{printf( "%10d = %s\n", length($2), $1) }' | sort -n
    else
        info "File ${file} does not exist or is empty. "
        info "Copy the value of the ${bldylw}Set-Cookie:${txtblu} header into the clipboard,"
        info "and rerun this function."
    fi
    [[ -z ${tmp} ]] || rm -f "${tmp}"
}

----

==== `osx.detect-cpu`

[source,bash]
----
osx.detect-cpu () 
{ 
    local arch_name="$(uname -m)"
    if [[ "${arch_name}" = "x86_64" ]]; then
        if [[ "$(sysctl -in sysctl.proc_translated)" = "1" ]]; then
            echo m1 rosetta
        else
            echo intel native
        fi
    else
        if [ "${arch_name}" = "arm64" ]; then
            echo m1 native
        else
            echo unknown unknown
        fi
    fi
}

----

==== `osx.dropbox.exclude`

[source,bash]
----
osx.dropbox.exclude () 
{ 
    local dir="$1"
    if [[ -d "${dir}" ]]; then
        xattr -w com.dropbox.ignored 1 "$1"
    else
        error "Folder '${dir}' does not exist or is blank."
        return 1
    fi
}

----

==== `osx.dropbox.exclude-pwd`

[source,bash]
----
osx.dropbox.exclude-pwd () 
{ 
    xattr -w com.dropbox.ignored 1 "${PWD}"
}

----

==== `osx.env-print`

[source,bash]
----
osx.env-print () 
{ 
    local var="$1"
    printf "${bldylw}%20s: ${bldgrn}%s\n" "${var}" "${!var}"
}

----

==== `osx.local-servers`

[source,bash]
----
osx.local-servers () 
{ 
    local protocol="${1:-"ssh"}"
    run.set-next show-output-on
    run "timeout 20 dns-sd -B _${protocol}._tcp ."
}

----

==== `osx.ramdisk.mount`

[source,bash]
----
osx.ramdisk.mount () 
{ 
    local size="${1:-"8"}"
    local diskname="${2:-"ramdisk"}"
    local total=$((size * 2 * 1024))
    util.os
    [[ ${BASHMATIC_OS} != "darwin" ]] && { 
        error "This function only works on OSX"
        return 1
    }
    if [[ "${diskname}" =~ ' ' ]]; then
        error "Disk name can not contain spaces."
        return 1
    fi
    local path="/Volumes/${diskname}"
    if ( mount | ${GrepCommand} -q "/[V]olumes/${diskname}" ); then
        info "Looks like RAM disk already exists at ${path}..."
        return 1
    else
        run.ui.ask "Creating RAM disk sized ${size}Mb at ${path}"
        run.set-next show-output-on
        run "diskutil erasevolume HFS+ '${diskname}' $(hdiutil attach -nomount ram://${total})"
    fi
}

----

==== `osx.ramdisk.unmount`

[source,bash]
----
osx.ramdisk.unmount () 
{ 
    local diskname="${2:-"ramdisk"}"
    [[ $(os.util) != "darwin" ]] && { 
        error "This function only works on OSX"
        return 1
    }
    local path="/Volumes/${diskname}"
    if ( mount | ${GrepCommand} -q "/[V]olumes/${diskname}" ); then
        run.ui.ask "Unmount RAM disk at ${path}? "
        run "umount ${path}"
    else
        info "Couldn't find volume ${bldylw}${path}. Does the RAM disk exist?"
        return 1
    fi
}

----

==== `osx.scutil-print`

[source,bash]
----
osx.scutil-print () 
{ 
    local var="$1"
    printf "${bldylw}%20s: ${bldgrn}%s\n" "${var}" $(sudo scutil --get "${var}" | tr -d '\n')
}

----

==== `osx.set-fqdn`

[source,bash]
----
osx.set-fqdn () 
{ 
    local fqdn="$1"
    local domain=$(echo "${fqdn}" | sed -E 's/^[^.]*\.//g')
    local host=$(echo "${fqdn}" | sed -E 's/\..*//g')
    h1 "Current HostName: ${bldylw}${HOSTNAME}"
    echo
    info "â€¢ You provided the following FQDN : ${bldylw}${fqdn}"
    echo
    info "â€¢ Hostname will be set to: ${bldgrn}${host}"
    info "â€¢ Domain will also change: ${bldgrn}${domain}"
    echo
    run.ui.ask "Does that look correct to you?"
    echo
    inf "Now, please provide your SUDO password, if asked: "
    sudo printf '' || { 
        ui.closer.not-ok:
        exit 1
    }
    ui.closer.ok:
    run "sudo scutil --set HostName ${fqdn}"
    run "sudo scutil --set LocalHostName ${host}.local 2>/dev/null|| true"
    run "sudo scutil --set ComputerName ${host}"
    run "dscacheutil -flushcache"
    echo
    h2 "Result of the changes:"
    osx.scutil-print HostName
    osx.scutil-print LocalHostName
    osx.scutil-print ComputerName
    osx.env-print HOSTNAME
    echo
    hr
}

----

==== `ssh.servers`

[source,bash]
----
ssh.servers () 
{ 
    osx.local-servers ssh
}

----


=== Module `output`

==== `ascii-clean`

[source,bash]
----
ascii-clean () 
{ 
    .output.clean "$@"
}

----

==== `ascii-pipe`

[source,bash]
----
ascii-pipe () 
{ 
    cat | .output.clean.pipe
}

----

==== `bashmatic.set-widget-width-to`

[source,bash]
----
bashmatic.set-widget-width-to () 
{ 
    output.constrain-screen-width "$@"
}

----

==== `center`

[source,bash]
----
center () 
{ 
    .output.center "$@"
}

----

==== `cursor.at.x`

[source,bash]
----
cursor.at.x () 
{ 
    .output.cursor-move-to-x "$@"
}

----

==== `cursor.at.y`

[source,bash]
----
cursor.at.y () 
{ 
    .output.cursor-move-to-y "$@"
}

----

==== `cursor.down`

[source,bash]
----
cursor.down () 
{ 
    .output.cursor-down-by "$@"
}

----

==== `cursor.left`

[source,bash]
----
cursor.left () 
{ 
    .output.cursor-left-by "$@"
}

----

==== `cursor.restore`

[source,bash]
----
cursor.restore () 
{ 
    printf "\e[u"
}

----

==== `cursor.rewind`

[source,bash]
----
cursor.rewind () 
{ 
    local x=${1:-0}
    .output.cursor-move-to-x "${x}"
}

----

==== `cursor.right`

[source,bash]
----
cursor.right () 
{ 
    .output.cursor-right-by "$@"
}

----

==== `cursor.save`

[source,bash]
----
cursor.save () 
{ 
    printf "\e[s"
}

----

==== `cursor.shift.x`

[source,bash]
----
cursor.shift.x () 
{ 
    local shift="$1"
    if [[ "${shift:0:1}" == "-" ]]; then
        .output.cursor-left-by "${shift:1}"
    else
        .output.cursor-right-by "${shift}"
    fi
}

----

==== `cursor.up`

[source,bash]
----
cursor.up () 
{ 
    .output.cursor-up-by "$@"
}

----

==== `duration`

[source,bash]
----
duration () 
{ 
    local millis="$1"
    local exit_code="$2"
    [[ -n $(which bc) ]] || return
    if [[ -n ${millis} && ${millis} -ge 0 ]]; then
        local pattern
        pattern=" %6.6s ms "
        pattern="${txtblu}ã€”${pattern}ã€•"
        printf "${txtblu}${pattern}" "${millis}"
    fi
    if [[ -n ${exit_code} ]]; then
        [[ ${exit_code} -eq 0 ]] && printf " ${txtblk}${bakgrn} %3d ${clr}" "${exit_code}"
        [[ ${exit_code} -gt 0 ]] && printf " ${bldwht}${bakred} %3d ${clr}" "${exit_code}"
    fi
}

----

==== `hr`

[source,bash]
----
hr () 
{ 
    [[ -z "$*" ]] || printf "$*"
    .output.hr
}

----

==== `hr.colored`

[source,bash]
----
hr.colored () 
{ 
    local color="$*"
    [[ -z ${color} ]] && color="${bldred}"
    .output.hr "$(screen-width)" "â€”" "${*}"
}

----

==== `inline.not-ok`

[source,bash]
----
inline.not-ok () 
{ 
    printf " ${txtwht}${bakred} âœ˜ ${clr} "
}

----

==== `inline.ok`

[source,bash]
----
inline.ok () 
{ 
    printf " ${txtblk}${bakgrn} âœ”ï¸Ž ${clr} "
}

----

==== `left`

[source,bash]
----
left () 
{ 
    .output.left-justify "$@"
}

----

==== `left-prefix`

[source,bash]
----
left-prefix () 
{ 
    [[ -z ${LibOutput__LeftPrefix} ]] && { 
        export LibOutput__LeftPrefix=$(.output.replicate-to " " "${LibOutput__LeftPrefixLen}")
    }
    printf "${LibOutput__LeftPrefix}"
}

----

==== `not-ok`

[source,bash]
----
not-ok () 
{ 
    ui.closer.not-ok "$@"
}

----

==== `not-ok:`

[source,bash]
----
not-ok: () 
{ 
    ui.closer.not-ok: "$@"
}

----

==== `ok`

[source,bash]
----
ok () 
{ 
    ui.closer.ok "$@"
}

----

==== `ok:`

[source,bash]
----
ok: () 
{ 
    ui.closer.ok: "$@"
}

----

==== `output.color.off`

[source,bash]
----
output.color.off () 
{ 
    reset-color: 1>&2
    reset-color: 1>&1
}

----

==== `output.color.on`

[source,bash]
----
output.color.on () 
{ 
    printf "${bldred}" 1>&2
    printf "${bldblu}" 1>&1
}

----

==== `output.constrain-screen-width`

[source,bash]
----
output.constrain-screen-width () 
{ 
    export LibOutput__WidthDetectionStrategy="constrained"
    [[ $1 -gt 0 ]] && output.set-max-width "$1"
    [[ $2 -gt 0 ]] && output.set-min-width "$2"
    return 0
}

----

==== `output.has-stdin`

[source,bash]
----
output.has-stdin () 
{ 
    [[ ! -t 0 ]]
}

----

==== `output.is-pipe`

[source,bash]
----
output.is-pipe () 
{ 
    [[ -p /dev/stdout ]]
}

----

==== `output.is-redirect`

[source,bash]
----
output.is-redirect () 
{ 
    [[ ! -t 1 && ! -p /dev/stdout ]]
}

----

==== `output.is-ssh`

[source,bash]
----
output.is-ssh () 
{ 
    [[ -n "${SSH_CLIENT}" || -n "${SSH_CONNECTION}" ]]
}

----

==== `output.is-terminal`

[source,bash]
----
output.is-terminal () 
{ 
    output.is-tty || output.is-redirect || output.is-pipe || output.is-ssh
}

----

==== `output.is-tty`

[source,bash]
----
output.is-tty () 
{ 
    [[ -t 1 ]]
}

----

==== `output.print-at-x-y`

[source,bash]
----
output.print-at-x-y () 
{ 
    local x=$1
    shift
    local y=$1
    shift
    .output.cursor-move-to-x "${x}"
    cursor.up "${y}"
    printf "%s" "$*"
    cursor.down "${y}"
    .output.cursor-move-to-x 0
}

----

==== `output.reset-min-max-width`

[source,bash]
----
output.reset-min-max-width () 
{ 
    export LibOutput__MinWidth=${LibOutput__MinWidth:-${LibOutput__MinWidth__Default}}
    export LibOutput__MaxWidth=${LibOutput__MaxWidth:-${LibOutput__MaxWidth__Default}}
    export LibOutput__MinHeight=${LibOutput__MaxHeight:-${LibOutput__MinHeight__Default}}
}

----

==== `output.screen-height.actual`

[source,bash]
----
output.screen-height.actual () 
{ 
    local h
    case ${BASHMATIC_OS_NAME} in 
        darwin)
            h="$(.output.stty.field rows)"
        ;
        linux)
            h="$(stty -a 2> /dev/null | grep rows | awk '{print $5}' | sedx 's/;//g')"
        ;
        *)
            error "Unsupported OS: ${BASHMATIC_OS_NAME}"
            return 1
        ;
    esac
    printf -- "%d" "${h}"
}

----

==== `output.screen-width.actual`

[source,bash]
----
output.screen-width.actual () 
{ 
    local w
    case "${BASHMATIC_OS_NAME}" in 
        darwin)
            w="$(.output.stty.field columns)"
        ;
        linux)
            w="$(stty -a 2> /dev/null | grep columns | awk '{print $7}' | sedx 's/;//g')"
        ;
        *)
            error "Unsupported OS: ${BASHMATIC_OS_NAME}"
            return 1
        ;
    esac
    printf -- "%d" "${w}"
}

----

==== `output.set-max-width`

[source,bash]
----
output.set-max-width () 
{ 
    [[ $1 -gt 0 ]] && export LibOutput__MaxWidth="$1"
}

----

==== `output.set-min-width`

[source,bash]
----
output.set-min-width () 
{ 
    [[ $1 -gt 0 ]] && export LibOutput__MinWidth="$1"
}

----

==== `output.unconstrain-screen-width`

[source,bash]
----
output.unconstrain-screen-width () 
{ 
    export LibOutput__WidthDetectionStrategy="unconstrained"
    return 0
}

----

==== `screen-height`

[source,bash]
----
screen-height () 
{ 
    .output.screen-height
}

----

==== `screen-width`

[source,bash]
----
screen-width () 
{ 
    .output.screen-width
}

----

==== `screen.height`

[source,bash]
----
screen.height () 
{ 
    .output.screen-height
}

----

==== `screen.height.actual`

[source,bash]
----
screen.height.actual () 
{ 
    .output.screen-height
}

----

==== `screen.width`

[source,bash]
----
screen.width () 
{ 
    .output.screen-width
}

----

==== `screen.width.actual`

[source,bash]
----
screen.width.actual () 
{ 
    .output.current-screen-width.unconstrained
}

----

==== `section`

[source,bash]
----
section () 
{ 
    .output.left-powerline pur "$@"
}

----

==== `stderr`

[source,bash]
----
stderr () 
{ 
    local file=$1
    hl.subtle STDERR
    printf "${txtred}"
    [[ -s ${file} ]] && cat "${file}"
    reset-color
}

----

==== `stdout`

[source,bash]
----
stdout () 
{ 
    local file=$1
    hl.subtle STDOUT
    printf "${clr}"
    [[ -s ${file} ]] && cat "${file}"
    reset-color
}

----

==== `ui.closer.kind-of-ok`

[source,bash]
----
ui.closer.kind-of-ok () 
{ 
    .output.cursor-left-by 1000
    printf " ${bakylw}${bldwht} â– ${clr} "
}

----

==== `ui.closer.kind-of-ok:`

[source,bash]
----
ui.closer.kind-of-ok: () 
{ 
    ui.closer.kind-of-ok "$@"
    echo
}

----

==== `ui.closer.not-ok`

[source,bash]
----
ui.closer.not-ok () 
{ 
    .output.cursor-left-by 1000
    printf " ${bakred}${bldwht} âœ˜ ${clr} "
}

----

==== `ui.closer.not-ok:`

[source,bash]
----
ui.closer.not-ok: () 
{ 
    ui.closer.not-ok "$@"
    echo
}

----

==== `ui.closer.ok`

[source,bash]
----
ui.closer.ok () 
{ 
    .output.cursor-left-by 1000
    printf " ${txtblk}${bakgrn} âœ”ï¸Ž ${clr} "
}

----

==== `ui.closer.ok:`

[source,bash]
----
ui.closer.ok: () 
{ 
    ui.closer.ok "$@"
    echo
}

----


=== Module `output-admonitions`

==== `alert`

[source,bash]
----
alert () 
{ 
    export title_text_color=${bold_yellow}
    export title_border_color=${color_red}
    export title_shadow_color=${bold_red}
    title-box "$@"
}

----

==== `divider`

[source,bash]
----
divider () 
{ 
    divider__ "$@"
    printf "${clr}\n"
}

----

==== `divider.yellow`

[source,bash]
----
divider.yellow () 
{ 
    printf "${clr}\n${txtylw}î‚²"
    divider__ "${txtylw}${bakylw}"
    printf "${clr}${txtylw}î‚°${clr}\n"
}

----

==== `divider__`

[source,bash]
----
divider__ () 
{ 
    local color="${1:-${fg_bright_green}}"
    printf "${color}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${clr}"
}

----

==== `panel-error`

[source,bash]
----
panel-error () 
{ 
    export title_title_color="${bldwht}${bg_blood}"
    export title_text_color="${txtblk}${bg_blood}"
    export title_border_color="${bg_blood}${fg_dark_red}"
    export title_shadow_color="${fg_dark_red}"
    title-panel "$@"
}

----

==== `panel-error-white`

[source,bash]
----
panel-error-white () 
{ 
    export title_text_color="${bg_bright_red}${bldwht}"
    export title_border_color="${bg_bright_red}${bldwht}"
    export title_shadow_color="${fg_dark_red}"
    title-panel "$@"
}

----

==== `panel-error-yellow`

[source,bash]
----
panel-error-yellow () 
{ 
    export title_title_color="${bldwht}${bakred}"
    export title_text_color="${bldylw}${bakred}"
    export title_border_color="${blkylw}${bakred}"
    export title_shadow_color="${fg_dark_red}"
    title-panel "$@"
}

----

==== `panel-info`

[source,bash]
----
panel-info () 
{ 
    export title_text_color="${txtwht}${bg_sky_blue}"
    export title_border_color="${txtblk}${bg_sky_blue}"
    export title_shadow_color="${bldblk}"
    title-panel "$@"
}

----

==== `panel-info-dark`

[source,bash]
----
panel-info-dark () 
{ 
    export title_text_color="${txtblk}${bakcyn}"
    export title_border_color="${txtblk}${bakcyn}"
    export title_shadow_color="${txtblu}"
    title-panel "$@"
}

----

==== `panel-purple-red`

[source,bash]
----
panel-purple-red () 
{ 
    export title_text_color="${bg_pink}${bldwht}"
    export title_border_color="${bg_pink}${bldred}"
    export title_shadow_color="${fg_dark_red}"
    title-panel "$@"
}

----

==== `title`

[source,bash]
----
title () 
{ 
    title-blue "$@"
}

----

==== `title-blue`

[source,bash]
----
title-blue () 
{ 
    export title_text_color="${color_black}${bg_sky_blue}"
    export title_border_color="${bg_sky_blue}"
    export title_shadow_color=${txtblu}
    title-box "$@"
}

----

==== `title-box`

[source,bash]
----
title-box () 
{ 
    local len
    local len_actual
    local width
    local diff
    width=82
    printf "${clr}\n
 ${title_border_color} â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” ${clr}\n"
    for line in "$@"
    do
        len=$(ruby -e "puts '${line}'.size")
        len_actual=$(echo "${line}" | wc -c | tr -d ' ')
        diff=$(( width - len ))
        printf " ${bold}${title_border_color} â”‚  ${title_text_color}%${len_actual}.${len_actual}s${title_border_color}%${diff}.${diff}s${clr}${title_border_color}â”‚ ${clr}${title_shadow_color}â–ˆâ–ˆ${clr}\n" "${line}" " "
    done
    printf " ${title_border_color} â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ ${clr}${title_shadow_color}â–ˆâ–ˆ${clr}
    ${title_shadow_color}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ${clr}
\n"
}

----

==== `title-green`

[source,bash]
----
title-green () 
{ 
    export title_text_color=${color_black}${bakgrn}
    export title_border_color=${fg_bright_green}${bakgrn}
    export title_shadow_color=${fg_deep_green}
    title-box "$@"
}

----

==== `title-panel`

[source,bash]
----
title-panel () 
{ 
    local line="$1"
    shift
    local shadow="${title_shadow_color}â–ˆâ–ˆ${clr}"
    printf "${clr}\n
 ${title_border_color} ${box_top} ${clr}\n"
    .title.line "${shadow}" "${title_title_color:-${title_text_color}}" "${line}"
    printf " ${title_border_color} ${box_divider} ${shadow}\n"
    for line in "$@"
    do
        .title.line "${shadow}" "${title_text_color}" "${line}"
    done
    printf " ${title_border_color} ${box_bottom} ${shadow}\n"
    printf " ${title_shadow_color}   ${box_bottom_shadow}${clr}\n\n"
}

----

==== `title-red`

[source,bash]
----
title-red () 
{ 
    export title_text_color="${txtwht}${bakred}"
    export title_border_color="${bldwht}${bakred}"
    export title_shadow_color="${fg_dark_red}"
    title-box "$@"
}

----

==== `title-yellow`

[source,bash]
----
title-yellow () 
{ 
    export title_text_color="${color_black}${bg_yellow_on_gray}"
    export title_border_color="${bg_yellow_on_gray}"
    export title_shadow_color="${fg_mustard}"
    title-box "$@"
}

----


=== Module `output-boxes`

==== `arrow-right`

[source,bash]
----
arrow-right () 
{ 
    .output.left-as-is "$@"
}

----

==== `arrow.blk-on-blu`

[source,bash]
----
arrow.blk-on-blu () 
{ 
    arrow-right "${bakblu}" "${txtblk}" "$@"
}

----

==== `arrow.blk-on-cyn`

[source,bash]
----
arrow.blk-on-cyn () 
{ 
    arrow-right "${bakcyn}" "${txtblk}" "$@"
}

----

==== `arrow.blk-on-grn`

[source,bash]
----
arrow.blk-on-grn () 
{ 
    arrow-right "${bakgrn}" "${txtblk}" "$@"
}

----

==== `arrow.blk-on-pur`

[source,bash]
----
arrow.blk-on-pur () 
{ 
    arrow-right "${bakpur}" "${txtblk}" "$@"
}

----

==== `arrow.blk-on-red`

[source,bash]
----
arrow.blk-on-red () 
{ 
    arrow-right "${bakred}" "${txtblk}" "$@"
}

----

==== `arrow.blk-on-wht`

[source,bash]
----
arrow.blk-on-wht () 
{ 
    arrow-right "${bakwht}" "${txtblk}" "$@"
}

----

==== `arrow.blk-on-ylw`

[source,bash]
----
arrow.blk-on-ylw () 
{ 
    arrow-right "${bakylw}" "${txtblk}" "$@"
}

----

==== `arrow.wht-on-blk`

[source,bash]
----
arrow.wht-on-blk () 
{ 
    arrow-right "${bakblk}" "${txtwht}" "$@"
}

----

==== `arrow.wht-on-blu`

[source,bash]
----
arrow.wht-on-blu () 
{ 
    arrow-right "${bakblu}" "${txtwht}" "$@"
}

----

==== `arrow.wht-on-cyn`

[source,bash]
----
arrow.wht-on-cyn () 
{ 
    arrow-right "${bakcyn}" "${txtwht}" "$@"
}

----

==== `arrow.wht-on-grn`

[source,bash]
----
arrow.wht-on-grn () 
{ 
    arrow-right "${bakgrn}" "${txtwht}" "$@"
}

----

==== `arrow.wht-on-pur`

[source,bash]
----
arrow.wht-on-pur () 
{ 
    arrow-right "${bakpur}" "${txtwht}" "$@"
}

----

==== `arrow.wht-on-red`

[source,bash]
----
arrow.wht-on-red () 
{ 
    arrow-right "${bakred}" "${txtwht}" "$@"
}

----

==== `arrow.wht-on-ylw`

[source,bash]
----
arrow.wht-on-ylw () 
{ 
    arrow-right "${bakylw}" "${txtwht}" "$@"
}

----

==== `attention`

[source,bash]
----
attention () 
{ 
    .output.left-powerline blu 65 "${txtwht}${bakblu}  $*  "
}

----

==== `box.black-on-blue`

[source,bash]
----
box.black-on-blue () 
{ 
    .output.box "${txtblk}${bakblu}" "${bakblu}" "$@"
}

----

==== `box.black-on-green`

[source,bash]
----
box.black-on-green () 
{ 
    .output.box "${txtblk}${bakgrn}" "${bakgrn}" "$@"
}

----

==== `box.black-on-purple`

[source,bash]
----
box.black-on-purple () 
{ 
    .output.box "${txtblk}${bakpur}" "${bakpur}" "$@"
}

----

==== `box.black-on-red`

[source,bash]
----
box.black-on-red () 
{ 
    .output.box "${txtblk}${bakred}" "${bakred}" "$@"
}

----

==== `box.black-on-yellow`

[source,bash]
----
box.black-on-yellow () 
{ 
    .output.box "${txtblk}${bakylw}" "${txtblk}${bakylw}" "$@"
}

----

==== `box.blue-in-green`

[source,bash]
----
box.blue-in-green () 
{ 
    .output.box "${bldblu}" "${bldgrn}" "$@"
}

----

==== `box.blue-in-yellow`

[source,bash]
----
box.blue-in-yellow () 
{ 
    .output.box "${bldylw}" "${bldblu}" "$@"
}

----

==== `box.green-in-cyan`

[source,bash]
----
box.green-in-cyan () 
{ 
    .output.box "${bldgrn}" "${bldcyn}" "$@"
}

----

==== `box.green-in-green`

[source,bash]
----
box.green-in-green () 
{ 
    .output.box "${bldgrn}" "${bldgrn}" "$@"
}

----

==== `box.green-in-magenta`

[source,bash]
----
box.green-in-magenta () 
{ 
    .output.box "${bldgrn}" "${bldpur}" "$@"
}

----

==== `box.green-in-yellow`

[source,bash]
----
box.green-in-yellow () 
{ 
    .output.box "${bldgrn}" "${bldylw}" "$@"
}

----

==== `box.magenta-in-blue`

[source,bash]
----
box.magenta-in-blue () 
{ 
    .output.box "${bldblu}" "${bldpur}" "$@"
}

----

==== `box.magenta-in-green`

[source,bash]
----
box.magenta-in-green () 
{ 
    .output.box "${bldpur}" "${bldgrn}" "$@"
}

----

==== `box.red-in-magenta`

[source,bash]
----
box.red-in-magenta () 
{ 
    .output.box "${bldred}" "${bldpur}" "$@"
}

----

==== `box.red-in-red`

[source,bash]
----
box.red-in-red () 
{ 
    .output.box "${txtred}" "${txtred}" "$@"
}

----

==== `box.red-in-yellow`

[source,bash]
----
box.red-in-yellow () 
{ 
    .output.box "${bldred}" "${bldylw}" "$@"
}

----

==== `box.white-on-blue`

[source,bash]
----
box.white-on-blue () 
{ 
    .output.box "${bakblu}${bldwht}" "${bakblu}${bldwht}" "$@"
}

----

==== `box.white-on-green`

[source,bash]
----
box.white-on-green () 
{ 
    .output.box "${bakgrn}${bldwht}" "${bakgrn}${bldwht}" "$@"
}

----

==== `box.white-on-red`

[source,bash]
----
box.white-on-red () 
{ 
    .output.box "${bakred}${bldwht}" "${bakred}${bldwht}" "$@"
}

----

==== `box.yellow-in-blue`

[source,bash]
----
box.yellow-in-blue () 
{ 
    .output.box "${bldylw}" "${bldblu}" "$@"
}

----

==== `box.yellow-in-red`

[source,bash]
----
box.yellow-in-red () 
{ 
    .output.box "${bldred}" "${bldylw}" "$@"
}

----

==== `box.yellow-in-yellow`

[source,bash]
----
box.yellow-in-yellow () 
{ 
    .output.box "${bldylw}" "${txtylw}" "$@"
}

----

==== `box.yellow-on-green`

[source,bash]
----
box.yellow-on-green () 
{ 
    .output.box "${bakgrn}${bldwht}" "${bakgrn}${bldylw}" "$@"
}

----

==== `box.yellow-on-purple`

[source,bash]
----
box.yellow-on-purple () 
{ 
    .output.box "${bakpur}" "${bldylw}" "$@"
}

----

==== `h.black`

[source,bash]
----
h.black () 
{ 
    center "${bldylw}${bakblk}" "$@"
}

----

==== `h.blue`

[source,bash]
----
h.blue () 
{ 
    center "${txtblk}${bakblu}" "$@"
}

----

==== `h.e`

[source,bash]
----
h.e () 
{ 
    .output.box "${bakred}${txtblk}" "${bakred}" "$@"
}

----

==== `h.green`

[source,bash]
----
h.green () 
{ 
    center "${txtblk}${bakgrn}" "$@"
}

----

==== `h.orange`

[source,bash]
----
h.orange () 
{ 
    left "${white_on_orange}" "$@"
}

----

==== `h.orange-center`

[source,bash]
----
h.orange-center () 
{ 
    center "${white_on_orange}" "$@"
}

----

==== `h.red`

[source,bash]
----
h.red () 
{ 
    center "${txtblk}${bakred}" "$@"
}

----

==== `h.salmon`

[source,bash]
----
h.salmon () 
{ 
    left "${white_on_salmon}" "$@"
}

----

==== `h.salmon-center`

[source,bash]
----
h.salmon-center () 
{ 
    center "${white_on_salmon}" "$@"
}

----

==== `h.salmon-center-black`

[source,bash]
----
h.salmon-center-black () 
{ 
    center "${black_on_salmon}" "$@"
}

----

==== `h.yellow`

[source,bash]
----
h.yellow () 
{ 
    center "${txtblk}${bakylw}" "$@"
}

----

==== `h.yellow-center-black`

[source,bash]
----
h.yellow-center-black () 
{ 
    center "${black_on_yellow}" "$@"
}

----

==== `h1`

[source,bash]
----
h1 () 
{ 
    box.blue-in-yellow "$@"
}

----

==== `h1.blue`

[source,bash]
----
h1.blue () 
{ 
    h1bg "${@}"
}

----

==== `h1.green`

[source,bash]
----
h1.green () 
{ 
    box.green-in-magenta "$@"
}

----

==== `h1.purple`

[source,bash]
----
h1.purple () 
{ 
    box.magenta-in-green "$@"
}

----

==== `h1.red`

[source,bash]
----
h1.red () 
{ 
    box.red-in-red "$@"
}

----

==== `h1.yellow`

[source,bash]
----
h1.yellow () 
{ 
    box.yellow-in-red "$@"
}

----

==== `h1bg`

[source,bash]
----
h1bg () 
{ 
    box.white-on-blue "$@"
}

----

==== `h2`

[source,bash]
----
h2 () 
{ 
    box.blue-in-green "$@"
}

----

==== `h2.green`

[source,bash]
----
h2.green () 
{ 
    h2bg "${@}"
}

----

==== `h2bg`

[source,bash]
----
h2bg () 
{ 
    box.black-on-green "$@"
}

----

==== `h3`

[source,bash]
----
h3 () 
{ 
    box.magenta-in-green "$@"
}

----

==== `h3.yellow`

[source,bash]
----
h3.yellow () 
{ 
    h3bg "${@}"
}

----

==== `h3bg`

[source,bash]
----
h3bg () 
{ 
    box.black-on-yellow "$@"
}

----

==== `h4`

[source,bash]
----
h4 () 
{ 
    section.blue "$@"
}

----

==== `h4.red`

[source,bash]
----
h4.red () 
{ 
    h4bg "${@}"
}

----

==== `h4bg`

[source,bash]
----
h4bg () 
{ 
    box.white-on-blue "$@"
}

----

==== `h5`

[source,bash]
----
h5 () 
{ 
    section.green "$@"
}

----

==== `h5bg`

[source,bash]
----
h5bg () 
{ 
    box.yellow-on-green "$@"
}

----

==== `h6`

[source,bash]
----
h6 () 
{ 
    section.yellow "$@"
}

----

==== `h7`

[source,bash]
----
h7 () 
{ 
    section.salmon "$@"
}

----

==== `h8`

[source,bash]
----
h8 () 
{ 
    section.cyan "$@"
}

----

==== `hdr`

[source,bash]
----
hdr () 
{ 
    h1 "$@"
}

----

==== `hl.blue`

[source,bash]
----
hl.blue () 
{ 
    left "${bldwht}${bakpur}" "$@"
}

----

==== `hl.desc`

[source,bash]
----
hl.desc () 
{ 
    left "${bakylw}${txtblk}${bakylw}" "$@"
}

----

==== `hl.green`

[source,bash]
----
hl.green () 
{ 
    left "${txtblk}${bakgrn}" "$@"
}

----

==== `hl.subtle`

[source,bash]
----
hl.subtle () 
{ 
    left "${bldwht}${bakblk}${underlined}" "$@"
}

----

==== `hl.yellow`

[source,bash]
----
hl.yellow () 
{ 
    left "${txtblk}${bakylw}" "$@"
}

----

==== `hl.yellow-on-black`

[source,bash]
----
hl.yellow-on-black () 
{ 
    left "${yellow_on_black}" "$@"
}

----

==== `hl.yellow-on-gray`

[source,bash]
----
hl.yellow-on-gray () 
{ 
    left "${yellow_on_gray}" "$@"
}

----

==== `notice`

[source,bash]
----
notice () 
{ 
    .output.left-powerline ylw 65 "${itablk}${bakylw} $*  "
}

----

==== `section.blue`

[source,bash]
----
section.blue () 
{ 
    .output.left-powerline blu "$@"
}

----

==== `section.cyan`

[source,bash]
----
section.cyan () 
{ 
    .output.left-powerline cyn "$@"
}

----

==== `section.gray`

[source,bash]
----
section.gray () 
{ 
    .output.left-powerline blk "$@"
}

----

==== `section.gray-yellow`

[source,bash]
----
section.gray-yellow () 
{ 
    section.gray "${bldylw}${bakblk}$*"
}

----

==== `section.green`

[source,bash]
----
section.green () 
{ 
    .output.left-powerline grn "$@"
}

----

==== `section.purple`

[source,bash]
----
section.purple () 
{ 
    .output.left-powerline pur "$@"
}

----

==== `section.red`

[source,bash]
----
section.red () 
{ 
    .output.left-powerline red "$@"
}

----

==== `section.salmon`

[source,bash]
----
section.salmon () 
{ 
    .output.left-powerline wht 65 "${txtwht}${white_on_salmon}  $*  "
}

----

==== `section.white`

[source,bash]
----
section.white () 
{ 
    .output.left-powerline wht "$@"
}

----

==== `section.yellow`

[source,bash]
----
section.yellow () 
{ 
    .output.left-powerline ylw "$@"
}

----

==== `status.failed`

[source,bash]
----
status.failed () 
{ 
    cursor.right 5
    section.red "       $*"
    cursor.up 2
    not-ok:
    cursor.down 2
}

----

==== `status.ok`

[source,bash]
----
status.ok () 
{ 
    cursor.right 5
    section.cyan "       $*"
    cursor.up 2
    ok:
    cursor.down 2
}

----


=== Module `output-repeat-char`


=== Module `output-utils`

==== `abort`

[source,bash]
----
abort () 
{ 
    echo
    printf -- "${LibOutput__LeftPrefix}${txtblk}${bakred}  Â« ABORT Â»  ${clr} ${bldwht} âœ”  ${bldgrn}$*${clr}" 1>&2
    echo
}

----

==== `ask`

[source,bash]
----
ask () 
{ 
    printf -- "%s${txtylw}$*${clr}\n" "${LibOutput__LeftPrefix}"
    printf -- "%s${bldgrn}â¯ ${bldylw}" "${LibOutput__LeftPrefix}"
}

----

==== `br`

[source,bash]
----
br () 
{ 
    echo
}

----

==== `columnize`

[source,bash]
----
columnize () 
{ 
    local columns="${1:-2}"
    [[ -n $1 ]] && shift
    local sw="${2:-$(screen.width.actual)}"
    [[ ${sw} -lt 90 ]] && sw=100
    pr -l 10000 -"${columns}" -e4 -w ${sw} | expand -8 | sed -E '/^ *$/d' | grep -v 'Page '
}

----

==== `dbg`

[source,bash]
----
dbg () 
{ 
    is-dbg && printf "     ${txtgrn}[DEBUG | ${txtylw}$(time.now.with-ms)${txtgrn}]  ${txtblu}$(txt-info)$*\n" 1>&2
    return 0
}

----

==== `dbg-off`

[source,bash]
----
dbg-off () 
{ 
    unset BASHMATIC_DEBUG
    unset BASHMATIC_PATH_DEBUG
    [[ -f ${BASHMATIC_HOME}/.envrc.no-debug ]] && source "${BASHMATIC_HOME}"/.envrc.no-debug
}

----

==== `dbg-on`

[source,bash]
----
dbg-on () 
{ 
    export BASHMATIC_DEBUG=1
    [[ -f ${BASHMATIC_HOME}/.envrc.debug ]] && source "${BASHMATIC_HOME}"/.envrc.debug
}

----

==== `dbgf`

[source,bash]
----
dbgf () 
{ 
    local func="$1"
    shift
    is.a-function "${func}" || { 
        error "${func} is not a function"
        return 1
    }
    dbg "${func}(" "$@" ")"
    ${func} "$@"
    local code=$?
    is-dbg || return "${code}"
    cursor.up 1
    cursor.at.x 0
    if [[ ${code} -eq 0 ]]; then
        ok:
    else
        not-ok:
    fi
    return ${code}
}

----

==== `err`

[source,bash]
----
err () 
{ 
    echo
    printf -- "${LibOutput__LeftPrefix}${bldylw}${bakred}  Â« ERROR! Â»  ${clr} ${bldwht}$*${clr}" 1>&2
    echo
}

----

==== `error`

[source,bash]
----
error () 
{ 
    panel-error "ERROR" "$@"
}

----

==== `error-title`

[source,bash]
----
error-title () 
{ 
    title-red "$(printf "%60.60s" "â”€â”€â”€â”€ ERROR â”€â”€â”€")" "$@"
}

----

==== `error:`

[source,bash]
----
error: () 
{ 
    err "$*"
    ui.closer.not-ok:
}

----

==== `fatal`

[source,bash]
----
fatal () 
{ 
    header=$(printf -- "${clr}${bldwht}  Â« ABORT Â» ")
    box.black-on-red "${header} ${clr}${txtblk}${bakred} â€” $1" "${@:2}" 1>&2
    exit 1
}

----

==== `inf`

[source,bash]
----
inf () 
{ 
    printf -- "${LibOutput__LeftPrefix}${clr}${txtcyn}$*${clr}"
}

----

==== `info`

[source,bash]
----
info () 
{ 
    inf "$@"
    echo
}

----

==== `info-debug`

[source,bash]
----
info-debug () 
{ 
    [[ -z ${BASHMATIC_DEBUG} ]] && return
    printf -- "${LibOutput__LeftPrefix}${bakpur}[ debug ] $*  ${clr}\n"
}

----

==== `info:`

[source,bash]
----
info: () 
{ 
    inf "$*"
    ui.closer.ok:
}

----

==== `is-dbg`

[source,bash]
----
is-dbg () 
{ 
    [[ -n ${BASHMATIC_DEBUG} ]]
}

----

==== `note`

[source,bash]
----
note () 
{ 
    printf -- "\n${bldwht}${bakblu}  Â« NOTE Â»  ${clr} ${bldwht} âœ”  ${bldgrn}$*${clr}" 1>&2
    printf -- "\n\n" 1>&2
}

----

==== `okay`

[source,bash]
----
okay () 
{ 
    printf -- " ${txtblk}${bakgrn} âœ“ ${clr}   â¯ ${clr}${italic}${bldcyn}$*${clr} â¯ ${bldgrn} ALL GOOD, YO ðŸ‘  ${clr}" 1>&2
    echo
}

----

==== `puts`

[source,bash]
----
puts () 
{ 
    printf "  â‡¨ ${txtwht}$*${clr}"
}

----

==== `reset-color`

[source,bash]
----
reset-color () 
{ 
    echo -en "${clr}"
}

----

==== `reset-color:`

[source,bash]
----
reset-color: () 
{ 
    printf "${clr}"
}

----

==== `shutdown`

[source,bash]
----
shutdown () 
{ 
    local message=${1:-"Shutting down..."}
    echo
    box.red-in-red "${message}"
    echo
    exit 1
}

----

==== `skipping`

[source,bash]
----
skipping () 
{ 
    printf -- "\n${bldwht}${bakcyn}  Â« SKIPPING Â»  ${clr} ${bldwht} âœ”  ${bldgrn}$*${clr}" 1>&2
    printf -- "\n\n" 1>&2
}

----

==== `success`

[source,bash]
----
success () 
{ 
    printf -- "\n${txtblk}${bakgrn}  Â« SUCCESS Â»  ${clr} ${bldwht} âœ”  ${bldgrn}$*${clr}" 1>&2
    printf -- "\n\n" 1>&2
}

----

==== `warn`

[source,bash]
----
warn () 
{ 
    printf -- "${LibOutput__LeftPrefix}${bldwht}${bakylw} Â« WARNING! Â» ${clr} ${bldylw}$*${clr}" 1>&2
}

----

==== `warning`

[source,bash]
----
warning () 
{ 
    local first="$1"
    shift
    box.black-on-yellow "${header} ${clr}${txtblk}${bakylw} â€” $first" "$@" 1>&2
}

----

==== `warning:`

[source,bash]
----
warning: () 
{ 
    warn "$*"
    ui.closer.kind-of-ok:
}

----


=== Module `package`

==== `package.ensure.commmand-available`

[source,bash]
----
package.ensure.commmand-available () 
{ 
    local package="$1"
    shift
    local binary="$1"
    shift
    is.a-command "${binary}" && return 0
    package.ensure.is-installed "${package}"
    hash -r > /dev/null 2>&1
    is.a-command "${binary}" && return 0
    error "After installing package ${package}, binary ${binary} still is not found."
}

----

==== `package.ensure.is-installed`

[source,bash]
----
package.ensure.is-installed () 
{ 
    for pkg in "$@"
    do
        package.is-installed "${pkg}" || package.install
        package.is-installed "${pkg}" || { 
            error "Package ${pkg} does not appear installed, broken package or version?"
            return 1
        }
    done
}

----


=== Module `path`

==== `PATH.uniqify`

[source,bash]
----
PATH.uniqify () 
{ 
    local _p="$(printf "${PATH}" | sed 's/:/\n/g' | uniq | tr '\n' ':')"
    [[ "${_p}" == "${PATH}" ]] || export PATH="${_p}"
}

----

==== `PATH_add`

[source,bash]
----
PATH_add () 
{ 
    path.mutate.append "$@"
}

----

==== `path.absolute`

[source,bash]
----
path.absolute () 
{ 
    if [[ -d "$1" ]]; then
        pushd "$1" > /dev/null || exit
        pwd
        popd > /dev/null || exit
    else
        if [[ -e "$1" ]]; then
            pushd "$(dirname "$1")" > /dev/null || exit
            echo "$(pwd)/$(basename "$1")"
            popd > /dev/null || exit
        else
            echo "$1" does not exist! 1>&2
            return 127
        fi
    fi
}

----

==== `path.append`

[source,bash]
----
path.append () 
{ 
    local new_path="${PATH}"
    for __path in "$@"
    do
        is.a-directory "${__path}" || { 
            error "Argument ${__path} is not a valid directory, abort." 1>&2
            return 1
        }
        path.dirs.uniq | grep -q -E "^${__path}\$" && continue
        new_path="${new_path}:${__path}"
    done
    echo "${new_path}"
}

----

==== `path.dirs`

[source,bash]
----
path.dirs () 
{ 
    local path
    if output.has-stdin; then
        while IFS= read -r line; do
            path="${path}:${line}"
        done
    fi
    [[ -z "${path}" ]] && path="${1:-${PATH}}"
    echo "${path//:/'
'}" | /usr/bin/tr -d "'" | sedx '/^$/d; s/://g'
}

----

==== `path.dirs.delete`

[source,bash]
----
path.dirs.delete () 
{ 
    local path="$1"
    shift
    local opath=""
    for p in "$@"
    do
        opath="${path}"
        path="$(eval "echo '${path}' | sedx 's#:${p}:#:#g'")"
        [[ ${path} == "${opath}" ]] && path="$(eval "echo '${path}' | sedx 's#(^|:|$)${p}(:|^|$)##g'")"
        is-dbg && dbg "path=${path} after removing ${p}"
    done
    echo "${path}"
    return
}

----

==== `path.dirs.join`

[source,bash]
----
path.dirs.join () 
{ 
    sedx 's/$/:/g' | tr -d '\n'
}

----

==== `path.dirs.size`

[source,bash]
----
path.dirs.size () 
{ 
    path.dirs "$@" | /usr/bin/wc -l | /usr/bin/tr -d ' '
}

----

==== `path.dirs.sort`

[source,bash]
----
path.dirs.sort () 
{ 
    path.dirs.uniq "$@" | sort
}

----

==== `path.dirs.sort-rev`

[source,bash]
----
path.dirs.sort-rev () 
{ 
    path.dirs.uniq "$@" | sort -r
}

----

==== `path.dirs.uniq`

[source,bash]
----
path.dirs.uniq () 
{ 
    local -a paths=($(path.dirs "$@"))
    for path in $(array.uniq "${paths[@]}")
    do
        echo "${path}"
    done | sort
}

----

==== `path.mutate.append`

[source,bash]
----
path.mutate.append () 
{ 
    export PATH="$(path.append "$@")"
}

----

==== `path.mutate.delete`

[source,bash]
----
path.mutate.delete () 
{ 
    export PATH="$(path.dirs.delete "$@")"
}

----

==== `path.mutate.prepend`

[source,bash]
----
path.mutate.prepend () 
{ 
    export PATH="$(path.prepend "$@")"
}

----

==== `path.mutate.uniq`

[source,bash]
----
path.mutate.uniq () 
{ 
    export PATH="$(path.uniq "$@")"
}

----

==== `path.prepend`

[source,bash]
----
path.prepend () 
{ 
    local new_path="${PATH}"
    for __path in "$@"
    do
        is.a-directory "${__path}" || { 
            error "Argument ${__path} is not a valid directory, abort." 1>&2
            return 1
        }
        local p="$(path.dirs.uniq | grep -v -E "^${__path}\$" | tr '\n' ':')"
        new_path="${__path}:${p}"
    done
    echo "${new_path}"
}

----

==== `path.strip-slash`

[source,bash]
----
path.strip-slash () 
{ 
    local path="$(echo "$1" | sed -E 's#\/+$##g')"
    printf -- "%s" "${path}"
}

----

==== `path.uniq`

[source,bash]
----
path.uniq () 
{ 
    array.join ':' $(path.dirs.uniq "$@")
}

----


=== Module `pdf`

==== `pdf.combine`

[source,bash]
----
pdf.combine () 
{ 
    local merged="${1}"
    shift
    local files=""
    for f in "$@"
    do
        [[ -f "${f}" ]] && { 
            info "Appending file ${bldylw}${f}"
            files="${files} '${f}'"
        }
    done
    [[ -s "${merged}" ]] && { 
        warning "Merged file ${merged} already exists, removing..."
        run "rm -f \"${merged}\""
    }
    unalias gs 2> /dev/null
    [[ -n $(command -V gs) ]] || brew.install.package gs
    run "mkdir -p $(dirname "${merged}")"
    info "Please wait while GhostScript combines your PDFs into"
    info "destination file: ${bldylw}${merged}"
    run "gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=${merged} ${files}"
    return "${LibRun__LastExitCode}"
}

----


=== Module `pg`

==== `pg.is-running`

[source,bash]
----
pg.is-running () 
{ 
    [[ $(/bin/ps -ef | grep -c '[p]ostgres:') -gt 4 ]]
}

----

==== `pg.running.data-dirs`

[source,bash]
----
pg.running.data-dirs () 
{ 
    ps -eo 'args' | $(which grep) '[p]ostgres.*-D' | awk 'BEGIN{FS="-D"}{print $2}' | awk '{print $1}' | sort
}

----

==== `pg.running.server-binaries`

[source,bash]
----
pg.running.server-binaries () 
{ 
    ps -eo 'args' | $(which grep) '[p]ostgres.*-D' | awk '{print $1}' | sort
}

----

==== `pg.server-in-path.version`

[source,bash]
----
pg.server-in-path.version () 
{ 
    is.command postgres || return 1
    $(which postgres) -V | sed -E 's/[^0-9.]//g;s/\..*$//g'
}

----


=== Module `pids`

==== `pall`

[source,bash]
----
pall () 
{ 
    pids.all "$@"
}

----

==== `pid.alive`

[source,bash]
----
pid.alive () 
{ 
    local pid="$1"
    [[ -z ${pid} ]] && { 
        error "usage: pid.alive PID"
        return 1
    }
    is.numeric "${pid}" || { 
        error "The argument to pid.alive() must be a numeric Process ID"
        return 1
    }
    [[ -n "${pid}" && -n $(ps -p "${pid}" | grep -v TTY) ]]
}

----

==== `pid.sig`

[source,bash]
----
pid.sig () 
{ 
    local pid="${1}"
    shift
    local signal="${1}"
    shift
    [[ -z "${pid}" || -z "${signal}" ]] && { 
        printf "
USAGE:
  pid.sig pid signal
"
        return 1
    }
    is.numeric "${pid}" || { 
        error "First argument to pid.sig must be numeric."
        return 1
    }
    is.numeric "${signal}" || sig.is-valid "${signal}" || { 
        error "First argument to pid.sig must be numeric."
        return 1
    }
    if pid.alive "${pid}"; then
        info "sending ${bldred}${signal}$(txt-info) to ${bldylw}${pid}..."
        /bin/kill -s "${signal}" "${pid}" 2>&1 | cat > /dev/null
    else
        warning "pid ${pid} was dead by the time we tried sending ${sig} to it."
        return 1
    fi
}

----

==== `pid.stop`

[source,bash]
----
pid.stop () 
{ 
    local pid=${1}
    shift
    local delay=${1:-"0.3"}
    shift
    if [[ -z ${pid} ]]; then
        printf "
DESCRIPTION:
  If the given PID is active, first sends kill -TERM, waits a bit,
  then sends kill -9.

USAGE:
  ${bldgrn}pid.stop pid${clr}

EXAMPLES:
  # stop all sidekiqs, waiting half a sec in between
  ${bldgrn}pid.stop sidekiq 0.5${clr}
"
        return 1
    fi
    pid.alive "${pid}" && ( pid.sig "${pid}" "TERM" || true ) && sleep "${delay}"
    pid.alive "${pid}" && pid.sig "${pid}" "KILL"
}

----

==== `pid.stop-and-kill`

[source,bash]
----
pid.stop-and-kill () 
{ 
    local pid="$1"
    delta=1
    sig=STOP
    while true; do
        pid.alive "$pid" || return 0
        kill -${sig} "${pid}" 2>&1 > /dev/null
        delta=$((delta * 2))
        [[ ${delta} -gt 16 ]] && sig="KILL"
        sleep "0.${delta}"
    done
    pid.alive "$pid" && { 
        error "PID ${pid} is miraculously still alive..." 1>&2
        return 1
    }
}

----

==== `pid.stop-if-listening-on-port`

[source,bash]
----
pid.stop-if-listening-on-port () 
{ 
    local port="$1"
    local protocol="${2:-"tcp"}"
    local -a pids
    pids=($(lsof -i "${protocol}":"${port}" | grep -v PID | awk '{print $2}'))
    local pids_string="${pids[*]}"
    if [[ ${#pids[@]} -eq 0 ]]; then
        return 0
    else
        info "Found ${#pids[@]} processes attached to port ${port}/${protocol}."
        info "Process IDs attached to ${bldcyn}${port}/${protocol}: ${bldylw}${pids_string/ /, }"
    fi
    pids.stop "${pids[@]}"
}

----

==== `pids-with-args`

[source,bash]
----
pids-with-args () 
{ 
    local -a permitted=("%cpu" "%mem" acflag acflg args blocked caught comm command cpu cputime etime f flags gid group ignored inblk inblock jobc ktrace ktracep lim login logname lstart majflt minflt msgrcv msgsnd ni nice nivcsw nsignals nsigs nswap nvcsw nwchan oublk oublock p_ru paddr pagein pcpu pending pgid pid pmem ppid pri pstime putime re rgid rgroup rss ruid ruser sess sig sigmask sl start stat state stime svgid svuid tdev time tpgid tsess tsiz tt tty ucomm uid upr user usrpri utime vsize vsz wchan wq wqb wql wqr xstat)
    local -a additional=()
    local -a matching=()
    for arg in $@
    do
        array.includes "${arg}" "${permitted[@]}" && additional=(${additional[@]} $arg) && continue
        matching=("${matching[@]}" "${arg}")
    done
    local columns="pid,ppid,user,%cpu,%mem,command"
    if [[ ${#additional[@]} -gt 0 ]]; then
        columns="${columns},$(array.join ',' "${additional[@]}")"
    fi
    pids.matching.regexp "${matching[*]}" | xargs /bin/ps -www -o"${columns}" -p
}

----

==== `pids.all`

[source,bash]
----
pids.all () 
{ 
    if [[ -z "${1}" ]]; then
        printf "
DESCRIPTION:
  prints processes matching a given pattern

USAGE:
  ${bldgrn}pids.all pattern${clr}

EXAMPLES:
  ${bldgrn}pids.all puma${clr}
"
        return 0
    fi
    local pattern="$(pids.normalize.search-string "$1")"
    shift
    ps -ef | ${GrepCommand} "${pattern}" | ${GrepCommand} -v grep
}

----

==== `pids.for-each`

[source,bash]
----
pids.for-each () 
{ 
    if [[ -z "${1}" || -z "${2}" ]]; then
        printf "
DESCRIPTION:
  loops over matching PIDs and calls a named BASH function

USAGE:
  ${bldgrn}pids.for-each pattern function${clr}

EXAMPLES:
  ${bldgrn}pids.for-each puma echo
  function hup() { kill -HUP \$1; }; pids.for-each sidekiq hup${clr}
"
        return 0
    fi
    local pattern="$(pids.normalize.search-string "$1")"
    shift
    local func=${1:-"echo"}
    if [[ -z $(which "${func}") && -z $(type "${func}" 2> /dev/null) ]]; then
        errror "Function ${func} does not exist."
        return 1
    fi
    while true; do
        local -a pids=($(pids.matching "${pattern}"))
        [[ ${#pids[@]} == 0 ]] && break
        eval "${func} ${pids[0]}"
        sleep 0.1
    done
}

----

==== `pids.matching`

[source,bash]
----
pids.matching () 
{ 
    local pattern="${1}"
    if [[ -z "${pattern}" ]]; then
        printf "
DESCRIPTION:
  Finds process IDs matching a given string.

USAGE:
  ${bldgrn}pids.matching string${clr}

EXAMPLES:
  ${bldgrn}pids.matching sidekiq${clr}
"
        return 0
    fi
    pattern="$(pids.normalize.search-string "${pattern}")"
    pids.matching.regexp "${pattern}"
}

----

==== `pids.matching.regexp`

[source,bash]
----
pids.matching.regexp () 
{ 
    local pattern="${1}"
    if [[ -z "${pattern}" ]]; then
        printf "
DESCRIPTION:
  Finds process IDs matching a given regexp.

USAGE:
  ${bldgrn}pids.matching regular-expression${clr}

EXAMPLES:
  ${bldgrn}pids.matching '[s]idekiq\s+' ${clr}
"
        return 0
    fi
    ps -ef | ${GrepCommand} "${pattern}" | ${GrepCommand} -v grep | awk '{print $2}' | sort -n
}

----

==== `pids.normalize.search-string`

[source,bash]
----
pids.normalize.search-string () 
{ 
    local pattern="$*"
    [[ "${pattern:0:1}" == '[' ]] || pattern="[${pattern:0:1}]${pattern:1}"
    printf "${pattern}"
}

----

==== `pids.stop`

[source,bash]
----
pids.stop () 
{ 
    if [[ -z "${1}" ]]; then
        printf "
DESCRIPTION:
  finds and stops IDs matching a given pattern

USAGE:
  ${bldgrn}pids.stop <pattern>${clr}
  ${bldgrn}pids.stop pid pid ... >${clr}

EXAMPLES:
  ${bldgrn}pids.stop puma${clr}
"
        return 0
    fi
    for pid in $@
    do
        if is.numeric "${pid}"; then
            pid.stop "${pid}"
        else
            pids.for-each "${pid}" "pid.stop"
        fi
    done
}

----

==== `pids.stop-by-listen-tcp-ports`

[source,bash]
----
pids.stop-by-listen-tcp-ports () 
{ 
    for port in "$@"
    do
        pid.stop-if-listening-on-port "${port}"
    done
}

----

==== `pstop`

[source,bash]
----
pstop () 
{ 
    pids.stop "$@"
}

----

==== `sig.is-valid`

[source,bash]
----
sig.is-valid () 
{ 
    [[ -n $(kill -l "${1}" 2> /dev/null) ]]
}

----

==== `sig.list`

[source,bash]
----
sig.list () 
{ 
    /bin/kill -l | sed -E 's/([ 0-9][0-9]\) SIG)//g; s/\s+/\n/g' | tr 'a-z' 'A-Z' | sort
}

----


=== Module `pipe`

==== `pipe.extract-variables`

[source,bash]
----
pipe.extract-variables () 
{ 
    sedx '/^\(\s*\)#.*$/D; /^\s*$/D; /^[^A-Z].*$/D' | sedx 's/export //ig' | cut -d '=' -f 1
}

----

==== `pipe.remove-blank-lines`

[source,bash]
----
pipe.remove-blank-lines () 
{ 
    sedx '/^$/D'
}

----

==== `pipe.remove-hash-comments`

[source,bash]
----
pipe.remove-hash-comments () 
{ 
    sedx '/^\(\s*\)?#.*$/D; s/#.*$//g;'
}

----


=== Module `progress-bar`

==== `progress.bar.auto-run`

[source,bash]
----
progress.bar.auto-run () 
{ 
    .progress.reset
    .progress.bar "$@"
    code=$?
    if [[ ${code} -ne 0 ]]; then
        .progress.reset
        return 1
    fi
    return 0
}

----

==== `progress.bar.config`

[source,bash]
----
progress.bar.config () 
{ 
    while true; do
        local setting="$1"
        shift
        [[ -z ${setting} ]] && break
        local key=${setting/=*/}
        local value=${setting/*=/}
        eval "export LibProgress__${key}=\"${value}\""
    done
}

----

==== `progress.bar.configure.color-green`

[source,bash]
----
progress.bar.configure.color-green () 
{ 
    progress.bar.config BarColor="${bldgrn}"
}

----

==== `progress.bar.configure.color-red`

[source,bash]
----
progress.bar.configure.color-red () 
{ 
    progress.bar.config BarColor="${bldred}"
}

----

==== `progress.bar.configure.color-yellow`

[source,bash]
----
progress.bar.configure.color-yellow () 
{ 
    progress.bar.config BarColor="${bldylw}"
}

----

==== `progress.bar.configure.symbol-arrow`

[source,bash]
----
progress.bar.configure.symbol-arrow () 
{ 
    progress.bar.config BarChar="â¯"
}

----

==== `progress.bar.configure.symbol-bar`

[source,bash]
----
progress.bar.configure.symbol-bar () 
{ 
    progress.bar.config BarChar="â–ˆ"
}

----

==== `progress.bar.configure.symbol-block`

[source,bash]
----
progress.bar.configure.symbol-block () 
{ 
    progress.bar.config BarChar="${LibProgress__BarChar__Default}"
}

----

==== `progress.bar.configure.symbol-square`

[source,bash]
----
progress.bar.configure.symbol-square () 
{ 
    progress.bar.config BarChar="â—¼ï¸Ž"
}

----

==== `progress.bar.launch-and-wait`

[source,bash]
----
progress.bar.launch-and-wait () 
{ 
    local command="$*"
    run.print-command "${command}\n"
    ${command} > /dev/null 2>&1 & local pid=$!
    info "Waiting for background process to finish; PID=${bldylw}${pid}"
    set -e
    while .progress.bar.check-pid-alive $pid; do
        progress.bar.auto-run 0.5 10
    done
    set +e
    return 0
}

----


=== Module `repositories`

==== `repo.rebase`

[source,bash]
----
repo.rebase () 
{ 
    run "git pull origin main --rebase"
}

----

==== `repo.stash-and-rebase`

[source,bash]
----
repo.stash-and-rebase () 
{ 
    run "git stash >/dev/null"
    run "git reset --hard"
    repo.rebase
}

----

==== `repo.update`

[source,bash]
----
repo.update () 
{ 
    local folder="$1"
    h2 "Entering repo â–º ${bldgren}${folder}"
    [[ -d "${folder}" ]] || return 1
    [[ -d "${folder}/.git" ]] || return 1
    [[ "$(pwd)" != "${folder}" ]] && { 
        cd "${folder}" || return 2
    }
    if [[ -z "$(git status -s)" ]]; then
        repo.rebase
    else
        repo.stash-and-rebase
    fi
}

----

==== `repos.catch-interrupt`

[source,bash]
----
repos.catch-interrupt () 
{ 
    export LibRepo__Interrupted=true
}

----

==== `repos.init-interrupt`

[source,bash]
----
repos.init-interrupt () 
{ 
    export LibRepo__Interrupted=false
    trap 'repos.catch-interrupt' SIGINT
}

----

==== `repos.recursive-update`

[source,bash]
----
repos.recursive-update () 
{ 
    local repo="${1}"
    run.set-all show-output-off
    if [[ ${LibRepo__Interrupted} == true ]]; then
        warn "Detected SINGINT, exiting..."
        return 2
    fi
    if [[ -n "$repo" ]]; then
        repo.update "$repo"
    else
        for dir in $(find . -type d -name '.git')
        do
            local subdir=$(dirname "$dir")
            [[ -n "${BASHMATIC_DEBUG}" ]] && info "checking out sub-folder ${bldcyn}${subdir}..."
            repos.recursive-update "${subdir}"
            if [[ $? -eq 2 ]]; then
                error "folder ${bldylw}${subdir}${bldred} return error!"
                return 2
            fi
        done
    fi
    if [[ -n ${repo} ]]; then
        info "returning to the root dir ${bldylw}${root_folder}..."
        cd "${root_folder}" > /dev/null || return 2
    fi
}

----

==== `repos.update`

[source,bash]
----
repos.update () 
{ 
    export root_folder="$(pwd)"
    bash -c "
    [[ -d ${BASHMATIC_HOME} ]] || {
      echo 'Can not find bashmatic installation sorry'
      return
    }
    source ${BASHMATIC_HOME}/init.sh
    repos.init-interrupt
    repos.recursive-update '$*'
  "
}

----

==== `repos.was-interrupted`

[source,bash]
----
repos.was-interrupted () 
{ 
    [[ ${LibRepo__Interrupted} == true ]]
}

----


=== Module `ruby`

==== `bundle.gems-with-c-extensions`

[source,bash]
----
bundle.gems-with-c-extensions () 
{ 
    run.set-next show-output-on
    run "bundle show --paths | ruby -e \"STDIN.each_line {|dep| puts dep.split('/').last if File.directory?(File.join(dep.chomp, 'ext')) }\""
}

----

==== `interrupted`

[source,bash]
----
interrupted () 
{ 
    export BashMatic__Interrupted=true
}

----

==== `ruby.aliases`

[source,bash]
----
ruby.aliases () 
{ 
    alias b="bundle"
    alias be="bundle exec"
    alias ber="bundle exec rake"
    alias bert="bundle exec rake -T"
    alias berr="bundle exec rspec"
    alias rdb="set -ex; bundle exec rake db:drop:all; bundle exec rake db:create:all; bundle exec rake db:migrate db:seed; bundle exec rake db:test:prepare; set +ex"
}

----

==== `ruby.bundle-install`

[source,bash]
----
ruby.bundle-install () 
{ 
    if [[ -f Gemfile.lock ]]; then
        run "bundle install"
    fi
}

----

==== `ruby.bundler-version`

[source,bash]
----
ruby.bundler-version () 
{ 
    if [[ ! -f Gemfile.lock ]]; then
        error "Can not find Gemfile.lock"
        return 1
    fi
    tail -1 Gemfile.lock | sedx 's/ //g'
}

----

==== `ruby.compiled-with`

[source,bash]
----
ruby.compiled-with () 
{ 
    if [[ -z "$*" ]]; then
        error "usage: ruby.compiled-with <library>"
        return 1
    fi
    ruby -r rbconfig -e "puts RbConfig.CONFIG['LIBS']" | grep -q "$*"
}

----

==== `ruby.default-gems`

[source,bash]
----
ruby.default-gems () 
{ 
    declare -a DEFAULT_RUBY_GEMS=(bundler rubocop relaxed-rubocop rubocop-performance warp-dir colored2 sym pry pry-doc pry-byebug rspec rspec-its awesome_print activesupport pivotal_git_scripts git-smart travis awscli irbtools kramdown-asciidoc asciidoctor kramdown gemsmith rspec rspec-its)
    export DEFAULT_RUBY_GEMS
    printf "${DEFAULT_RUBY_GEMS[*]}"
}

----

==== `ruby.ensure-rbenv`

[source,bash]
----
ruby.ensure-rbenv () 
{ 
    [[ -n $(command -v rbenv) ]] && return 0
    brew.install
    brew.install.package rbenv ruby-build
    grep -q "rbenv init" ~/.bash_profile && echo 'eval "$(rbenv init -)"' >> ~/.bash_profile
    [[ -n $(command -V rbenv) ]] && return 0
    return 1
}

----

==== `ruby.ensure-rbenv-or-complain`

[source,bash]
----
ruby.ensure-rbenv-or-complain () 
{ 
    ruby.ensure-rbenv || { 
        error "Can't install rbenv via HomeBrew, please try manually."
        return 1
    }
    return 0
}

----

==== `ruby.full-version`

[source,bash]
----
ruby.full-version () 
{ 
    /usr/bin/env ruby --version
}

----

==== `ruby.gemfile-lock-version`

[source,bash]
----
ruby.gemfile-lock-version () 
{ 
    local gem=${1}
    if [[ ! -f Gemfile.lock ]]; then
        error "Can not find Gemfile.lock"
        return 1
    fi
    ${GrepCommand} " ${gem} \([0-9]" Gemfile.lock | sed -e 's/[\(\)]//g' | awk '{print $2}'
}

----

==== `ruby.gems`

[source,bash]
----
ruby.gems () 
{ 
    ruby.gems.install "$@"
}

----

==== `ruby.gems.install`

[source,bash]
----
ruby.gems.install () 
{ 
    local -a gems=($@)
    gem.clear-cache
    [[ ${#gems[@]} -eq 0 ]] && gems=($(ruby.default-gems))
    local -a existing=($(ruby.installed-gems))
    [[ ${#gems[@]} -eq 0 ]] && { 
        error 'Unable to determine what gems to install. ' "Argument is empty, so is ${DEFAULT_RUBY_GEMS[@]}" "USAGE: ${bldgrn}ruby.gems ${bldred} rails rubocop puma pry"
        return 1
    }
    h2 "There are a total of ${#existing[@]} of globally installed Gems." "Total of ${#gems[@]} need to be installed unless they already exist. " "${bldylw}Checking for gems that still missing..."
    local -a gems_to_be_installed=()
    for gem in "${gems[@]}"
    do
        local gem_info=
        if [[ $(array.has-element "${gem}" "${existing[@]}") == "true" ]]; then
            gem_info="${bldgrn} âœ”  ${gem}${clr}\n"
        else
            gem_info="${bldred} x  ${gem}${clr}\n"
            gems_to_be_installed+=("${gem}")
        fi
        printf "   ${gem_info}"
    done
    if [[ ${#gems_to_be_installed[@]} -eq 0 ]]; then
        info "All gems are already installed. ðŸ‘ðŸ¼"
        return 0
    fi
    info "Looks like ${#gems_to_be_installed[@]} gems are left to install..."
    local -a gem_installed
    for gem in "${gems_to_be_installed[@]}"
    do
        run "gem install -q --force --no-document $gem"
        if [[ ${LibRun__LastExitCode} -ne 0 ]]; then
            error "Gem ${gem} refuses to install." "Perhaps try installing it manually?" "${bldgrn}Action: Skip and Continuing..."
            break
        else
            gem_installed+=("${gem}")
            continue
        fi
    done
    gem.clear-cache
    info "Total of ${#gem_installed[@]} gems were installed."
    echo
}

----

==== `ruby.gems.uninstall`

[source,bash]
----
ruby.gems.uninstall () 
{ 
    local -a gems
    gems=("$@")
    gem.clear-cache
    [[ ${#gems[@]} -eq 0 ]] && declare -a gems=($(ruby.default-gems))
    local -a existing=($(ruby.installed-gems))
    [[ ${#gems[@]} -eq 0 ]] && { 
        error "Unable to determine what gems to remove. Argument is empty, so is ${DEFAULT_RUBY_GEMS[@]}" "USAGE: ${bldgrn}ruby.gems.uninstall ${bldred} rails rubocop puma pry"
        return 1
    }
    h1.blue "There are a total of ${#existing[@]} of gems installed in a global namespace." "Total of ${#gems[@]} need to be removed."
    local deleted=0
    for gem in "${gems[@]}"
    do
        local gem_info=
        if [[ $(array.has-element "${gem}" "${existing[@]}") == "true" ]]; then
            run "gem uninstall -a -x -I -D --force ${gem}"
            deleted=$((deleted + 1))
        else
            gem_info="${bldred} x [not found] ${bldylw}${gem}${clr}\n"
        fi
        printf "   ${gem_info}"
    done
    gem.clear-cache
    echo
    success "Total of ${deleted} gems were successfully obliterated."
    echo
}

----

==== `ruby.handle-missing`

[source,bash]
----
ruby.handle-missing () 
{ 
    command -v ruby > /dev/null || { 
        info "Couldn't find Ruby, installing it..." 1>&2
        ruby.install-ruby "$(ruby.numeric-version)"
    }
    command -v ruby > /dev/null
}

----

==== `ruby.init`

[source,bash]
----
ruby.init () 
{ 
    h1 "Installing Critical Gems for Your Glove, Thanos..."
    ruby.rubygems-update
    ruby.install-upgrade-bundler
    ruby.gems.install
    ruby.kigs-gems
}

----

==== `ruby.install`

[source,bash]
----
ruby.install () 
{ 
    ruby.install-ruby "$@"
}

----

==== `ruby.install-ruby`

[source,bash]
----
ruby.install-ruby () 
{ 
    local version="$1"
    shift
    local version_source="provided as an argument"
    if [[ -z ${version} && -f .ruby-version ]]; then
        version="$(cat .ruby-version | tr -d '\n')"
        version_source="auto-detected from .ruby-version file"
    fi
    [[ -z ${version} ]] && { 
        error "USAGE: ruby.install-ruby VERSION" "Or, you can create a local .ruby-version file"
        return 1
    }
    local -a required_packages
    required_packages=(rbenv ruby-build)
    h3 "Installing Ruby Version ${bldpur}${version} ${bldblu}${version_source}."
    ruby.validate-version "${version}" || return 1
    brew.install.packages "${required_packages[@]}"
    brew.upgrade.packages "${required_packages[@]}"
    if [[ -n "$*" ]]; then
        info "Attemping to install additional packages via Brew:"
        for package in "$@"
        do
            run.set-next abort-on-error
            brew.install.package "${package}"
            local func=".ruby.configure-with.${package}"
            util.is-a-function "${func}" && ${func}
        done
    fi
    eval "$(rbenv init -)"
    h2 "RUBY_CONFIGURE_OPTS: ${bldgrn}${RUBY_CONFIGURE_OPTS}"
    run "RUBY_CONFIGURE_OPTS=\"${RUBY_CONFIGURE_OPTS}\" rbenv install -s ${version}"
    return "${LibRun__LastExitCode:-"0"}"
}

----

==== `ruby.install-ruby-with-deps`

[source,bash]
----
ruby.install-ruby-with-deps () 
{ 
    local version="$1"
    declare -a packages=(cask bash bash-completion git go haproxy htop jemalloc libxslt jq libiconv libzip netcat nginx openssl pcre pstree p7zip rbenv redis ruby_build readline tree vim watch wget zlib)
    run.set-next show-output-on
    run "brew install --display-times ${packages[*]}"
}

----

==== `ruby.install-ruby-with-readline-and-openssl`

[source,bash]
----
ruby.install-ruby-with-readline-and-openssl () 
{ 
    local version="$1"
    [[ -z ${version} ]] && { 
        error "usage: ruby.install-ruby-with-readline-and-openssl ruby-version"
        return 1
    }
    shift
    ruby.install-ruby "${version}" openssl readline "$@"
}

----

==== `ruby.install-upgrade-bundler`

[source,bash]
----
ruby.install-upgrade-bundler () 
{ 
    gem.install bundler
    run "bundle --update bundler || true"
}

----

==== `ruby.installed-gems`

[source,bash]
----
ruby.installed-gems () 
{ 
    gem list | cut -d ' ' -f 1 | uniq
}

----

==== `ruby.kigs-gems`

[source,bash]
----
ruby.kigs-gems () 
{ 
    if [[ -z $(type wd 2> /dev/null) && -n $(command -v warp-dir) ]]; then
        [[ -f ~/.bash_wd ]] || { 
            warp-dir install --dotfile ~/.bashrc > /dev/null
            source ~/.bash_wd
        }
    fi
    [[ -n $(command -v sym) ]] && { 
        [[ -f ~/.sym.completion.bash ]] || { 
            sym -B ~/.bashrc
        }
    }
}

----

==== `ruby.linked-libs`

[source,bash]
----
ruby.linked-libs () 
{ 
    ruby -r rbconfig -e "puts RbConfig.CONFIG['LIBS']"
}

----

==== `ruby.numeric-version`

[source,bash]
----
ruby.numeric-version () 
{ 
    /usr/bin/env ruby --version | sed 's/^ruby //g; s/ (.*//g'
}

----

==== `ruby.rbenv`

[source,bash]
----
ruby.rbenv () 
{ 
    ruby.ensure-rbenv-or-complain || return 1
    if [[ -n "$*" ]]; then
        rbenv "$*"
    else
        eval "$(rbenv init -)"
    fi
    run "rbenv rehash"
}

----

==== `ruby.rubygems-update`

[source,bash]
----
ruby.rubygems-update () 
{ 
    info "Updating RubyGems..."
    run.set-next show-output-on
    run "gem update --system -N"
    gem.clear-cache
}

----

==== `ruby.stop`

[source,bash]
----
ruby.stop () 
{ 
    local regex='/[r]uby| [p]uma| [i]rb| [r]ails | [b]undle| [u]nicorn| [r]ake'
    local procs=$(ps -ef | ${GrepCommand} "${regex}" | ${GrepCommand} -v grep | awk '{print $2}' | sort | uniq | wc -l)
    [[ ${procs} -eq 0 ]] && { 
        info: "No ruby processes were found."
        return 0
    }
    local -a pids=$(ps -ef | ${GrepCommand} "${regex}" | ${GrepCommand} -v grep | awk '{print $2}' | sort | uniq | tr '\n' ' -p ')
    h2 "Detected ${#pids[@]} Ruby Processes..., here is the tree:"
    printf "${txtcyn}"
    pstree "${pids[*]}"
    printf "${clr}"
    hr
    printf "To abort, press Ctrl-C. To kill them all press any key.."
    run.ui.press-any-key
    ps -ef | ${GrepCommand} "${regex}" | ${GrepCommand} -v grep | awk '{print $2}' | sort | uniq | xargs kill -9
}

----

==== `ruby.top-versions`

[source,bash]
----
ruby.top-versions () 
{ 
    local platform="${1}"
    local arg="$(.ruby.ruby-build.list-argument)"
    local filter="cat"
    [[ -n ${platform} ]] && filter="grep -E '^${platform}'"
    eval "rbenv install ${arg}" | eval "${filter}" | ruby -e '
      last_v = nil
      last_m = nil
      ARGF.each do |line|
        v = line.split(".")[0..1].join(".")
        if last_v != v
          puts last_m if last_m
          last_v = v
        end
        last_m = line
      end
      puts last_m if last_m'
}

----

==== `ruby.top-versions-as-yaml`

[source,bash]
----
ruby.top-versions-as-yaml () 
{ 
    ruby.top-versions | sed 's/^/ - /g'
}

----

==== `ruby.validate-version`

[source,bash]
----
ruby.validate-version () 
{ 
    local version="$1"
    local -a ruby_versions=()
    run "brew upgrade ruby-build || true"
    [[ -d ~/.rbenv/plugins/ruby-build ]] && { 
        run "cd ~/.rbenv/plugins/ruby-build && git reset --hard && git pull --rebase"
    }
    local arg="$(.ruby.ruby-build.list-argument)"
    array.from.command ruby_versions "rbenv install ${arg}"
    inf "Validating ruby version: ${version}"
    array.includes "${version}" "${ruby_versions[@]}" || { 
        not-ok:
        error "Ruby Version provided was NOT found by rbenv: ${bldylw}${version}" "Found a total of ${bldgrn}${#ruby_versions[*]} ruby versions."
        return 1
    }
    ok:
    return 0
}

----


=== Module `run`

==== `run`

[source,bash]
----
run () 
{ 
    .run "$@"
    return ${LibRun__LastExitCode}
}

----

==== `run.ui.ask`

[source,bash]
----
run.ui.ask () 
{ 
    local question=$*
    local func="${LibRun__AskDeclineFunction}"
    export LibRun__AskDeclineFunction="${LibRun__AskDeclineFunction__Default}"
    echo
    inf "${bldcyn}${question}${clr} [Y/n] ${bldylw}"
    read a 2> /dev/null
    code=$?
    if [[ ${code} != 0 ]]; then
        error "Unable to read from STDIN."
        eval "${func} 12"
    fi
    echo
    if [[ ${a} == 'y' || ${a} == 'Y' || ${a} == '' ]]; then
        info "${bldblu}Roger that."
        info "Let's just hope it won't go nuclear on us :) ðŸ’¥"
        hr
        echo
    else
        info "${bldred}(Great idea!) Abort! Abandon ship!  ðŸ›³   " 1>&2
        hr 1>&2
        echo
        eval "${func} 1"
    fi
}

----

==== `run.ui.ask-user-value`

[source,bash]
----
run.ui.ask-user-value () 
{ 
    local variable="$1"
    shift
    local text="$*"
    local user_input
    trap 'echo; echo Aborting at user request... ; echo; abort; return' int
    ask "${text}"
    read user_input
    if [[ -z "${user_input}" ]]; then
        error "Sorry, I didn't get that. Please try again or press Ctrl-C to abort."
        return 1
    else
        eval "export ${variable}=\"${user_input}\""
        return 0
    fi
}

----

==== `run.ui.get-user-value`

[source,bash]
----
run.ui.get-user-value () 
{ 
    run.ui.retry-command run.ui.ask-user-value "${@}"
}

----

==== `run.ui.press-any-key`

[source,bash]
----
run.ui.press-any-key () 
{ 
    local prompt="$*"
    [[ -z ${prompt} ]] && prompt="Press any key to continue..."
    br
    printf "    ${txtgrn}${italic}${prompt} ${clr}  "
    read -r -s -n1 key
    cursor.rewind
    printf "                                                           "
    cursor.up 2
    cursor.rewind
    echo
}

----

==== `run.ui.retry-command`

[source,bash]
----
run.ui.retry-command () 
{ 
    local command="$*"
    local retries=5
    n=0
    until [ $n -ge ${retries} ]; do
        [[ ${n} -gt 0 ]] && info "Retry number ${n}..."
        command && break
        n=$(($n + 1))
        sleep 1
    done
}

----


=== Module `runtime`

==== `command-spacer`

[source,bash]
----
command-spacer () 
{ 
    local color="${LibRun__CommandColor}"
    [[ ${LibRun__LastExitCode} -ne 0 ]] && color="${txtred}"
    [[ -z ${LibRun__AssignedWidth} || -z ${LibRun__CommandLength} ]] && return
    printf "%s${color}" ""
    local __width=$((LibRun__AssignedWidth - LibRun__CommandLength - 10))
    [[ ${__width} -gt 0 ]] && .output.replicate-to "${LibRun__CommandColor} " "${__width}"
    printf "${clr}"
}

----

==== `run`

[source,bash]
----
run () 
{ 
    .run "$@"
    return ${LibRun__LastExitCode}
}

----

==== `run.add-obfuscated-var`

[source,bash]
----
run.add-obfuscated-var () 
{ 
    while true; do
        local variable="$1"
        shift
        [[ -n ${variable} ]] || break
        export OBFUSCATED_VARIABLES+=("${variable}")
    done
    export OBFUSCATED_VARIABLES=($(array.uniq "${OBFUSCATED_VARIABLES[@]}"))
}

----

==== `run.config.detail-is-enabled`

[source,bash]
----
run.config.detail-is-enabled () 
{ 
    [[ ${LibRun__Detail} -eq ${True} ]]
}

----

==== `run.config.is-dry-run`

[source,bash]
----
run.config.is-dry-run () 
{ 
    [[ ${LibRun__DryRun} -eq ${True} ]]
}

----

==== `run.config.verbose-is-enabled`

[source,bash]
----
run.config.verbose-is-enabled () 
{ 
    [[ ${LibRun__Verbose} -eq ${True} ]]
}

----

==== `run.dry-run-prefix`

[source,bash]
----
run.dry-run-prefix () 
{ 
    if [[ ${LibRun__DryRun} == ${True} ]]; then
        printf "${txtcyn}${italic}Â« dry run Â»${clr} "
    fi
}

----

==== `run.filter-out-sensitive-vars`

[source,bash]
----
run.filter-out-sensitive-vars () 
{ 
    local a="${1:-""}"
    if [[ "$a" == "-" ]]; then
        read -r a
    else
        if [[ -f "${a}" ]]; then
            grep -v -E "${SENSITIVE_VARS_REGEX}" "${a}"
        else
            echo | grep -v -E "${SENSITIVE_VARS_REGEX}"
        fi
    fi
}

----

==== `run.inspect`

[source,bash]
----
run.inspect () 
{ 
    if [[ ${#@} -eq 0 || $(array.has-element "config" "$@") == "true" ]]; then
        run.inspect-variables-that-are starting-with LibRun
    fi
    if [[ ${#@} -eq 0 || $(array.has-element "totals" "$@") == "true" ]]; then
        hl.subtle "TOTALS"
        info "${bldgrn}${commands_completed} commands completed successfully"
        [[ ${commands_failed} -gt 0 ]] && info "${bldred}${commands_failed} commands failed"
        [[ ${commands_ignored} -gt 0 ]] && info "${bldylw}${commands_ignored} commands failed, but were ignored."
        echo
    fi
    if [[ ${#@} -eq 0 || $(array.has-element "current" "$@") == "true" ]]; then
        run.inspect-variables-that-are ending-with __LastExitCode
    fi
    reset-color
}

----

==== `run.inspect-variable`

[source,bash]
----
run.inspect-variable () 
{ 
    local var_name=${1}
    local var_value=${!var_name}
    local value=""
    local print_value
    local obfuscated_value
    local max_len=100
    local avail_len=$(($(screen.width.actual) - 45))
    local lcase_var_name="$(echo "${var_name}" | tr '[:upper:]' '[:lower:]')"
    print_value=1
    local print_value
    array.includes "${var_name}" "${OBFUSCATED_VARIABLES[@]}" && obfuscated_value=$(run.obfuscate-string-value "${var_name}")
    array.includes "${lcase_var_name}" "${OBFUSCATED_VARIABLES[@]}" && obfuscated_value=$(run.obfuscate-string-value "${lcase_var_name}")
    local color="${txtblk}${bakpur}"
    local value_off=" âœ˜ "
    local value_check=" âœ”ï¸Ž  "
    local value_color=""
    [[ -n ${obfuscated_value} ]] && { 
        obfuscated_value="<obfuscated-value-${obfuscated_value}>"
        value_color="${italic}${txtred}"
    }
    if [[ -n "${var_value}" ]]; then
        if [[ ${var_name} =~ ${SENSITIVE_VARS_REGEX} || ${var_name} =~ ${SENSITIVE_VARS_REGEX^^} ]]; then
            var_value="$(run.obfuscate-string-value ${var_name}) [obfuscated]"
            color="${itawht}${italic}${bakcyn}"
        else
            if [[ ${lcase_var_name} =~ 'exit' ]]; then
                if [[ ${var_value} -eq 0 ]]; then
                    var_value="${value_check} [zero]"
                    color="${bakgrn}"
                else
                    print_value=1
                    var_value=${var_value}
                    color="${bakred}"
                    avail_len=$((avail_len + 5))
                fi
                avail_len=$((avail_len + 5))
            else
                if var.is-truthy "${var_value}"; then
                    var_value="${value_check} [true]"
                    color="${bakgrn}"
                    avail_len=$((avail_len + 5))
                else
                    if var.is-falsy "${var_value}"; then
                        var_value="${value_off} [false]"
                        color="${bakred}"
                        avail_len=$((avail_len + 2))
                    fi
                fi
            fi
        fi
    else
        var_value=" â”€  [empty]"
        color="${bakpur}"
        avail_len=$((avail_len + 2))
    fi
    printf -- "  â¯${txtylw} %-40s ${txtblk}${color} " "${var_name}"
    [[ ${avail_len} -gt ${max_len} ]] && avail_len=${max_len}
    local dot_count="$(echo "${var_value}" | sedx -E 's/[^.]//g' | tr -d '\n' | wc -c)"
    if [[ "${print_value}" -eq 1 ]]; then
        if [[ -n ${obfuscated_value} ]]; then
            print_value="${obfuscated_value}"
            var_value="${obfuscated_value}"
            value="${obfuscated_value}"
        fi
        if [[ -n "${value}" ]] && ! is.numeric "${var_value}"; then
            echo "XXX"
        else
            if is.numeric "${var_value}"; then
                avail_len=$((avail_len))
                if [[ ${dot_count} -gt 1 || ${dot_count} -gt 1 ]]; then
                    echo "XXX"
                    printf -- "${value_color}[%-*.*s]" "${avail_len}" "${avail_len}" "${var_value}"
                else
                    if [[ "${var_value}" =~ \. ]]; then
                        printf -- "${value_color}%-*.2f" "$((avail_len))" "${var_value}"
                    else
                        printf -- "${value_color}%-*d" "$((avail_len))" "${var_value}"
                    fi
                fi
            else
                printf -- "${value_color}%-*.*s" "${avail_len}" "${avail_len}" "${var_value}"
            fi
        fi
    else
        avail_len=$((avail_len))
        printf -- "${value_color}%-*.*s" "${avail_len}" "${avail_len}" "${var_value}"
    fi
    printf "${clr}\n"
}

----

==== `run.inspect-variables`

[source,bash]
----
run.inspect-variables () 
{ 
    local title=${1}
    shift
    output.constrain-screen-width 100
    h3bg "${title}"
    for var in $@
    do
        run.inspect-variable "${var}"
    done
}

----

==== `run.inspect-variables-that-are`

[source,bash]
----
run.inspect-variables-that-are () 
{ 
    local pattern_type="${1}"
    local pattern="${2}"
    run.inspect-variables "VARIABLES $(echo "${pattern_type}" | tr '[:lower:]' '[:upper:]') ${pattern}" "$(run.variables-"${pattern_type}" "${pattern}" | tr '\n' ' ')"
}

----

==== `run.inspect-vars`

[source,bash]
----
run.inspect-vars () 
{ 
    for var in "$@"
    do
        run.inspect-variables-that-are starting-with "$var"
    done
}

----

==== `run.inspect.set-skip-false-or-blank`

[source,bash]
----
run.inspect.set-skip-false-or-blank () 
{ 
    local value="${1}"
    [[ -n "${value}" ]] && export LibRun__Inspect__SkipFalseOrBlank=${value}
    [[ -z "${value}" ]] && export LibRun__Inspect__SkipFalseOrBlank=${True}
}

----

==== `run.obfuscate-string-value`

[source,bash]
----
run.obfuscate-string-value () 
{ 
    local value="$1"
    local len="30"
    local sha=$(echo "${value}" | sha512sum | cut -d ' ' -f 1)
    printf "%s" "${sha:0:${len}}"
}

----

==== `run.on-error.ask-is-enabled`

[source,bash]
----
run.on-error.ask-is-enabled () 
{ 
    [[ ${LibRun__AskOnError} -eq ${True} ]]
}

----

==== `run.post-command-with-output`

[source,bash]
----
run.post-command-with-output () 
{ 
    local duration="$1"
    if [[ ${LibRun__ShowCommand} -eq ${True} ]]; then
        command-spacer
        duration "${duration}" ${LibRun__LastExitCode}
    fi
}

----

==== `run.print-command`

[source,bash]
----
run.print-command () 
{ 
    local command="$1"
    local max_width=${2:-"120"}
    local min_width=60
    local w
    w=$(($(.output.screen-width) - 10))
    [[ ${w} -gt ${max_width} ]] && w=${max_width}
    export LibRun__AssignedWidth=${w}
    local prefix="${LibOutput__LeftPrefix}${clr}"
    local ascii_cmd
    local command_prompt="${prefix} â¯ "
    local command_width=$((w - 25))
    [[ ${command_width} -lt ${min_width} ]] && command_width=${min_width}
    ascii_cmd="$(printf "${command_prompt}$(run.dry-run-prefix)%-.${command_width}s " "${command:0:${command_width}}")"
    export LibRun__CommandLength=${#ascii_cmd}
    if [[ "${LibRun__ShowCommand}" -eq ${False} ]]; then
        printf -- "${prefix}${LibRun__PromptColor} â¯ ${LibRun__CommandColor} %-.${command_width}s " "$(.output.replicate-to "â– " ${command_width})"
    else
        printf -- "${prefix}${LibRun__PromptColor} â¯ ${LibRun__CommandColor} %-.${command_width}s " "${command:0:${command_width}}"
    fi
}

----

==== `run.print-command-full-screen`

[source,bash]
----
run.print-command-full-screen () 
{ 
    run.print-long-command "$1" "$(screen.width)"
}

----

==== `run.print-long-command`

[source,bash]
----
run.print-long-command () 
{ 
    local command="$1"
    local max_width=${2:-"150"}
    local w
    w=$(($(.output.screen-width) - 10))
    [[ ${w} -gt ${max_width} ]] && w=${max_width}
    export LibRun__AssignedWidth=${w}
    local prefix="${LibRun__PromptColor}${LibOutput__LeftPrefix}${clr}"
    local ascii_cmd
    local command_prompt="${prefix}â¯ $(run.dry-run-prefix)"
    local command_width=$((w - 10))
    printf "${prefix}â¯ ${bldylw}"
    printf "${command}" | fold -s -w"${w}" | awk 'NR > 1 {printf "            "}; { printf "%s\n", $0}'
}

----

==== `run.print-obfuscated-vars`

[source,bash]
----
run.print-obfuscated-vars () 
{ 
    for var in "${OBFUSCATED_VARIABLES[@]}"
    do
        run.inspect-variable "${var}"
    done
}

----

==== `run.print-variable`

[source,bash]
----
run.print-variable () 
{ 
    run.inspect-variable "$1"
}

----

==== `run.print-variables`

[source,bash]
----
run.print-variables () 
{ 
    local title="${1}"
    shift
    hl.yellow "${title}"
    for var in $@
    do
        run.print-variable "${var}"
    done
}

----

==== `run.register-obfuscated-vars`

[source,bash]
----
run.register-obfuscated-vars () 
{ 
    run.add-obfuscated-var password api_key secret token
}

----

==== `run.ui.press-any-key`

[source,bash]
----
run.ui.press-any-key () 
{ 
    local prompt="$*"
    [[ -z ${prompt} ]] && prompt="Press any key to continue..."
    br
    printf "    ${txtgrn}${italic}${prompt} ${clr}  "
    read -r -s -n1 key
    cursor.rewind
    printf "                                                           "
    cursor.up 2
    cursor.rewind
    echo
}

----

==== `run.variables-ending-with`

[source,bash]
----
run.variables-ending-with () 
{ 
    local suffix="${1}"
    env | grep -E -e ".*${suffix}=.*\$" | grep -v -E "${SENSITIVE_VARS_REGEX}" | grep '=' | sedx 's/=.*//g' | sort
}

----

==== `run.variables-starting-with`

[source,bash]
----
run.variables-starting-with () 
{ 
    local prefix="${1}"
    env | grep -E -e "^${prefix}" | grep '=' | sedx 's/=.*//g' | grep -v -E "${SENSITIVE_VARS_REGEX}" | sort
}

----

==== `run.was-successful`

[source,bash]
----
run.was-successful () 
{ 
    [[ ${LibRun__LastExitCode} -eq 0 ]]
}

----

==== `run.with.minimum-duration`

[source,bash]
----
run.with.minimum-duration () 
{ 
    local min_duration=$1
    shift
    local command="$*"
    local started=$(millis)
    info "starting a command with the minimum duration of ${bldylw}${min_duration} seconds"
    run "${command}"
    local result=$?
    local now=$(millis)
    local duration=$(ruby -e "puts (${now} - ${started})/1000.0")
    if [[ ${result} -eq 0 && ${duration} -lt ${min_duration} ]]; then
        local cmd="$(echo "${command}" | sedx 's/\"//g')"
        error "An operation finished too quickly. The threshold was set to ${bldylw}${min_duration} sec." "The command took ${bldylw}${duration}${txtred} secs." "${bldylw}${cmd}${txtred}"
        ((BASH_IN_SUBSHELL)) && exit 1 || return 1
    else
        if [[ ${duration} -gt ${min_duration} ]]; then
            info "minimum duration operation ran in ${duration} seconds."
        fi
    fi
    return ${result}
}

----

==== `run.with.ruby-bundle`

[source,bash]
----
run.with.ruby-bundle () 
{ 
    .run.bundle.exec "$@"
}

----

==== `run.with.ruby-bundle-and-output`

[source,bash]
----
run.with.ruby-bundle-and-output () 
{ 
    .run.bundle.exec.with-output "$@"
}

----

==== `var.is-falsy`

[source,bash]
----
var.is-falsy () 
{ 
    local value="${1}"
    [[ -z "${value}" || "${value}" == "${False}" || "${value}" == "0" || ${value} == "false" ]]
}

----

==== `var.is-truthy`

[source,bash]
----
var.is-truthy () 
{ 
    local value="${1}"
    [[ "${value}" == "${True}" || "${value}" == "1" || ${value} == "true" ]]
}

----


=== Module `runtime-config`

==== `is.dry-run.off`

[source,bash]
----
is.dry-run.off () 
{ 
    ((LibRun__DryRun)) || return 0
    return 1
}

----

==== `is.dry-run.on`

[source,bash]
----
is.dry-run.on () 
{ 
    ((LibRun__DryRun))
}

----

==== `run.inspect`

[source,bash]
----
run.inspect () 
{ 
    if [[ ${#@} -eq 0 || $(array.has-element "config" "$@") == "true" ]]; then
        run.inspect-variables-that-are starting-with LibRun
    fi
    if [[ ${#@} -eq 0 || $(array.has-element "totals" "$@") == "true" ]]; then
        hl.subtle "TOTALS"
        info "${bldgrn}${commands_completed} commands completed successfully"
        [[ ${commands_failed} -gt 0 ]] && info "${bldred}${commands_failed} commands failed"
        [[ ${commands_ignored} -gt 0 ]] && info "${bldylw}${commands_ignored} commands failed, but were ignored."
        echo
    fi
    if [[ ${#@} -eq 0 || $(array.has-element "current" "$@") == "true" ]]; then
        run.inspect-variables-that-are ending-with __LastExitCode
    fi
    reset-color
}

----

==== `run.set-all`

[source,bash]
----
run.set-all () 
{ 
    ____run.configure all "$@"
}

----

==== `run.set-all.list`

[source,bash]
----
run.set-all.list () 
{ 
    set | ${GrepCommand} '^____run.set.all' | awk 'BEGIN{FS="."}{print $4}' | sedx 's/[() ]//g'
}

----

==== `run.set-next`

[source,bash]
----
run.set-next () 
{ 
    ____run.configure next "$@"
}

----

==== `run.set-next.list`

[source,bash]
----
run.set-next.list () 
{ 
    set | ${GrepCommand} '^____run.set.next' | awk 'BEGIN{FS="."}{print $4}' | sedx 's/[() ]//g'
}

----

==== `set.dry-run.off`

[source,bash]
----
set.dry-run.off () 
{ 
    export LibRun__DryRun=0
}

----

==== `set.dry-run.on`

[source,bash]
----
set.dry-run.on () 
{ 
    export LibRun__DryRun=1
}

----


=== Module `sedx`

==== `sedx`

[source,bash]
----
sedx () 
{ 
    [[ -z ${bashmatic__sed_command} ]] && sedx.cache-command
    [[ -z ${bashmatic__sed_command} ]] && { 
        warning "Can't determine determine advanced sed location, using regular sed." 1>&2
        export bashmatic__sed_command="/usr/bin/sed"
    }
    ${bashmatic__sed_command} -E "$@"
}

----

==== `sedx.cache-command`

[source,bash]
----
sedx.cache-command () 
{ 
    local sed_path="$(util.ensure-gnu-sed)"
    [[ -x "${sed_path}" ]] || sed_path="$(command -v gsed || command -v sed)"
    export bashmatic__sed_command="${sed_path}"
}

----

==== `util.ensure-gnu-sed`

[source,bash]
----
util.ensure-gnu-sed () 
{ 
    local sed_path
    local gsed_path
    util.os
    case "${BASHMATIC_OS}" in 
        darwin)
            gsed_path="$(command -v gsed 2> /dev/null)"
            if [[ -z "${gsed_path}" ]]; then
                echo
                h3 "Please wait while we install gnu-sed using Brew..." "It's a required dependency for many key features." 1>&2
                ( brew install gnu-sed --force --quiet && brew unlink gnu-sed
                brew link gnu-sed --overwrite ) 1>&2 > /dev/null
                hash -r 2> /dev/null
                gsed_path="$(command -v gsed 2> /dev/null)"
                [[ -z ${gsed_path} && -x /usr/local/bin/gsed ]] && gsed_path="/usr/local/bin/gsed"
            fi
            [[ -n "${gsed_path}" && -x "${gsed_path}" ]] || { 
                error "Can't find GNU sed even after installation." 1>&2
            }
            sed_path="${gsed_path}"
        ;
        *)
            sed_path="$(command -v sed)"
        ;
    esac
    echo -n "${sed_path}"
}

----


=== Module `serial`

==== `serial.baud`

[source,bash]
----
serial.baud () 
{ 
    if [[ -n $1 ]]; then
        is.number "$1" && export BashmaticSerial__DefaultBaud="$1"
    fi
    h2 "Current Baud Rate:" "${bldylw}${BashmaticSerial__DefaultBaud} Bits/Second"
}

----

==== `serial.device`

[source,bash]
----
serial.device () 
{ 
    if [[ -n $1 && $1 =~ ^/dev ]]; then
        export BashmaticSerial__DefaultDevice="$1"
    else
        export BashmaticSerial__DefaultDevice=$(ls -1 /dev/cu.* | grep -vi bluetooth | tail -1)
    fi
    h3 "Current Device is:" "${bldylw}${BashmaticSerial__DefaultDevice}"
}

----


=== Module `set`

==== `set-e-restore`

[source,bash]
----
set-e-restore () 
{ 
    [[ -f ${__bash_set_errexit_status} ]] && { 
        error "You must first save it with the function:s ${bldgrn}set-e-save"
        return 1
    }
    local status=$(cat "${__bash_set_errexit_status}" | tr -d '\n')
    if [[ ${status} != 'on' && ${status} != 'off' ]]; then
        error "Invalid data in the set -e tempfile:" "$(cat "${__bash_set_errexit_status}")"
        return 1
    fi
    set -o errexit "${status}"
    rm -f "${__bash_set_errexit_status}" 2> /dev/null
}

----

==== `set-e-save`

[source,bash]
----
set-e-save () 
{ 
    export __bash_set_errexit_status=$(mktemp -t 'errexit')
    rm -f "${__bash_set_errexit_status}" 2> /dev/null
    set-e-status > "${__bash_set_errexit_status}"
}

----

==== `set-e-status`

[source,bash]
----
set-e-status () 
{ 
    set -o | grep errexit | awk '{print $2}'
}

----


=== Module `shasum`

==== `sha`

[source,bash]
----
sha () 
{ 
    if output.has-stdin; then
        shasum -a 256 "$@" | cut -d ' ' -f 1
    else
        shasum -a 256 "$@" | cut -d ' ' -f 1
    fi
}

----

==== `shasum.all-files`

[source,bash]
----
shasum.all-files () 
{ 
    shasum.sha "$@" | awk '{print $2 " " $1}' | sort | .sha-only
}

----

==== `shasum.all-files-in-dir`

[source,bash]
----
shasum.all-files-in-dir () 
{ 
    local dir="$1"
    shift
    local name_pattern="$1"
    shift
    [[ -n ${name_pattern} ]] && name_pattern=" -name \"${name_pattern}\""
    shasum.sha $(eval "find \"${dir}\" -type f ${name_pattern}") | awk '{print $2 " " $1}' | sort | .sha-only
}

----

==== `shasum.set-algo`

[source,bash]
----
shasum.set-algo () 
{ 
    local algo="${1:-1}"
    export __bashmatic__sha_command="${__default_bashmatic__sha_command} -a ${algo}"
}

----

==== `shasum.set-command`

[source,bash]
----
shasum.set-command () 
{ 
    export __bashmatic__sha_command="$*"
}

----

==== `shasum.sha`

[source,bash]
----
shasum.sha () 
{ 
    .sha "$@" 2> /dev/null
}

----

==== `shasum.sha-only`

[source,bash]
----
shasum.sha-only () 
{ 
    .sha-only "$@" 2> /dev/null
}

----

==== `shasum.sha-only-stdin`

[source,bash]
----
shasum.sha-only-stdin () 
{ 
    echo "$*" | eval "${__bashmatic__sha_command}" | cut -d' ' -f 1
}

----

==== `shasum.to-hash`

[source,bash]
----
shasum.to-hash () 
{ 
    local hash_name="$1"
    shift
    local index=0
    local last_sha
    for file in $(shasum.sha "$@")
    do
        index=$((index + 1))
        if [[ $((index % 2)) == 0 ]]; then
            is-dbg && info "${last_sha} <- ${bldpur}${file}"
            eval "${hash_name}['${file}']=${last_sha}"
        else
            last_sha="${file}"
        fi
    done
    is-dbg && { 
        local count=$((index / 2))
        eval "local size=\${#${hash_name}[@]}"
        h.yellow "Total ${count} files, ${size} hash entries in a Hash Variable '${hash_name}'"
    }
    return
}

----


=== Module `shdoc`

==== `gawk.install`

[source,bash]
----
gawk.install () 
{ 
    local gawk_path="$(command -v gawk 2> /dev/null)"
    [[ -n "${gawk_path}" && -x "${gawk_path}" ]] || brew.install.package gawk
}

----


=== Module `shell-set`

==== `save-restore-x`

[source,bash]
----
save-restore-x () 
{ 
    shell-set.pop-stack x
}

----

==== `save-set-x`

[source,bash]
----
save-set-x () 
{ 
    shell-set.push-stack x
}

----

==== `shell-set.init-stack`

[source,bash]
----
shell-set.init-stack () 
{ 
    unset SetOptsStack
    declare -a SetOptsStack=()
    export SetOptsStack
}

----

==== `shell-set.is-set`

[source,bash]
----
shell-set.is-set () 
{ 
    local v="$1"
    local is_set=${-//[^${v}]/}
    if [[ -n ${is_set} ]]; then
        return 0
    else
        return 1
    fi
}

----

==== `shell-set.pop-stack`

[source,bash]
----
shell-set.pop-stack () 
{ 
    local value="$1"
    local len=${#SetOptsStack[@]}
    local last_index=$((len - 1))
    local last=${SetOptsStack[${last_index}]}
    if [[ ${last} != "-${value}" && ${last} != "+${value}" ]]; then
        error "Can not restore ${value}, not the last element in ${SetOptsStack[*]} stack."
        return 1
    fi
    local pop=(${last})
    export SetOptsStack=("${SetOptsStack[@]/$pop/}")
    [[ -n ${BASHMATIC_DEBUG} ]] && shell-set-show
    eval "set ${last}"
}

----

==== `shell-set.push-stack`

[source,bash]
----
shell-set.push-stack () 
{ 
    local value="$1"
    local is_set=${-//[^${value}]/}
    shell-set.is-set "${value}" && export SetOptsStack=(${SetOptsStack[@]} "-${value}")
    shell-set.is-set "${value}" || export SetOptsStack=(${SetOptsStack[@]} "+${value}")
    [[ -n ${BASHMATIC_DEBUG} ]] && shell-set-show
}

----

==== `shell-set.show-stack`

[source,bash]
----
shell-set.show-stack () 
{ 
    info "Current Shell Set Stack: ${bldylw}[${SetOptsStack[*]}]"
}

----


=== Module `ssh`

==== `ssh.key.copy`

[source,bash]
----
ssh.key.copy () 
{ 
    cat ~/.ssh/id_rsa.pub | pbcopy
}

----

==== `ssh.key.filenames`

[source,bash]
----
ssh.key.filenames () 
{ 
    local name="$1"
    is.not-blank "${name}" && name="_${name}"
    export __bm__private_key_path="${HOME}/.ssh/id_rsa${name}"
    export __bm__public_key_path="${HOME}/.ssh/id_rsa${name}.pub"
    export __bm__ssh_folder="${HOME}/.ssh"
}

----

==== `ssh.keys.generate`

[source,bash]
----
ssh.keys.generate () 
{ 
    local name="$1"
    local code=0
    local email
    local date="$(time.now.db)"
    ssh.key.filenames "$@"
    if is.a-non-empty-file "${__bm__private_key_path}"; then
        warning "Private key already exists at the path:" "${bldred}${__bm__private_key_path}"
        is.blank "${name}" && info "NOTE You can pass an optional name argument to this function"
        info "so that the key file will be unique."
        ( run.ui.ask "Replace the existing key (previous key will be backed up)?" )
        code=$?
        ((code)) && return 1
    fi
    is.a-function user.gitconfig.email && email="$(user.gitconfig.email)"
    is.blank "${email}" && run.ui.ask-user-value email "Please enter the email address for this key:"
    if [[ -f "${__bm__private_key_path}" ]]; then
        for file in "${__bm__private_key_path}" "${__bm__public_key_path}"
        do
            [[ -f ${file} ]] && run "mv ${file} ${file}.backup.${date}"
        done
    fi
    run.set-next show-output-on
    run "ssh-keygen -t rsa -b 4096 -C ${email}"
}

----

==== `ssh.load-keys`

[source,bash]
----
ssh.load-keys () 
{ 
    local pattern="$1"
    ssh.key.filenames "$@"
    local dir="${__bm__ssh_folder}"
    local regex="id_*${pattern}*"
    info "Loading keys from ${bldylw}${dir}$(txt-info), matching regex: ${bldred}[${regex}]"
    find "${dir}" -type f -name "${regex}" -and -not -name '*.pub' -exec ssh-add {} \
}

----


=== Module `subshell`

==== `bashmatic.detect-subshell`

[source,bash]
----
bashmatic.detect-subshell () 
{ 
    bashmatic.subshell-init
    [[ -n ${BASH_SUBSHELL_DETECTED} && -n ${BASH_IN_SUBSHELL} ]] && return "${BASH_IN_SUBSHELL}"
    unset BASH_IN_SUBSHELL
    export BASH_SUBSHELL_DETECTED=true
    local len="${#BASH_SOURCE[@]}"
    local last_index=$((len - 1))
    [[ -n ${BASHMATIC_DEBUG} ]] && { 
        echo "BASH_SOURCE[*] = ${BASH_SOURCE[*]}" 1>&2
        echo "BASH_SOURCE[${last_index}] = ${BASH_SOURCE[${last_index}]}" 1>&2
        echo "\$0            = $0" 1>&2
    }
    if [[ -n ${ZSH_EVAL_CONEXT} && ${ZSH_EVAL_CONTEXT} =~ :file$ ]] || [[ -n ${BASH_VERSION} && "$0" != "${BASH_SOURCE[${last_index}]}" ]]; then
        export BASH_IN_SUBSHELL=0
    else
        export BASH_IN_SUBSHELL=1
    fi
    return ${BASH_IN_SUBSHELL}
}

----

==== `bashmatic.run-if-subshell`

[source,bash]
----
bashmatic.run-if-subshell () 
{ 
    local current_shell=$(ps -p $$ -o comm | grep -v COMM | sed 's/-//g')
    set +e
    if [[ ${current_shell} == "bash" ]]; then
        local len="${#BASH_SOURCE[@]}"
        local last_index=$((len - 1))
        local last_script="${BASH_SOURCE[${last_index}]}"
        [[ ${last_index} -lt 0 ]] && last_index=0
        is-dbg && dbg "Detected BASH, last script name is [${last_script}], sourcing in [$0], is it sourced in? "
        if [[ -n ${BASH_VERSION} && "$0" != "${BASH_SOURCE[${last_index}]}" ]]; then
            is-dbg && dbg "YES"
            return 0
        else
            is-dbg && dbg "NO"
            eval "$*"
        fi
    else
        if [[ ${current_shell} == "zsh" ]]; then
            is-dbg && dbg "Detected ZSH, ZSH_EVAL_CONTEXT = [${ZSH_EVAL_CONTEXT}], is it sourced in?"
            if [[ -n ${ZSH_EVAL_CONEXT} && ${ZSH_EVAL_CONTEXT} =~ :shfunc$ ]]; then
                is-dbg && dbg "YES"
                return 0
            else
                is-dbg && dbg "NO"
                eval "$*"
            fi
        else
            error "SHELL ${current_shell} is not supported."
            return 1
        fi
    fi
}

----

==== `bashmatic.subshell-init`

[source,bash]
----
bashmatic.subshell-init () 
{ 
    export BASH_SUBSHELL_DETECTED=
}

----

==== `bashmatic.validate-sourced-in`

[source,bash]
----
bashmatic.validate-sourced-in () 
{ 
    bashmatic.detect-subshell
    [[ ${BASH_IN_SUBSHELL} -eq 0 ]] || { 
        echo "This script is meant to be sourced in, not run in a subshell." 1>&2
        return 1
    }
    return 0
}

----

==== `bashmatic.validate-subshell`

[source,bash]
----
bashmatic.validate-subshell () 
{ 
    bashmatic.detect-subshell
    [[ ${BASH_IN_SUBSHELL} -eq 1 ]] || { 
        echo "This script is meant to be run, not sourced-in" 1>&2
        return 1
    }
    return 0
}

----


=== Module `sym`

==== `decrypt.secrets`

[source,bash]
----
decrypt.secrets () 
{ 
    ./bin/decrypt
    local code=$?
    [[ ${code} != 0 ]] && { 
        error "bin/decrypt returned non-zero exit status ${code}"
        echo
        exit ${code}
    }
}

----

==== `dev.crypt.chef`

[source,bash]
----
dev.crypt.chef () 
{ 
    sym -ck APP_CHEF_SYM_KEY "$*"
}

----

==== `dev.decrypt.file`

[source,bash]
----
dev.decrypt.file () 
{ 
    [[ -f ${1} ]] || { 
        error 'usage: dev.decrypt.file <filename.enc>'
        return
    }
    sym -ck APP_SYM_KEY -n "${1}"
}

----

==== `dev.decrypt.str`

[source,bash]
----
dev.decrypt.str () 
{ 
    [[ -z ${1} ]] && { 
        error 'usage: dev.decrypt.str "string to decrypt"'
        return
    }
    sym -ck APP_SYM_KEY -d -s "$*"
}

----

==== `dev.edit.file`

[source,bash]
----
dev.edit.file () 
{ 
    [[ -f ${1} ]] || { 
        error 'usage: dev.edit.file <filename>'
        return
    }
    sym -ck APP_SYM_KEY -t "${1}"
}

----

==== `dev.encrypt.file`

[source,bash]
----
dev.encrypt.file () 
{ 
    [[ -f ${1} ]] || { 
        error 'usage: dev.encrypt.file <filename>'
        return
    }
    sym -ck APP_SYM_KEY -e -f "${1}" -o "${1}.enc"
}

----

==== `dev.encrypt.str`

[source,bash]
----
dev.encrypt.str () 
{ 
    [[ -z "${1}" ]] && { 
        error 'usage: dev.encrypt.str "string to encrypt"'
        return
    }
    sym -ck APP_SYM_KEY -e -s "$*"
}

----

==== `dev.sym`

[source,bash]
----
dev.sym () 
{ 
    sym -cqk APP_SYM_KEY "$*"
}

----

==== `sym.dev.configure`

[source,bash]
----
sym.dev.configure () 
{ 
    export SYMIT__KEY="APP_SYM_KEY"
}

----

==== `sym.dev.files`

[source,bash]
----
sym.dev.files () 
{ 
    find . -name '*.enc' -type f
}

----

==== `sym.dev.have-key`

[source,bash]
----
sym.dev.have-key () 
{ 
    sym.dev.configure
    if [[ -z ${CI} ]]; then
        [[ -z "$(keychain ${SYMIT__KEY} find 2> /dev/null)" ]] || printf "yes"
    else
        [[ -n "${APP_SYM_KEY}" ]] && print "yes"
    fi
}

----

==== `sym.dev.import`

[source,bash]
----
sym.dev.import () 
{ 
    local skip_instructions=${1:-0}
    if [[ ${BASHMATIC_OS} != 'darwin' ]]; then
        error 'This is only meant to run on Mac OS-X'
        return
    fi
    sym.dev.configure
    sym.install.symit
    [[ -f ~/.sym.symit.bash ]] && source ~/.sym.symit.bash
    h2 'Encryption Key Import'
    info "Checking for the existence of the current key..."
    if [[ -n "$(sym.dev.have-key)" ]]; then
        info: "Key ${SYMIT_KEY} is already in you your OS-X Key Chain."
        run.ui.ask "Would you like to re-import it?"
        [[ $? != 0 ]] && return
    fi
    if [[ ${skip_instructions} == ${false} ]]; then
        hr
        echo
        info "1. Please open 1Password App and search for 'Encryption Key'"
        echo
        info "2. Once you find the entry, it will contain two items: encryption key"
        info "      and password. Start by copying the key to the clipboard."
        echo
        info "3. You will need to paste the key first, and then copy/paste"
        info "      the key password (also in 1Password)"
        echo
        info "4. As a final setup, you will be asked to create a new password."
        info "      It must be at least 7 characters long, and will be used to encrypt"
        info "      the key locally on your machine."
        echo
        echo
        run.ui.ask "Ready?"
        [[ $? != 0 ]] && return
    fi
    echo
    hr
    sym -iqpx APP_SYM_KEY
    code=$?
    [[ ${code} != 0 ]] && { 
        error "Sym exited with error code ${code}"
        return ${code}
    }
    hr
    echo
    info "Key import was successful, great job! ${bldylw}â˜º "
    info "You can test that it works by encrypting, and decrypting a string,"
    echo
    info "\$ ${bldylw}source bin/bash"
    info "\$ ${bldylw}dev.encrypt.str hello"
    info "\$ ${bldylw}dev.decrypt.str \$(dev.encrypt.str hello )"
    echo
    info "Or a file:"
    info "\$ ${bldylw}dev.decrypt.file config/application.dev.yml.enc"
    echo
    info "You can edit the file as if it wasn't encrypted:"
    info "\$ ${bldylw}dev.edit.file config/application.dev.yml.enc"
    echo
}

----

==== `sym.dev.install-shell-helpers`

[source,bash]
----
sym.dev.install-shell-helpers () 
{ 
    local found=
    declare -a init_files=($(util.shell-init-files))
    for file in "${init_files[@]}"
    do
        f="${file}"
        [[ ! -f "${f}" ]] && continue
        [[ -n $(grep sym.symit "${f}") ]] && { 
            found=${f}
            break
        }
    done
    if [[ -z ${found} ]]; then
        for file in "${init_files[@]}"
        do
            f="${file}"
            if [[ -f "${f}" ]]; then
                run "sym -B ${f} 1>/dev/null"
                return $?
            fi
        done
    else
        run "sym -B ${found} 1>/dev/null"
    fi
}

----

==== `sym.install.symit`

[source,bash]
----
sym.install.symit () 
{ 
    if [[ ! -f config.ru ]]; then
        error "Please run this command from the RAILS_ROOT folder"
        return 1
    fi
    [[ -n "$(which sym 2> /dev/null)" && -f ~/.sym.symit.bash ]] && return
    local symit_source="/tmp/sym.symit.bash.$$"
    trap "rm -f ${symit__source}; " EXIT
    local symit_url="https://raw.githubusercontent.com/kigster/sym/master/bin/sym.symit.bash"
    local cmd="curl -fsSL ${symit_url} -o ${symit_source}"
    export LibRun__AbortOnError=${True}
    run "${cmd}"
    if [[ ! -f ${symit_source} ]]; then
        err "unable to find downloaded file ${symit_source}"
        return 1
    fi
    source ${symit_source}
    rm -f ${symit_source}
    run "symit install"
    sym.dev.install-shell-helpers
}

----


=== Module `text`

==== `text.chr`

[source,bash]
----
text.chr () 
{ 
    [ "$1" -lt 256 ] || return 1
    printf "\\$(printf '%03o' "$1")"
}

----

==== `text.markdown-to-asciidoc`

[source,bash]
----
text.markdown-to-asciidoc () 
{ 
    local file="$1"
    shift
    local default_flags="--imagesdir=/assets/images --no-html-to-native"
    [[ -n $(command -v kramdoc) ]] || gem.install "kramdown-asciidoc"
    if [[ -z "${file}" ]]; then
        usage.set-min-flag-len 1
        usage-box "text.markdown-to-asciidoc markdown-file [ flags ] Â© Converts a markdown doc to asciidoc using the kramdown-asciidoc ruby gem" " " "Default flags: ${bldcyn}${default_flags}" " " "To override pass any flags that are supported by ${bldred}kramdoc${bldylw}, see below:"
        printf "\n${txtblu}"
        kramdoc --help | tail -16
        printf "${clr}\n"
        return 0
    fi
    [[ -f ${file} && $(file.extension "${file}") == "md" ]] || { 
        error "File ${file} either does not exist, or is not markdown."
        run.set-all on-decline-return
        run.ui.ask "Convert anyway?"
    }
    local target="$(file.extension.replace adoc "${file}")"
    file.ask.if-exists "${target}" || { 
        info "Aborting conversion, leaving ${target} in place."
        return 1
    }
    gem.install "kramdown-asciidoc"
    local args
    if [[ -z "$*" ]]; then
        args="--auto-ids --auto-id-prefix=_ --auto-id-separator=_ --imagesdir=/assets/images --no-html-to-native"
    else
        args="$*"
    fi
    run "kramdoc -o ${target} ${args} ${file}"
}

----

==== `text.ord`

[source,bash]
----
text.ord () 
{ 
    LC_CTYPE=C printf '%d' "'$1"
}

----


=== Module `time`

==== `date.now.with-time`

[source,bash]
----
date.now.with-time () 
{ 
    date '+%F ' | tr -d '\n'
    time.now.with-ms
}

----

==== `date.now.with-time.and.zone`

[source,bash]
----
date.now.with-time.and.zone () 
{ 
    ( date '+%F '
    time.now.with-ms
    date '+ %z' ) | tr -d '\n'
}

----

==== `epoch`

[source,bash]
----
epoch () 
{ 
    date +%s
}

----

==== `millis`

[source,bash]
----
millis () 
{ 
    .run.millis
}

----

==== `time.a-command`

[source,bash]
----
time.a-command () 
{ 
    local start="$(millis)"
    eval "$*"
    local end="$(millis)"
    local ruby_expr="secs=(0.0 + ${end} - ${start}).to_f/1000.0; mins=secs/60; secs=( secs - secs/60 ) if mins > 0 ; printf('%d minutes %2.3f seconds', mins, secs)"
    local duration=$(ruby -e "${ruby_expr}")
    echo -en "${duration}"
}

----

==== `time.date-from-epoch`

[source,bash]
----
time.date-from-epoch () 
{ 
    local epoch_ts="$1"
    if [[ "${BASHMATIC_OS}" == "darwin" ]]; then
        printf "date -r ${epoch_ts}"
    else
        printf "date --date='@${epoch_ts}'"
    fi
}

----

==== `time.duration.humanize`

[source,bash]
----
time.duration.humanize () 
{ 
    local seconds=${1}
    local hours=$((seconds / 3600))
    local remainder=$((seconds - hours * 3600))
    local mins=$((remainder / 60))
    local secs=$((seconds - hours * 3600 - mins * 60))
    local prefixed=0
    [[ ${hours} -gt 0 ]] && { 
        printf "%02dh:" ${hours}
        prefixed=1
    }
    [[ ${mins} -gt 0 || ${prefixed} == 1 ]] && { 
        printf "%02dm:" ${mins}
        prefixed=1
    }
    { 
        printf "%02ds" ${secs}
    }
}

----

==== `time.duration.millis-to-secs`

[source,bash]
----
time.duration.millis-to-secs () 
{ 
    local duration="$1"
    local format="${2:-"%d.%d"}"
    local seconds=$((duration / 1000))
    local leftover=$((duration - 1000 * seconds))
    printf "${format}" ${seconds} ${leftover}
}

----

==== `time.epoch-to-iso`

[source,bash]
----
time.epoch-to-iso () 
{ 
    local epoch_ts=$1
    eval "$(time.date-from-epoch "${epoch_ts}") -u \"+%Y-%m-%dT%H:%M:%S%z\"" | sed 's/0000/00:00/g'
}

----

==== `time.epoch-to-local`

[source,bash]
----
time.epoch-to-local () 
{ 
    local epoch_ts=$1
    [[ -z ${epoch_ts} ]] && epoch_ts=$(epoch)
    eval "$(time.date-from-epoch "${epoch_ts}") \"+%m/%d/%Y, %r\""
}

----

==== `time.epoch.minutes-ago`

[source,bash]
----
time.epoch.minutes-ago () 
{ 
    local mins=${1}
    [[ -z ${mins} ]] && mins=1
    local seconds=$((mins * 60))
    local now_epoch=$(epoch)
    echo $((now_epoch - seconds))
}

----

==== `time.now.db`

[source,bash]
----
time.now.db () 
{ 
    date '+%F.%T.%S   ' | tr -d '\:\-\.'
}

----

==== `time.now.file-extension`

[source,bash]
----
time.now.file-extension () 
{ 
    time.now.db
}

----

==== `time.now.with-ms`

[source,bash]
----
time.now.with-ms () 
{ 
    util.os
    local date_runnable
    date_runnable='date'
    if [[ "${BASHMATIC_OS}" == "darwin" ]]; then
        [[ -z $(command -v gdate) ]] && .time.osx.coreutils
        [[ -n $(command -v gdate) ]] && date_runnable='gdate'
    fi
    ${date_runnable} '+%T.%3N'
}

----

==== `time.with-duration`

[source,bash]
----
time.with-duration () 
{ 
    local quiet=false
    local verbose=false
    local secret=false
    [[ "$1" == quiet ]] && { 
        shift
        quiet=true
    }
    [[ "$1" == verbose ]] && { 
        shift
        verbose=true
    }
    [[ "$1" == secret ]] && { 
        shift
        secret=true
    }
    local -a command=("$@")
    local marker="$(util.random-string 10)"
    time.with-duration.start "${marker}"
    local cmd="${command[*]}"
    ${quiet} && cmd+=">/dev/null 2>&1"
    if ${secret}; then
        ${verbose} && inf "ðŸ¤žðŸ¼ Running Command: ${txtblk}${bakblu}[REDACTED]"
    else
        ${verbose} && inf "ðŸ¤žðŸ¼ Running Command: ${txtblk}${bakblu}${cmd}"
    fi
    set +e
    local code=0
    /usr/bin/env bash -c "${cmd}"
    code=$?
    if ${verbose}; then
        if [[ ${code} -eq 0 ]]; then
            ok:
            hr
            info "â³ Total time taken: ${bldgrn}$(time.with-duration.end "${marker}"), command successful."
        else
            not-ok:
            hr
            info "â³ Total time taken: ${bldred}$(time.with-duration.end "${marker}"), exit code: ${bldred}${code}"
        fi
    fi
    return ${code}
}

----

==== `time.with-duration.clear`

[source,bash]
----
time.with-duration.clear () 
{ 
    local name="$1"
    eval "unset __bashmatic_with_duration_ms${name}"
}

----

==== `time.with-duration.end`

[source,bash]
----
time.with-duration.end () 
{ 
    local name="$1"
    shift
    [[ -z ${name} ]] && name="_default"
    local var="__bashmatic_with_duration_ms${name}"
    local started=$(.subst ${var})
    [[ -z ${started} ]] && started=${!var}
    [[ -z ${started} ]] && { 
        error "No start time recorded for namespace ${name}."
        return 1
    }
    local finished="$(millis)"
    local duration=$((finished - started))
    duration="$(time.duration.millis-to-secs "${duration}")"
    printf -- "$* %s\n" "${duration} sec"
}

----

==== `time.with-duration.start`

[source,bash]
----
time.with-duration.start () 
{ 
    local name="$1"
    [[ -z ${name} ]] && name="_default"
    eval "export __bashmatic_with_duration_ms${name}=$(millis)"
}

----

==== `today`

[source,bash]
----
today () 
{ 
    date +'%Y-%m-%d'
}

----


=== Module `trap`

==== `trap-setup`

[source,bash]
----
trap-setup () 
{ 
    .trap-remove
    local signal="${1:-"SIGINT"}"
    trap '.trap-catch' "${signal}"
    export __int_signal__="${signal}"
}

----

==== `trap-was-fired`

[source,bash]
----
trap-was-fired () 
{ 
    if [[ -n "${__int_marker__}" && -f "${__int_marker__}" ]]; then
        rm -f "${__int_marker__}"
        return 0
    fi
    return 1
}

----

==== `trapped`

[source,bash]
----
trapped () 
{ 
    if [[ ${__int_flag__} -eq 1 ]]; then
        unset __int__flag__
        return 0
    fi
    return 1
}

----


=== Module `url`

==== `url.cert.domain`

[source,bash]
----
url.cert.domain () 
{ 
    url.cert.info "$@" | grep 'subject: CN=' | cut -d '=' -f 2
}

----

==== `url.cert.info`

[source,bash]
----
url.cert.info () 
{ 
    local url="$1"
    local quiet="${2:-false}"
    [[ ${url} =~ https:// ]] || url="https://${url}"
    url.host.is-valid "${url}" || return 1
    curl --insecure -vvI "${url}" 2>&1 | awk 'BEGIN { cert=0 } 
        /^\* SSL connection/ { cert=1 } /^\*/ { if (cert) print }'
}

----

==== `url.cert.is-valid`

[source,bash]
----
url.cert.is-valid () 
{ 
    local url="$1"
    shift
    [[ ${url} =~ https:// ]] || url="https://${url}"
    curl -L -q -I "${url}" "$@" > /dev/null 2>&1
}

----

==== `url.downloader`

[source,bash]
----
url.downloader () 
{ 
    local downloader=
    if [[ -z "${LibUrl__Downloader}" ]]; then
        [[ -z "${downloader}" && -n $(which curl) ]] && downloader="$(which curl) ${LibUrl__CurlDownloaderFlags}"
        [[ -z "${downloader}" && -n $(which wget) ]] && downloader="$(which wget) ${LibUrl__WgetDownloaderFlags}"
        [[ -z "${downloader}" ]] && { 
            error "Neither Curl nor WGet appear in the \$PATH... HALP?"
            return 1
        }
        export LibUrl__Downloader="${downloader}"
    fi
    printf "${LibUrl__Downloader}"
}

----

==== `url.host.is-valid`

[source,bash]
----
url.host.is-valid () 
{ 
    local host="$1"
    local host="${host/https:\/\//}"
    host "${host}" > /dev/null || { 
        error "${host} does not appear to be a valid host." 1>&2
        return 255
    }
}

----

==== `url.http-code`

[source,bash]
----
url.http-code () 
{ 
    local url="$1"
    local quiet="${2:-false}"
    [[ -z $(which wget) ]] && { 
        echo 1>&2
        err "This function currently only supports ${bldylw}wget.\n" 1>&2
        echo 1>&2
        return 100
    }
    url.is-valid "$url" || { 
        echo 1>&2
        err "The URL provided is not a valid URL: ${bldylw}${url}\n" 1>&2
        echo 1>&2
        return 101
    }
    local result=$(wget -v --spider "${url}" 2>&1 | ${GrepCommand} "response" | awk '{print $6}' | tr -d ' ' | tail -1)
    export LibUrl__LastHttpCode="${result}"
    if [[ ${quiet} == true ]]; then
        if [[ ${result} -gt 199 && ${result} -lt 210 ]]; then
            return 0
        else
            return 1
        fi
    else
        [[ -n "${result}" ]] && printf "${result}" || printf "404"
    fi
}

----

==== `url.is-valid`

[source,bash]
----
url.is-valid () 
{ 
    local url="$1"
    if [[ $(url.valid-status "$url") = "ok" ]]; then
        return 0
    else
        return 1
    fi
}

----

==== `url.shorten`

[source,bash]
----
url.shorten () 
{ 
    local longUrl="$1"
    error "This function used Bitly API V3 which is now defunct."
    return 1
    if [[ -z "${BITLY_LOGIN}" || -z "${BITLY_API_KEY}" ]]; then
        printf "${longUrl}"
    else
        export BITLY_LOGIN=$(printf '%s' "${BITLY_LOGIN}" | tr -d '\r' | tr -d '\n')
        export BITLY_API_KEY=$(printf '%s' "${BITLY_API_KEY}" | tr -d '\r' | tr -d '\n')
        if [[ -n $(which ruby) ]]; then
            longUrl=$(ruby -e "require 'uri'; str = '${longUrl}'.force_encoding('ASCII-8BIT'); puts URI.encode(str)")
        fi
        bitlyUrl="http://api.bit.ly/v3/shorten?login=${BITLY_LOGIN}&apiKey=${BITLY_API_KEY}&format=txt&longURL=${longUrl}"
        debug "BITLY_LOLGIN : ${clr}${bldylw}${BITLY_LOGIN}" 1>&2
        debug "BITLY_LOLGIN : ${clr}${bldgrn}${BITLY_API_KEY}" 1>&2
        debug "BITLY_API_URL: ${clr}${undblu}${bitlyUrl}${clr}" 1>&2
        local output="$($(url.downloader) "${bitlyUrl}" 2>&1)"
        if [[ "${output}" =~ "INVALID" || "${output}" =~ "Server Error" ]]; then
            error "${output}"
            return 1
        else
            printf "%s" "${output}" | tr -d '\n' | tr -d ' '
            return 0
        fi
    fi
}

----

==== `url.valid-status`

[source,bash]
----
url.valid-status () 
{ 
    local url="$1"
    echo "${url}" | ruby -ne '
    require "uri"
    u = URI.parse("#{$_}".chomp)
    if u && u.host && u.host&.include?(".") && u&.scheme =~ /^http/
      print "ok"
    else
      print "invalid"
    end'
}

----


=== Module `usage`

==== `help-command`

[source,bash]
----
help-command () 
{ 
    printf "    ${bldylw}\$ $*\n"
}

----

==== `help-comment`

[source,bash]
----
help-comment () 
{ 
    printf "    ${txtblk}# $*\n"
}

----

==== `help-details`

[source,bash]
----
help-details () 
{ 
    printf "    ${txtblu}$*\n"
}

----

==== `help-example`

[source,bash]
----
help-example () 
{ 
    printf "    ${bldgrn}\$ $*\n"
}

----

==== `help-name`

[source,bash]
----
help-name () 
{ 
    box.white-on-green "$@"
}

----

==== `help-section`

[source,bash]
----
help-section () 
{ 
    printf "\n${bldgrn}$(echo "$*" | tr '[:lower:]' '[:upper:]')\n"
}

----

==== `usage-box`

[source,bash]
----
usage-box () 
{ 
    local backup="$(.usage-cache-file)"
    if [[ "${EXPIRE_USAGE_CACHE}" -eq 0 && -s "${backup}" ]]; then
        cat "${backup}"
    else
        .usage.box "$@" | tee "${backup}"
    fi
}

----

==== `usage-box.section`

[source,bash]
----
usage-box.section () 
{ 
    printf "${__color_headers}"
    .usage.hdr "$*"
}

----

==== `usage-box.sub-section`

[source,bash]
----
usage-box.sub-section () 
{ 
    .output.box-separator "${__color_bdr}"
    .output.boxed-text "${__color_bdr}" "${__color_sub_headers}" "$(.usage.hdr "$1")"
}

----

==== `usage-widget`

[source,bash]
----
usage-widget () 
{ 
    local width="$1"
    local cache_wipe=0
    [[ ${width} =~ ^- ]] && { 
        cache_wipe=1
        width=${width:1}
    }
    is.numeric "${width}" && { 
        shift
        bashmatic.set-widget-width-to "${width}"
    }
    ((cache_wipe)) && rm -f "$(.usage-cache-file)"
    local -a args=("$@")
    is-debug && { 
        h1 "Got total of ${#args[@]} arguments."
    }
    local -a details
    local left_space
    left_space="$(cursor.right 1) "
    if [[ ${#args[@]} -gt 2 ]]; then
        for i in $(seq 2 50)
        do
            [[ -z ${args[$i]} ]] && break
            if [[ ${args[$i]} =~ ^Â® ]]; then
                details+=("$(cursor.left 4)$(usage-box.section "${args[$i]/Â®/}")")
                details+=(" ")
            else
                details+=("${left_space}")
                details+=("$(cursor.left 6)${args[$i]}")
            fi
        done
    fi
    usage-box "${args[0]} Â© ${args[1]}" "$(cursor.up 1; cursor.left 5)" "$(cursor.right 10)" "${details[@]}"
}

----

==== `usage.set-min-flag-len`

[source,bash]
----
usage.set-min-flag-len () 
{ 
    export LibUsage__MinFlagLen="${1}"
}

----


=== Module `user`

==== `user`

[source,bash]
----
user () 
{ 
    local user
    user=$(user.finger.name)
    [[ -z "${user}" ]] && user="$(user.gitconfig.name)"
    [[ -z "${user}" ]] && user="$(user.gitconfig.email)"
    [[ -z "${user}" ]] && user="$(user.username)"
    echo "${user}"
}

----

==== `user.current-shell`

[source,bash]
----
user.current-shell () 
{ 
    /bin/ps -p $$ -o comm | tail -1 | sed -E 's/-//g'
}

----

==== `user.current-shell-init-file`

[source,bash]
----
user.current-shell-init-file () 
{ 
    declare -a shell_files=($(util.shell-init-files "$(user.current-shell)"))
    .user.pick-shell-init-file "${shell_files[@]}"
}

----

==== `user.finger.name`

[source,bash]
----
user.finger.name () 
{ 
    [[ -n $(which finge) ]] && finger "${USER}" | head -1 | sedx 's/.*Name: //g'
}

----

==== `user.first`

[source,bash]
----
user.first () 
{ 
    user | tr '\n' ' ' | ruby -ne 'puts $_.split(/ /).first.capitalize'
}

----

==== `user.gitconfig.email`

[source,bash]
----
user.gitconfig.email () 
{ 
    if [[ -s ${HOME}/.gitconfig ]]; then
        grep email "${HOME}/.gitconfig" | sedx 's/.*=\s?//g'
    fi
}

----

==== `user.gitconfig.name`

[source,bash]
----
user.gitconfig.name () 
{ 
    if [[ -s ${HOME}/.gitconfig ]]; then
        grep name "${HOME}/.gitconfig" | sedx 's/.*=\s?//g'
    fi
}

----

==== `user.host`

[source,bash]
----
user.host () 
{ 
    local host=
    host=$(user.my.reverse-ip)
    [[ -z ${host} ]] && host=$(user.my.ip)
    printf "${host}"
}

----

==== `user.login-shell`

[source,bash]
----
user.login-shell () 
{ 
    basename "$(user.login-shell-path)"
}

----

==== `user.login-shell-init-file`

[source,bash]
----
user.login-shell-init-file () 
{ 
    declare -a shell_files=($(util.shell-init-files))
    .user.pick-shell-init-file "${shell_files[@]}"
}

----

==== `user.login-shell-path`

[source,bash]
----
user.login-shell-path () 
{ 
    if [[ -n $(command -v finger 2> /dev/null) ]]; then
        finger "${USER}" | grep Shell: | sed 's/^.*Shell: //g'
    else
        if grep -q "${USER}" /etc/passwd 2> /dev/null; then
            grep "${USER}" /etc/passwd | sed 's/.*://g'
        else
            command -v "$(user.current-shell)"
        fi
    fi
}

----

==== `user.my.ip`

[source,bash]
----
user.my.ip () 
{ 
    dig +short myip.opendns.com @resolver1.opendns.com
}

----

==== `user.my.reverse-ip`

[source,bash]
----
user.my.reverse-ip () 
{ 
    nslookup "$(user.my.ip)" | grep 'name =' | sedx 's/.*name = //g'
}

----

==== `user.pairs.email`

[source,bash]
----
user.pairs.email () 
{ 
    [[ ! -s "${bashmatic_git_pairs}" || -z "$1" ]] && return
    local username="$(user.pairs.username "$1")"
    local domain="$(grep domain "${bashmatic_git_pairs}" | sed 's/.*domain://g' | tr -d ' ')"
    [[ -n ${username} && -n "${domain}" ]] || { 
        error "Couldn't determine username or domain from ${bashmatic_git_pairs} file for input ${bldwht}$*"
        return 1
    }
    echo "${username}@${domain}"
}

----

==== `user.pairs.firstname`

[source,bash]
----
user.pairs.firstname () 
{ 
    [[ ! -s "${bashmatic_git_pairs}" || -z "$1" ]] && return
    grep -i "$1" "${bashmatic_git_pairs}" | head -1 | awk '{print $2}' | tr -d ';'
}

----

==== `user.pairs.lastname`

[source,bash]
----
user.pairs.lastname () 
{ 
    [[ ! -s "${bashmatic_git_pairs}" || -z "$1" ]] && return
    grep -i "$1" "${bashmatic_git_pairs}" | head -1 | awk '{print $3}' | tr -d ';'
}

----

==== `user.pairs.set-file`

[source,bash]
----
user.pairs.set-file () 
{ 
    [[ -s "$1" ]] || { 
        error "Please pass a valid path to the .pairs file, typically in your home. You passed: [$1]"
        return 1
    }
    export bashmatic_git_pairs="$1"
}

----

==== `user.pairs.username`

[source,bash]
----
user.pairs.username () 
{ 
    [[ ! -s "${bashmatic_git_pairs}" || -z "$1" ]] && return
    grep -i "$1" "${bashmatic_git_pairs}" | head -1 | awk '{print $4}' | tr -d ';'
}

----

==== `user.username`

[source,bash]
----
user.username () 
{ 
    echo "${USER:-$(whoami)}"
}

----


=== Module `util`

==== `is-func`

[source,bash]
----
is-func () 
{ 
    is.a-function "$@"
}

----

==== `pause`

[source,bash]
----
pause () 
{ 
    sleep "${1:-1}"
}

----

==== `pause.long`

[source,bash]
----
pause.long () 
{ 
    sleep "${1:-10}"
}

----

==== `pause.medium`

[source,bash]
----
pause.medium () 
{ 
    sleep "${1:-0.3}"
}

----

==== `pause.short`

[source,bash]
----
pause.short () 
{ 
    sleep "${1:-0.1}"
}

----

==== `system.save-os-name`

[source,bash]
----
system.save-os-name () 
{ 
    local _os=""
    __os="$($(system.uname) -s | tr '[:upper:]' '[:lower:]' | tr -d '\n')"
    [[ -z "${BASHMATIC_OS_NAME}" ]] && export BASHMATIC_OS_NAME="${__os}" > /dev/null 2>&1
    export BASHMASTIC_OS="${BASHMATIC_OS_NAME}"
}

----

==== `system.uname`

[source,bash]
----
system.uname () 
{ 
    command -v uname && return 0
    [[ -x ${__bashmatic_uname_binary} && -x ${__bashmatic_uname_binary} ]] && { 
        echo ${__bashmatic_uname_binary}
        return 0
    }
    local -a uname_options=("/bin/uname" "/usr/bin/uname" "/sbin/uname" "/usr/sbin/uname")
    local binary
    for binary in ${uname_options[@]}
    do
        [[ -x ${binary} ]] && { 
            export __bashmatic_uname_binary="$(printf -- "%s" "${binary}")"
            printf "%s" "${__bashmatic_uname_binary}"
            return 0
        }
    done
    return 1
}

----

==== `util.append-to-init-files`

[source,bash]
----
util.append-to-init-files () 
{ 
    local string="$1"
    local search="${2:-$1}"
    is_installed=
    declare -a shell_files=($(util.shell-init-files))
    for init_file in "${shell_files[@]}"
    do
        file="${init_file}"
        [[ -f ${file} ]] && grep -q "${search}" "${file}" && { 
            is_installed=${file}
            break
        }
    done
    if [[ -z "${is_installed}" ]]; then
        for init_file in "${shell_files[@]}"
        do
            file="${init_file}"
            [[ -f ${file} ]] && { 
                echo "${string}" >> "${file}"
                is_installed="${file}"
                break
            }
        done
    fi
    printf "${is_installed}"
}

----

==== `util.arch`

[source,bash]
----
util.arch () 
{ 
    echo -n "${BASHMATIC_OS}-$($(system.uname) -m)-$($(system.uname) -p)" | /usr/bin/tr '[:upper:]' '[:lower:]'
}

----

==== `util.call-if-function`

[source,bash]
----
util.call-if-function () 
{ 
    local func="$1"
    shift
    util.is-a-function "${func}" && { 
        ${func} "$@"
    }
}

----

==== `util.dev-setup.update`

[source,bash]
----
util.dev-setup.update () 
{ 
    run "rm -f ${BASHMATIC_HOME}/bin/.dev-setup"
    run "dev-setup -N -h > /tmp/a"
    run "mv /tmp/a ${BASHMATIC_HOME}/bin/.dev-setup"
    run "cd ${BASHMATIC_HOME} && git add bin/.dev-setup"
    run "cd -"
}

----

==== `util.eval-function-body`

[source,bash]
----
util.eval-function-body () 
{ 
    local name="$1"
    shift
    type "${name}" | grep -qi function || { 
        error "${name} is not a function."
        return 1
    }
    eval "$(type "${name}" | sedx '1,3d;$d')" "$@"
}

----

==== `util.functions-matching`

[source,bash]
----
util.functions-matching () 
{ 
    local prefix="${1}"
    local extra_command=${2:-"cat"}
    declare -f | ${GrepCommand} "^${prefix}" | sedx 's/[\(\)]//g;' | /usr/bin/tr -d ' ' | /usr/bin/tr '\n' ' '
}

----

==== `util.functions-matching.diff`

[source,bash]
----
util.functions-matching.diff () 
{ 
    while true; do
        [[ -z "$1" ]] && break
        for e in $(util.functions-matching "${1}")
        do
            printf "${e/$1/}\n"
        done
        shift
    done
    return 0
}

----

==== `util.functions-starting-with`

[source,bash]
----
util.functions-starting-with () 
{ 
    local prefix="${1}"
    local extra_command=${2:-"cat"}
    set | ${GrepCommand} '^[^ ].* \(\) $' | ${GrepCommand} "^${prefix}" | sedx 's/[\(\)]//g;' | ${extra_command} | /usr/bin/tr '\n ' ' '
}

----

==== `util.functions-starting-with-csv`

[source,bash]
----
util.functions-starting-with-csv () 
{ 
    local prefix="$1"
    util.functions-starting-with "${prefix}" | sedx "s/${prefix/./\\.}//g; s/\s+(\w)/, \1/g;"
}

----

==== `util.functions-starting-with-lines`

[source,bash]
----
util.functions-starting-with-lines () 
{ 
    local prefix="${1}"
    local extra_command=${2:-"cat"}
    set | ${GrepCommand} '^[^ ].* \(\) $' | ${GrepCommand} "^${prefix}" | sedx 's/[\(\)]//g;' | ${extra_command}
}

----

==== `util.generate-password`

[source,bash]
----
util.generate-password () 
{ 
    local len=${1:-32}
    local val=$(($(date '+%s') - 100000 * RANDOM))
    [[ ${val:0:1} == "-" ]] && val=${val/-//}
    printf "$(echo ${val} | shasum -a 512 | awk '{print $1}' | base64 | head -c "${len}")"
}

----

==== `util.i-to-ver`

[source,bash]
----
util.i-to-ver () 
{ 
    version=${1}
    /usr/bin/env ruby -e "ver='${version}'; printf %Q{%d.%d.%d}, ver[1..2].to_i, ver[3..5].to_i, ver[6..8].to_i"
}

----

==== `util.install-direnv`

[source,bash]
----
util.install-direnv () 
{ 
    "${BASHMATIC_HOME}/bin/install-direnv"
}

----

==== `util.invoke-if-function`

[source,bash]
----
util.invoke-if-function () 
{ 
    local namespace="$1"
    shift
    local action="$1"
    shift
    local func="${namespace}.${action}"
    util.is-a-function "${func}" || return 255
    ${func} "$@"
}

----

==== `util.is-a-function`

[source,bash]
----
util.is-a-function () 
{ 
    is.a-function "$@"
}

----

==== `util.is-numeric`

[source,bash]
----
util.is-numeric () 
{ 
    is.numeric "$1"
}

----

==== `util.is-variable-defined`

[source,bash]
----
util.is-variable-defined () 
{ 
    local var_name="$1"
    [[ -n ${!var_name+x} ]]
}

----

==== `util.lines-in-folder`

[source,bash]
----
util.lines-in-folder () 
{ 
    local folder=${1:-'.'}
    find "${folder}" -type f -exec wc -l {} \; | awk 'BEGIN{a=0}{a+=$1}END{print a}'
}

----

==== `util.os`

[source,bash]
----
util.os () 
{ 
    export BASHMATIC_OS="${BASHMATIC_OS_NAME:=$(uname -s | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]')}"
    export BASHMATIC_OS_NAME
}

----

==== `util.random-number`

[source,bash]
----
util.random-number () 
{ 
    local limit="${1:-"1000000"}"
    printf $(((RANDOM % limit)))
}

----

==== `util.random-string.of-length`

[source,bash]
----
util.random-string.of-length () 
{ 
    util.generate-password "$@"
}

----

==== `util.remove-from-init-files`

[source,bash]
----
util.remove-from-init-files () 
{ 
    local search="${1}"
    local backup_extension="${2}"
    [[ -z ${backup_extension} ]] && backup_extension="$(epoch).backup"
    [[ -z ${search} ]] && return
    declare -a shell_files=($(util.shell-init-files))
    local temp_holder=$(mktemp)
    for init_file in "${shell_files[@]}"
    do
        run.config.detail-is-enabled && inf "verifying file ${init_file}..."
        file="${init_file}"
        if [[ -f ${file} ]] && grep -q "${search}" "${file}"; then
            run.config.detail-is-enabled && ui.closer.ok:
            local matches=$(grep -c "${search}" "${file}")
            run.config.detail-is-enabled && info "file ${init_file} matches with ${bldylw}${matches} matches"
            run "grep -v \"${search}\" ${file} > ${temp_holder}"
            if [[ -n "${backup_extension}" ]]; then
                local backup="${file}.${backup_extension}"
                run.config.detail-is-enabled && info "backup file will created in ${bldylw}${backup}"
                [[ -n "${do_backup_changes}" ]] && "mv ${file} ${backup}"
            fi
            run "cp -v ${temp_holder} ${file}"
        else
            run.config.detail-is-enabled && ui.closer.not-ok:
        fi
    done
    return "${LibRun__LastExitCode}"
}

----

==== `util.rot13`

[source,bash]
----
util.rot13 () 
{ 
    local value="$*"
    echo "$value" | util.rot13-stdin
}

----

==== `util.rot13-stdin`

[source,bash]
----
util.rot13-stdin () 
{ 
    ruby -e 'puts STDIN.read.
  tr(
    "0123456789",
    "5678901234").
  tr(
    "abcdefghijklmnopqrstuvwxyz",
    "nopqrstuvwxyzabcdefghijklm").
  tr(
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    "NOPQRSTUVWXYZABCDEFGHIJKLM")'
}

----

==== `util.shell-init-files`

[source,bash]
----
util.shell-init-files () 
{ 
    local shell_function="${1:-"user.login-shell"}"
    local shell_name=$(${shell_function})
    if [[ ${shell_name} == "bash" ]]; then
        echo "${HOME}/.bash_profile ${HOME}/.bash_login ${HOME}/.bashrc ${HOME}/.profile"
    else
        if [[ ${shell_name} == "zsh" ]]; then
            echo "${HOME}/.zshrc"
        else
            error "Shell ${shell_name} is not supported."
            return 1
        fi
    fi
}

----

==== `util.ver-to-i`

[source,bash]
----
util.ver-to-i () 
{ 
    version=${1}
    echo "${version}" | awk 'BEGIN{FS="."}{ printf "1%02d%03.3d%03.3d", $1, $2, $3}'
}

----

==== `var.expand`

[source,bash]
----
var.expand () 
{ 
    .subst "$@"
}

----

==== `watch.command`

[source,bash]
----
watch.command () 
{ 
    [[ -z "$1" ]] && return 1
    trap "return 1" SIGINT
    while true; do
        clear
        hr.colored "${txtblu}"
        printf " â¯ Command: ${bldgrn}$*${clr}  â€¢  ${txtblu}$(date)${clr}  â€¢  Refresh: ${bldcyn}${LibUtil__WatchRefreshSeconds}${clr}\n"
        hr.colored "${txtblu}"
        eval "$*"
        hr.colored "${txtblu}"
        printf "To change refresh rate run ${bldylw}watch.set-refresh <seconds>${clr}\n\n\n"
        sleep "${LibUtil__WatchRefreshSeconds}"
    done
}

----

==== `watch.ls-al`

[source,bash]
----
watch.ls-al () 
{ 
    while true; do
        ls -al
        sleep "${LibUtil__WatchRefreshSeconds}"
        clear
    done
}

----

==== `watch.set-refresh`

[source,bash]
----
watch.set-refresh () 
{ 
    export LibUtil__WatchRefreshSeconds="${1:-"0.5"}"
}

----


=== Module `video`

==== `video.encode`

[source,bash]
----
video.encode () 
{ 
    set +e
    local file="$1"
    shift
    local algo="${1:-"11"}"
    shift
    local output="${1}"
    shift
    [[ -z "${output}" ]] && output=$(video.filename.encoded "${file}" "${algo}")
    output="${output/\.*/\.mkv}"
    [[ "${file}" == "${output}" ]] && output="${output/.mkv/-converted.mkv}"
    is.an-existing-file "${output}" && { 
        info "File ${output} already exists, making a backup..."
        local t="$(time.now.db | tr -d ' ')"
        local backup_output="$(echo "${output}" | sed "s/\.\(.*\)$/-${t}.\1/g")"
        info "Backing up a name clashing file to ${backup_output}..."
        mv -v "${output}" "${backup_output}"
    }
    h2 "Starting \"${ffmpeg_binary}\" conversion, source file size is ${bldred}$(file.size.mb "${file}")" " â€¢ Source:      [${file}]" " â€¢ Destination: [${output}]" " â€¢ Algorithm:   [${algo}]"
    video.install.dependencies
    local func=".video.convert.compress-${algo}"
    is.a-function "${func}" || { 
        error "${func} is not a valid function name."
        return 1
    }
    arrow.blk-on-ylw "Conversion Function: ${func}"
    arrow.blk-on-blu "Source File:         \"${file}\""
    arrow.blk-on-grn "Destination File:    \"${output}\""
    local token=$(echo "${file}" | shasum.sha | cut -f 1 -d ' ')
    time.with-duration.start "${token}"
    info "Please wait while we compress this file... (set DEBUG=1 to see the output)"
    echo
    run.set-all show-output-on abort-on-error
    ${func} "${file}" "${output}"
    run.set-all show-output-off
    local before="$(file.size "${file}")"
    local after="$(file.size "${output}")"
    local reduction=
    local duration=$(time.with-duration.end "${token}")
    if [[ ${before} -lt ${after} ]]; then
        reduction=$((100 * (after - before) / before))
        warning "${output} was generated with ${reduction}%% increase in file size" "from ${before} to ${after}" "and took ${duration}"
    else
        reduction=$((100 * (before - after) / before))
        success "${output} was generated with ${reduction}%% reduction in file size" "from ${before} to ${after}" "and took ${duration}"
    fi
    return 0
}

----

==== `video.filename.encoded`

[source,bash]
----
video.filename.encoded () 
{ 
    local source="$1"
    local algo="${2:-"compressed"}"
    local dest
    dest="$(echo "${source}" | tr ' ' '-' | tr '[:upper:]' '[:lower:]' | sed -E 's/\.(.*)$/-'"${algo}"'.\1/g' | tr -d ' ')"
    printf -- "%s" "${dest}"
}

----

==== `video.install.dependencies`

[source,bash]
----
video.install.dependencies () 
{ 
    brew.cache-reset
    run.set-all verbose-on show-output-on
    set +e
    for package in "${required_packages[@]}"
    do
        brew.package.is-installed "${package}" > /dev/null || brew.install.package "${package}"
    done
    command -v ffmpeg > /dev/null || brew.install.package ffmpeg
    command -v npm > /dev/null || brew.install.package node
    command -v ffmpeg-bar > /dev/null || run "npm install -g ffmpeg-progressbar-cli"
    if ( command -v ffmpeg-bar > /dev/null ); then
        export ffmpeg_binary="ffmpeg-bar"
    else
        export ffmpeg_binary="ffmpeg-y -loglevel error -stats "
    fi
    printf "%s" "${ffmpeg_binary}"
    return 0
}

----

==== `video.make.mp4`

[source,bash]
----
video.make.mp4 () 
{ 
    local file="$1"
    local target="${2}"
    [[ -z "${target}" ]] && target="CC-${file/.MOV/.mp4}"
    [[ -s "${file}" ]] || { 
        error "File [$file] does not exist."
        return 1
    }
    [[ "${file}" == "${target}" ]] && target="COMPRESSED-${target}"
    h1bg "${file} -> ${target}"
    run.set-next show-output-on continue-on-error
    run "ffmpeg -n -loglevel error -stats -i \"${file}\" -c:v libx265 -b:v 4M -x265-params pass=1 -f null /dev/null"
    run "ffmpeg -n -loglevel error -stats -i \"${file}\" -c:v libx265 -b:v 4M -x265-params pass=2 \"${target}\""
}

----

==== `video.shrink`

[source,bash]
----
video.shrink () 
{ 
    [[ -z "$*" ]] && { 
        printf -- "${bldgrn}USAGE:\n    ${bldylw}[ DEBUG=1 ] video-shrink *.mp4${clr}\n"
        return 0
    }
    for file in "$@"
    do
        [[ -s "${file}" ]] || { 
            warning "File ${file} does not exist..."
            continue
        }
        dest="$(.destination-file-name "${file}")"
        h1 "Compressing \"${file}\"" "To \"${dest}\""
        video.encode "${file}" "shrinkwrap" "${dest}"
    done
}

----

==== `video.squeeze`

[source,bash]
----
video.squeeze () 
{ 
    [[ -z "$*" ]] && { 
        printf -- "${bldgrn}USAGE:\n    ${bldylw}[ DEBUG=1 ] video-squeeze *.mp4 *.m4v${clr}\n"
        return 0
    }
    for file in "$@"
    do
        [[ -s "${file}" ]] || { 
            warning "Skipping ${file}..."
            continue
        }
        dest="$(.destination-file-name "${file}")"
        arrow.blk-on-blu "Compressing \"${file}\""
        video.encode "${file}" "11" "${dest}"
    done
}

----


=== Module `vim`

==== `gvim.off`

[source,bash]
----
gvim.off () 
{ 
    vim.gvim-off
}

----

==== `gvim.on`

[source,bash]
----
gvim.on () 
{ 
    vim.gvim-on
}

----

==== `vim.gvim-off`

[source,bash]
----
vim.gvim-off () 
{ 
    vim.setup
    [[ "${EDITOR}" == "vim" ]] && return 0
    local regex_from='^export EDITOR=.*$'
    local regex_to='export EDITOR=vim'
    file.gsub "${LibVim__initFile}" "${regex_from}" "${regex_to}"
    file.gsub "${LibVim__initFile}" '^gvim.on$' 'gvim.off'
    ${GrepCommand} -q "${regex_from}" "${LibVim__initFile}" || echo "${regex_to}" >> "${LibVim__initFile}"
    ${GrepCommand} -q "^gvim\.o" "${LibVim__initFile}" || echo "gvim.off" >> "${LibVim__initFile}"
    eval "
    [[ -n '${BASHMATIC_DEBUG}' ]] && set -x
    export EDITOR=${LibVim__editorGvimOff}
    unalias ${LibVim__editorVi} 2>/dev/null
    unalias ${LibVim__editorGvimOff} 2>/dev/null
  "
}

----

==== `vim.gvim-on`

[source,bash]
----
vim.gvim-on () 
{ 
    vim.setup
    [[ "${EDITOR}" == "gvim" ]] && return 0
    local regex_from='^export EDITOR=.*$'
    local regex_to='export EDITOR=gvim'
    file.gsub "${LibVim__initFile}" "${regex_from}" "${regex_to}"
    file.gsub "${LibVim__initFile}" '^gvim.off$' 'gvim.on'
    ${GrepCommand} -q "${regex_from}" "${LibVim__initFile}" || echo "${regex_to}" >> "${LibVim__initFile}"
    ${GrepCommand} -q "^gvim\.o.*" "${LibVim__initFile}" || echo "gvim.on" >> "${LibVim__initFile}"
    eval "
    [[ -n '${BASHMATIC_DEBUG}' ]] && set -x
    export EDITOR=${LibVim__editorGvimOn}
    alias ${LibVim__editorVi}=${LibVim__editorGvimOn}
    alias ${LibVim__editorGvimOff}=${LibVim__editorGvimOn}
  "
}

----

==== `vim.setup`

[source,bash]
----
vim.setup () 
{ 
    export LibVim__initFile="${HOME}/.bash_profile"
    export LibVim__editorVi="vi"
    export LibVim__editorGvimOn="gvim"
    export LibVim__editorGvimOff="vim"
}

----


=== Module `yaml`

==== `yaml-diff`

[source,bash]
----
yaml-diff () 
{ 
    yaml.diff "$@"
}

----

==== `yaml-dump`

[source,bash]
----
yaml-dump () 
{ 
    yaml.dump "$@"
}

----

==== `yaml.diff`

[source,bash]
----
yaml.diff () 
{ 
    local f1="$1"
    shift
    local f2="$1"
    shift
    [[ -f "$f1" && -f "$f2" ]] || { 
        h2 "USAGE: ${bldylw}yaml-diff file1.yml file2.yml [ ydiff-options ]"
        return 1
    }
    [[ -n $(which ${BashMatic__DiffTool}) ]] || brew.package.install ${BashMatic__DiffTool}
    local t1="/tmp/${RANDOM}.$(basename "${f1}").$$.yml"
    local t2="/tmp/${RANDOM}.$(basename "${f2}").$$.yml"
    yaml.expand-aliases "$f1" > "$t1"
    yaml.expand-aliases "$f2" > "$t2"
    run.set-next show-output-on
    hr
    run "ydiff $* ${t1} ${t2}"
    hr
    run "rm -rf ${t1} ${t2}"
}

----

==== `yaml.dump`

[source,bash]
----
yaml.dump () 
{ 
    local f1="$1"
    shift
    [[ -f "$f1" ]] || { 
        h2 "USAGE: ${bldylw}yaml-dump file.yml"
        return 1
    }
    [[ -n $(which ${BashMatic__DiffTool}) ]] || brew.package.install ${BashMatic__DiffTool}
    local t1="/tmp/${RANDOM}.$(basename "${f1}").$$.yml"
    yaml.expand-aliases "$f1" > "$t1"
    vim "$t1"
    run "rm -rf ${t1}"
}

----

==== `yaml.expand-aliases`

[source,bash]
----
yaml.expand-aliases () 
{ 
    ruby -e "require 'yaml'; require 'json'; puts YAML.dump(JSON.parse(JSON.pretty_generate(YAML.load(File.read('${1}')))))"
}

----


=== Module `yarn`

==== `yarn_install`

[source,bash]
----
yarn_install () 
{ 
    command -v yarn > /dev/null || npm install -g yarn
    if [[ ! -f .yarn.sha || "$(cat .yarn.sha)" != "$(yarn_sha)" ]]; then
        set -x
        yarn install
        set +x
        yarn_sha > .yarn.sha
    fi
}

----

==== `yarn_sha`

[source,bash]
----
yarn_sha () 
{ 
    [[ -f package.json && -f yarn.lock ]] && cat package.json yarn.lock | sha
}

----


=== Module `zsh`

==== `zsh.install`

[source,bash]
----
zsh.install () 
{ 
    zsh.install.plugins
}

----

==== `zsh.install.oh-my-zsh`

[source,bash]
----
zsh.install.oh-my-zsh () 
{ 
    if [[ -d ${HOME}/.oh-my-zsh/ ]]; then
        info "oh-my-zsh is already installed, updating..."
        run "cd ${HOME}/.oh-my-zsh"
        run "git pull || true"
    else
        info "Installing oh-my-zsh..."
        run "sh -c \"\$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\""
    fi
    if [[ -f ${HOME}/.zshrc ]]; then
        run "sed -E -i '' 's/robbyrussell/agnoster/g' ${HOME}/.zshrc"
        run "sed -E -i '' 's/^plugins=.*$/plugins=(git wd golang osx aws brew zsh-completions)/g' ${HOME}/.zshrc"
    fi
}

----

==== `zsh.install.plugins`

[source,bash]
----
zsh.install.plugins () 
{ 
    zsh.install.oh-my-zsh
    local dest="${ZSH_CUSTOM:=${HOME}/.oh-my-zsh/custom}/plugins"
    run "mkdir -p ${dest}"
    [[ -d ${dest}/zsh-completions ]] || { 
        run "git clone https://github.com/zsh-users/zsh-completions ${dest}/zsh-completions"
    }
    [[ -d ${dest}/brew ]] || { 
        run "mkdir ${dest}/brew"
        run "curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/plugins/brew/brew.plugin.zsh > ${dest}/brew/brew.plugin.zsh"
    }
}

----



== Copyright



Â© 2016-2022 Konstantin Gredeskoul, All rights reserved, MIT License.