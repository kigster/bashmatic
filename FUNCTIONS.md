## BashMatic Functions Index

  * [`abort`](#abort)
  * [`ansi`](#ansi)
  * [`array-bullet-list`](#array-bullet-list)
  * [`array-contains-element`](#array-contains-element)
  * [`array-csv`](#array-csv)
  * [`array-join`](#array-join)
  * [`array-piped`](#array-piped)
  * [`ascii-clean`](#ascii-clean)
  * [`aws.ec2`](#awsec2)
  * [`aws.rds.hostname`](#awsrdshostname)
  * [`aws.s3.upload`](#awss3upload)
  * [`bashmatic-set-fqdn`](#bashmatic-set-fqdn)
  * [`bashmatic-term`](#bashmatic-term)
  * [`bashmatic-term-program`](#bashmatic-term-program)
  * [`bashmatic.auto-update`](#bashmaticauto-update)
  * [`bashmatic.functions`](#bashmaticfunctions)
  * [`bashmatic.functions-from`](#bashmaticfunctions-from)
  * [`bashmatic.functions.output`](#bashmaticfunctionsoutput)
  * [`bashmatic.functions.runtime`](#bashmaticfunctionsruntime)
  * [`bashmatic.load-at-login`](#bashmaticload-at-login)
  * [`bashmatic.reload`](#bashmaticreload)
  * [`bashmatic.version`](#bashmaticversion)
  * [`bashmatic::detect-subshell`](#bashmaticdetect-subshell)
  * [`bashmatic::subshell-init`](#bashmaticsubshell-init)
  * [`bashmatic::validate-sourced-in`](#bashmaticvalidate-sourced-in)
  * [`bashmatic::validate-subshell`](#bashmaticvalidate-subshell)
  * [`bold`](#bold)
  * [`box::blue-in-green`](#boxblue-in-green)
  * [`box::blue-in-yellow`](#boxblue-in-yellow)
  * [`box::green-in-cyan`](#boxgreen-in-cyan)
  * [`box::green-in-green`](#boxgreen-in-green)
  * [`box::green-in-magenta`](#boxgreen-in-magenta)
  * [`box::green-in-yellow`](#boxgreen-in-yellow)
  * [`box::magenta-in-blue`](#boxmagenta-in-blue)
  * [`box::magenta-in-green`](#boxmagenta-in-green)
  * [`box::red-in-magenta`](#boxred-in-magenta)
  * [`box::red-in-red`](#boxred-in-red)
  * [`box::red-in-yellow`](#boxred-in-yellow)
  * [`box::yellow-in-blue`](#boxyellow-in-blue)
  * [`box::yellow-in-red`](#boxyellow-in-red)
  * [`box::yellow-in-yellow`](#boxyellow-in-yellow)
  * [`br`](#br)
  * [`bundle.gems-with-c-extensions`](#bundlegems-with-c-extensions)
  * [`center`](#center)
  * [`change-underscan`](#change-underscan)
  * [`columnize`](#columnize)
  * [`command-spacer`](#command-spacer)
  * [`cookie-dump`](#cookie-dump)
  * [`cursor.at.x`](#cursoratx)
  * [`cursor.at.y`](#cursoraty)
  * [`cursor.down`](#cursordown)
  * [`cursor.left`](#cursorleft)
  * [`cursor.rewind`](#cursorrewind)
  * [`cursor.right`](#cursorright)
  * [`cursor.up`](#cursorup)
  * [`debug`](#debug)
  * [`decrypt.secrets`](#decryptsecrets)
  * [`duration`](#duration)
  * [`epoch`](#epoch)
  * [`err`](#err)
  * [`error`](#error)
  * [`error-text`](#error-text)
  * [`error:`](#error-1)
  * [`file::list::filter-existing`](#filelistfilter-existing)
  * [`file::list::filter-non-empty`](#filelistfilter-non-empty)
  * [`file::size`](#filesize)
  * [`file::size::mb`](#filesizemb)
  * [`file::source-if-exists`](#filesource-if-exists)
  * [`file::stat`](#filestat)
  * [`ftrace-in`](#ftrace-in)
  * [`ftrace-off`](#ftrace-off)
  * [`ftrace-on`](#ftrace-on)
  * [`ftrace-out`](#ftrace-out)
  * [`g-i`](#g-i)
  * [`g-u`](#g-u)
  * [`gem.clear-cache`](#gemclear-cache)
  * [`gvim.off`](#gvimoff)
  * [`gvim.on`](#gvimon)
  * [`h1`](#h1)
  * [`h1::blue`](#h1blue)
  * [`h1::green`](#h1green)
  * [`h1::purple`](#h1purple)
  * [`h1::red`](#h1red)
  * [`h1::yellow`](#h1yellow)
  * [`h2`](#h2)
  * [`h2::green`](#h2green)
  * [`h3`](#h3)
  * [`h::black`](#hblack)
  * [`h::blue`](#hblue)
  * [`h::green`](#hgreen)
  * [`h::red`](#hred)
  * [`h::yellow`](#hyellow)
  * [`hb::crypt::chef`](#hbcryptchef)
  * [`hb::decrypt::file`](#hbdecryptfile)
  * [`hb::decrypt::str`](#hbdecryptstr)
  * [`hb::edit::file`](#hbeditfile)
  * [`hb::encrypt::file`](#hbencryptfile)
  * [`hb::encrypt::str`](#hbencryptstr)
  * [`hb::sym`](#hbsym)
  * [`hbsed`](#hbsed)
  * [`hdr`](#hdr)
  * [`hl::blue`](#hlblue)
  * [`hl::desc`](#hldesc)
  * [`hl::green`](#hlgreen)
  * [`hl::orange`](#hlorange)
  * [`hl::subtle`](#hlsubtle)
  * [`hl::white-on-orange`](#hlwhite-on-orange)
  * [`hl::white-on-salmon`](#hlwhite-on-salmon)
  * [`hl::yellow`](#hlyellow)
  * [`hl::yellow-on-gray`](#hlyellow-on-gray)
  * [`hr`](#hr)
  * [`hr::colored`](#hrcolored)
  * [`inf`](#inf)
  * [`info`](#info)
  * [`info:`](#info-1)
  * [`interrupted`](#interrupted)
  * [`is-func`](#is-func)
  * [`is_ask_on_error`](#is_ask_on_error)
  * [`is_detail`](#is_detail)
  * [`is_verbose`](#is_verbose)
  * [`italic`](#italic)
  * [`jm::check`](#jmcheck)
  * [`jm::jemalloc::detect-loud`](#jmjemallocdetect-loud)
  * [`jm::jemalloc::detect-quiet`](#jmjemallocdetect-quiet)
  * [`jm::jemalloc::stats`](#jmjemallocstats)
  * [`jm::ruby::detect`](#jmrubydetect)
  * [`jm::ruby::report`](#jmrubyreport)
  * [`jm::usage`](#jmusage)
  * [`kind_of_ok`](#kind_of_ok)
  * [`kind_of_ok:`](#kind_of_ok-1)
  * [`left`](#left)
  * [`left-prefix`](#left-prefix)
  * [`lib::7z::install`](#lib7zinstall)
  * [`lib::7z::unzip`](#lib7zunzip)
  * [`lib::7z::zip`](#lib7zzip)
  * [`lib::array::complain-unless-includes`](#libarraycomplain-unless-includes)
  * [`lib::array::contains-element`](#libarraycontains-element)
  * [`lib::array::exit-unless-includes`](#libarrayexit-unless-includes)
  * [`lib::array::from-command-output`](#libarrayfrom-command-output)
  * [`lib::array::join`](#libarrayjoin)
  * [`lib::array::piped`](#libarraypiped)
  * [`lib::audio::wav-to-mp3`](#libaudiowav-to-mp3)
  * [`lib::audio::wave-file-frequency`](#libaudiowave-file-frequency)
  * [`lib::brew::cache-reset`](#libbrewcache-reset)
  * [`lib::brew::cache-reset::delayed`](#libbrewcache-resetdelayed)
  * [`lib::brew::cask::is-installed`](#libbrewcaskis-installed)
  * [`lib::brew::cask::list`](#libbrewcasklist)
  * [`lib::brew::cask::tap`](#libbrewcasktap)
  * [`lib::brew::install`](#libbrewinstall)
  * [`lib::brew::install::cask`](#libbrewinstallcask)
  * [`lib::brew::install::package`](#libbrewinstallpackage)
  * [`lib::brew::install::packages`](#libbrewinstallpackages)
  * [`lib::brew::package::is-installed`](#libbrewpackageis-installed)
  * [`lib::brew::package::list`](#libbrewpackagelist)
  * [`lib::brew::reinstall::package`](#libbrewreinstallpackage)
  * [`lib::brew::reinstall::packages`](#libbrewreinstallpackages)
  * [`lib::brew::relink`](#libbrewrelink)
  * [`lib::brew::setup`](#libbrewsetup)
  * [`lib::brew::uninstall::package`](#libbrewuninstallpackage)
  * [`lib::brew::uninstall::packages`](#libbrewuninstallpackages)
  * [`lib::brew::upgrade`](#libbrewupgrade)
  * [`lib::cache-or-command`](#libcache-or-command)
  * [`lib::caller::stack`](#libcallerstack)
  * [`lib::color::disable`](#libcolordisable)
  * [`lib::color::enable`](#libcolorenable)
  * [`lib::db::datetime`](#libdbdatetime)
  * [`lib::db::dump`](#libdbdump)
  * [`lib::db::num_procs`](#libdbnum_procs)
  * [`lib::db::psql-args`](#libdbpsql-args)
  * [`lib::db::psql::args::`](#libdbpsqlargs)
  * [`lib::db::psql::args::default`](#libdbpsqlargsdefault)
  * [`lib::db::psql::args::maint`](#libdbpsqlargsmaint)
  * [`lib::db::rails::schema::checksum`](#libdbrailsschemachecksum)
  * [`lib::db::rails::schema::file`](#libdbrailsschemafile)
  * [`lib::db::restore`](#libdbrestore)
  * [`lib::db::top`](#libdbtop)
  * [`lib::db::wait-until-db-online`](#libdbwait-until-db-online)
  * [`lib::deploy::slack`](#libdeployslack)
  * [`lib::deploy::slack-ding`](#libdeployslack-ding)
  * [`lib::deploy::validate-vpn`](#libdeployvalidate-vpn)
  * [`lib::dir::count-slashes`](#libdircount-slashes)
  * [`lib::dir::expand-dir`](#libdirexpand-dir)
  * [`lib::dir::is-a-dir`](#libdiris-a-dir)
  * [`lib::docker::abort-if-down`](#libdockerabort-if-down)
  * [`lib::docker::actions::build`](#libdockeractionsbuild)
  * [`lib::docker::actions::clean`](#libdockeractionsclean)
  * [`lib::docker::actions::pull`](#libdockeractionspull)
  * [`lib::docker::actions::push`](#libdockeractionspush)
  * [`lib::docker::actions::setup`](#libdockeractionssetup)
  * [`lib::docker::actions::start`](#libdockeractionsstart)
  * [`lib::docker::actions::stop`](#libdockeractionsstop)
  * [`lib::docker::actions::tag`](#libdockeractionstag)
  * [`lib::docker::actions::up`](#libdockeractionsup)
  * [`lib::docker::actions::update`](#libdockeractionsupdate)
  * [`lib::docker::build::container`](#libdockerbuildcontainer)
  * [`lib::docker::containers::clean`](#libdockercontainersclean)
  * [`lib::docker::image::inspect`](#libdockerimageinspect)
  * [`lib::docker::image::rm`](#libdockerimagerm)
  * [`lib::docker::images-named`](#libdockerimages-named)
  * [`lib::docker::images::clean`](#libdockerimagesclean)
  * [`lib::docker::images::inspect`](#libdockerimagesinspect)
  * [`lib::docker::last-version`](#libdockerlast-version)
  * [`lib::docker::next-version`](#libdockernext-version)
  * [`lib::docker::set-repo`](#libdockerset-repo)
  * [`lib::file::exists_and_newer_than`](#libfileexists_and_newer_than)
  * [`lib::file::gsub`](#libfilegsub)
  * [`lib::file::install_with_backup`](#libfileinstall_with_backup)
  * [`lib::file::last-modified-date`](#libfilelast-modified-date)
  * [`lib::file::last-modified-year`](#libfilelast-modified-year)
  * [`lib::gem::cache-installed`](#libgemcache-installed)
  * [`lib::gem::cache-refresh`](#libgemcache-refresh)
  * [`lib::gem::configure-cache`](#libgemconfigure-cache)
  * [`lib::gem::ensure-gem-version`](#libgemensure-gem-version)
  * [`lib::gem::gemfile::version`](#libgemgemfileversion)
  * [`lib::gem::global::latest-version`](#libgemgloballatest-version)
  * [`lib::gem::global::versions`](#libgemglobalversions)
  * [`lib::gem::install`](#libgeminstall)
  * [`lib::gem::is-installed`](#libgemis-installed)
  * [`lib::gem::uninstall`](#libgemuninstall)
  * [`lib::gem::version`](#libgemversion)
  * [`lib::git::configure-auto-updates`](#libgitconfigure-auto-updates)
  * [`lib::git::last-update-at`](#libgitlast-update-at)
  * [`lib::git::local-vs-remote`](#libgitlocal-vs-remote)
  * [`lib::git::quiet`](#libgitquiet)
  * [`lib::git::remotes`](#libgitremotes)
  * [`lib::git::repo-is-clean`](#libgitrepo-is-clean)
  * [`lib::git::save-last-update-at`](#libgitsave-last-update-at)
  * [`lib::git::seconds-since-last-pull`](#libgitseconds-since-last-pull)
  * [`lib::git::sync`](#libgitsync)
  * [`lib::git::sync-remote`](#libgitsync-remote)
  * [`lib::git::update-repo-if-needed`](#libgitupdate-repo-if-needed)
  * [`lib::json::begin-array`](#libjsonbegin-array)
  * [`lib::json::begin-hash`](#libjsonbegin-hash)
  * [`lib::json::begin-key`](#libjsonbegin-key)
  * [`lib::json::end-array`](#libjsonend-array)
  * [`lib::json::end-hash`](#libjsonend-hash)
  * [`lib::json::file-to-array`](#libjsonfile-to-array)
  * [`lib::osx::cookie-dump`](#libosxcookie-dump)
  * [`lib::osx::env-print`](#libosxenv-print)
  * [`lib::osx::local-servers`](#libosxlocal-servers)
  * [`lib::osx::ramdisk::mount`](#libosxramdiskmount)
  * [`lib::osx::ramdisk::unmount`](#libosxramdiskunmount)
  * [`lib::osx::scutil-print`](#libosxscutil-print)
  * [`lib::osx::set-fqdn`](#libosxset-fqdn)
  * [`lib::output::color::off`](#liboutputcoloroff)
  * [`lib::output::color::on`](#liboutputcoloron)
  * [`lib::output::is_pipe`](#liboutputis_pipe)
  * [`lib::output::is_redirect`](#liboutputis_redirect)
  * [`lib::output::is_ssh`](#liboutputis_ssh)
  * [`lib::output::is_terminal`](#liboutputis_terminal)
  * [`lib::output::is_tty`](#liboutputis_tty)
  * [`lib::progress::bar`](#libprogressbar)
  * [`lib::psql::db-settings`](#libpsqldb-settings)
  * [`lib::repo::rebase`](#libreporebase)
  * [`lib::repo::stash-and-rebase`](#librepostash-and-rebase)
  * [`lib::repo::update`](#librepoupdate)
  * [`lib::repos::catch-interrupt`](#libreposcatch-interrupt)
  * [`lib::repos::init-interrupt`](#libreposinit-interrupt)
  * [`lib::repos::recursive-update`](#libreposrecursive-update)
  * [`lib::repos::was-interrupted`](#libreposwas-interrupted)
  * [`lib::ruby::bundler-version`](#librubybundler-version)
  * [`lib::ruby::gemfile-lock-version`](#librubygemfile-lock-version)
  * [`lib::ruby::install-ruby`](#librubyinstall-ruby)
  * [`lib::ruby::install-ruby-with-deps`](#librubyinstall-ruby-with-deps)
  * [`lib::ruby::validate-version`](#librubyvalidate-version)
  * [`lib::run`](#librun)
  * [`lib::run::ask`](#librunask)
  * [`lib::run::inspect`](#libruninspect)
  * [`lib::run::inspect-variable`](#libruninspect-variable)
  * [`lib::run::inspect-variables`](#libruninspect-variables)
  * [`lib::run::inspect-variables-that-are`](#libruninspect-variables-that-are)
  * [`lib::run::inspect::set-skip-false-or-blank`](#libruninspectset-skip-false-or-blank)
  * [`lib::run::print-variable`](#librunprint-variable)
  * [`lib::run::print-variables`](#librunprint-variables)
  * [`lib::run::variables-ending-with`](#librunvariables-ending-with)
  * [`lib::run::variables-starting-with`](#librunvariables-starting-with)
  * [`lib::run::with-min-duration`](#librunwith-min-duration)
  * [`lib::ssh::load-keys`](#libsshload-keys)
  * [`lib::time::date-from-epoch`](#libtimedate-from-epoch)
  * [`lib::time::duration::humanize`](#libtimedurationhumanize)
  * [`lib::time::duration::millis-to-secs`](#libtimedurationmillis-to-secs)
  * [`lib::time::epoch-to-iso`](#libtimeepoch-to-iso)
  * [`lib::time::epoch-to-local`](#libtimeepoch-to-local)
  * [`lib::time::epoch::minutes-ago`](#libtimeepochminutes-ago)
  * [`lib::trap-setup`](#libtrap-setup)
  * [`lib::trap-was-fired`](#libtrap-was-fired)
  * [`lib::trapped`](#libtrapped)
  * [`lib::url::downloader`](#liburldownloader)
  * [`lib::url::http-code`](#liburlhttp-code)
  * [`lib::url::is-valid`](#liburlis-valid)
  * [`lib::url::shorten`](#liburlshorten)
  * [`lib::url::valid-status`](#liburlvalid-status)
  * [`lib::user`](#libuser)
  * [`lib::user::finger::name`](#libuserfingername)
  * [`lib::user::first`](#libuserfirst)
  * [`lib::user::gitconfig::email`](#libusergitconfigemail)
  * [`lib::user::gitconfig::name`](#libusergitconfigname)
  * [`lib::user::host`](#libuserhost)
  * [`lib::user::my::ip`](#libusermyip)
  * [`lib::user::my::reverse-ip`](#libusermyreverse-ip)
  * [`lib::user::username`](#libuserusername)
  * [`lib::util::append-to-init-files`](#libutilappend-to-init-files)
  * [`lib::util::arch`](#libutilarch)
  * [`lib::util::call-if-function`](#libutilcall-if-function)
  * [`lib::util::checksum::files`](#libutilchecksumfiles)
  * [`lib::util::checksum::stdin`](#libutilchecksumstdin)
  * [`lib::util::functions-matching`](#libutilfunctions-matching)
  * [`lib::util::generate-password`](#libutilgenerate-password)
  * [`lib::util::i-to-ver`](#libutili-to-ver)
  * [`lib::util::install-direnv`](#libutilinstall-direnv)
  * [`lib::util::is-a-function`](#libutilis-a-function)
  * [`lib::util::is-numeric`](#libutilis-numeric)
  * [`lib::util::is-variable-defined`](#libutilis-variable-defined)
  * [`lib::util::lines-in-folder`](#libutillines-in-folder)
  * [`lib::util::remove-from-init-files`](#libutilremove-from-init-files)
  * [`lib::util::shell-init-files`](#libutilshell-init-files)
  * [`lib::util::shell-name`](#libutilshell-name)
  * [`lib::util::ver-to-i`](#libutilver-to-i)
  * [`lib::util::whats-installed`](#libutilwhats-installed)
  * [`lib::vim::gvim-off`](#libvimgvim-off)
  * [`lib::vim::gvim-on`](#libvimgvim-on)
  * [`lib::vim::setup`](#libvimsetup)
  * [`lib::yaml::diff`](#libyamldiff)
  * [`lib::yaml::dump`](#libyamldump)
  * [`lib::yaml::expand-aliases`](#libyamlexpand-aliases)
  * [`long-pause`](#long-pause)
  * [`millis`](#millis)
  * [`not_ok`](#not_ok)
  * [`not_ok:`](#not_ok-1)
  * [`odie`](#odie)
  * [`ok`](#ok)
  * [`ok:`](#ok-1)
  * [`okay`](#okay)
  * [`onoe`](#onoe)
  * [`pall`](#pall)
  * [`pause`](#pause)
  * [`pid::alive`](#pidalive)
  * [`pid::sig`](#pidsig)
  * [`pid::stop`](#pidstop)
  * [`pids-with-args`](#pids-with-args)
  * [`pids::all`](#pidsall)
  * [`pids::for-each`](#pidsfor-each)
  * [`pids::matching`](#pidsmatching)
  * [`pids::matching::regexp`](#pidsmatchingregexp)
  * [`pids::normalize::search-string`](#pidsnormalizesearch-string)
  * [`pids::stop`](#pidsstop)
  * [`press-any-key-to-continue`](#press-any-key-to-continue)
  * [`pstop`](#pstop)
  * [`puts`](#puts)
  * [`red`](#red)
  * [`repos.update`](#reposupdate)
  * [`reset-color`](#reset-color)
  * [`reset-color:`](#reset-color-1)
  * [`ruby.compiled-with`](#rubycompiled-with)
  * [`ruby.default-gems`](#rubydefault-gems)
  * [`ruby.full-version`](#rubyfull-version)
  * [`ruby.gems`](#rubygems)
  * [`ruby.gems.install`](#rubygemsinstall)
  * [`ruby.gems.uninstall`](#rubygemsuninstall)
  * [`ruby.init`](#rubyinit)
  * [`ruby.install`](#rubyinstall)
  * [`ruby.install-upgrade-bundler`](#rubyinstall-upgrade-bundler)
  * [`ruby.installed-gems`](#rubyinstalled-gems)
  * [`ruby.kigs-gems`](#rubykigs-gems)
  * [`ruby.linked-libs`](#rubylinked-libs)
  * [`ruby.numeric-version`](#rubynumeric-version)
  * [`ruby.rbenv`](#rubyrbenv)
  * [`ruby.rubygems-update`](#rubyrubygems-update)
  * [`ruby.stop`](#rubystop)
  * [`ruby.top-versions`](#rubytop-versions)
  * [`ruby.top-versions-as-yaml`](#rubytop-versions-as-yaml)
  * [`run`](#run)
  * [`run::inspect`](#runinspect)
  * [`run::set-all`](#runset-all)
  * [`run::set-all::list`](#runset-alllist)
  * [`run::set-next`](#runset-next)
  * [`run::set-next::list`](#runset-nextlist)
  * [`save-restore-x`](#save-restore-x)
  * [`save-set-x`](#save-set-x)
  * [`screen-width`](#screen-width)
  * [`screen.height`](#screenheight)
  * [`screen.width`](#screenwidth)
  * [`set-e-restore`](#set-e-restore)
  * [`set-e-save`](#set-e-save)
  * [`set-e-status`](#set-e-status)
  * [`shell-set::init-stack`](#shell-setinit-stack)
  * [`shell-set::is-set`](#shell-setis-set)
  * [`shell-set::pop-stack`](#shell-setpop-stack)
  * [`shell-set::push-stack`](#shell-setpush-stack)
  * [`shell-set::show-stack`](#shell-setshow-stack)
  * [`short-pause`](#short-pause)
  * [`shortish-pause`](#shortish-pause)
  * [`shutdown`](#shutdown)
  * [`sig::is-valid`](#sigis-valid)
  * [`sig::list`](#siglist)
  * [`stderr`](#stderr)
  * [`stdout`](#stdout)
  * [`strikethrough`](#strikethrough)
  * [`success`](#success)
  * [`sym::hb::configure`](#symhbconfigure)
  * [`sym::hb::files`](#symhbfiles)
  * [`sym::hb::have_key`](#symhbhave_key)
  * [`sym::hb::import`](#symhbimport)
  * [`sym::hb::install-shell-helpers`](#symhbinstall-shell-helpers)
  * [`sym::install::symit`](#syminstallsymit)
  * [`test-group`](#test-group)
  * [`today`](#today)
  * [`txt-err`](#txt-err)
  * [`txt-info`](#txt-info)
  * [`txt-warn`](#txt-warn)
  * [`underline`](#underline)
  * [`warn`](#warn)
  * [`warning`](#warning)
  * [`warning:`](#warning-1)
  * [`watch-ls-al`](#watch-ls-al)
  * [`with-bundle-exec`](#with-bundle-exec)
  * [`with-bundle-exec-and-output`](#with-bundle-exec-and-output)
  * [`with-min-duration`](#with-min-duration)
  * [`yaml-diff`](#yaml-diff)
  * [`yaml-dump`](#yaml-dump)
  * [`√¶-wav2mp3`](#√¶-wav2mp3)
  * [`√¶-wavfreq`](#√¶-wavfreq)

## Function Definitions

### `abort`

```
abort ()
{
    printf -- "${LibOutput__LeftPrefix}${txtblk}${bakred}  ¬´ ABORT ¬ª  ${clr} ${bldwht} ‚úî  ${bldgrn}$*${clr}" 1>&2;
    echo
}

```
### `ansi`

```
ansi ()
{
    echo -e "\e[${1}m${*:2}\e[0m"
}

```
### `array-bullet-list`

```
array-bullet-list ()
{
    lib::array::join ' ‚Ä¢ ' true "$@"
}

```
### `array-contains-element`

```
array-contains-element ()
{
    local search="$1";
    shift;
    local r="false";
    local e;
    [[ "$*" =~ ${search} ]] || {
        echo -n $r;
        return 1
    };
    for e in "${@}";
    do
        [[ "$e" == "${search}" ]] && r="true";
    done;
    echo -n $r;
    [[ $r == "false" ]] && return 1;
    return 0
}

```
### `array-csv`

```
array-csv ()
{
    lib::array::join ', ' false "$@"
}

```
### `array-join`

```
array-join ()
{
    lib::array::join "$@"
}

```
### `array-piped`

```
array-piped ()
{
    lib::array::piped "$@"
}

```
### `ascii-clean`

```
ascii-clean ()
{
    __lib::output::clean "$@"
}

```
### `aws.ec2`

```
aws.ec2 ()
{
    local cmd="$1";
    local command="$cmd";
    case $command in
        list | show | ls)
            __utf_table "$(aws ec2 describe-instances --query 'Reservations[*].Instances[*].{name: Name, instance_id: InstanceId, ip_address: PrivateIpAddress, state: State.Name}' --output table 2>/dev/null)";
            return $?
        ;;
        *)
            error "Invalid Command: ${cmd}";
            return 1
        ;;
    esac
}

```
### `aws.rds.hostname`

```
aws.rds.hostname ()
{
    local name=${1};
    [[ -z $(which jq) ]] && out=$(lib::brew::install::package jq 2>/dev/null 1>/dev/null);
    [[ -z $(which aws) ]] && out=$(lib::brew::install::package awscli 2>/dev/null 1>/dev/null);
    [[ -n ${name} ]] && aws rds describe-db-instances | jq '.[][].Endpoint.Address' | hbsed 's/"//g' | egrep "^${name}\.";
    [[ -z ${name} ]] && aws rds describe-db-instances | jq '.[][].Endpoint.Address' | hbsed 's/"//g'
}

```
### `aws.s3.upload`

```
aws.s3.upload ()
{
    local pathname="$1";
    shift;
    local skip_file_modification="$1";
    [[ -n ${skip_file_modification} ]] && skip_file_modification=true;
    [[ -z ${skip_file_modification} ]] && skip_file_modification=false;
    if [[ -z "${LibAws__DefaultUploadBucket}" || -z "${LibAws__DefaultUploadFolder}" ]]; then
        error "Required AWS S3 configuration is not defined." "Please set variables: ${bldylw}LibAws__DefaultUploadFolder" "and ${bldylw}LibAws__DefaultUploadBucket" "before using this function.";
        return 1;
    fi;
    if [[ ! -f "${pathname}" ]]; then
        error "Local file was not found: ${bldylw}${pathname}";
        return 1;
    fi;
    local file=$(basename "${pathname}");
    local remote_file="${file}";
    local year=$(lib::file::last-modified-year "${pathname}");
    local date=$(lib::file::last-modified-date "${pathname}");
    [[ -z ${year} ]] && year=$(date +'%Y');
    [[ -z ${date} ]] && date=$(today);
    ${skip_file_modification} || {
        [[ "${remote_file}" =~ "${date}" ]] && remote_file=$(echo "${remote_file}" | hbsed "s/[_\.-]?${date}[_\.-]//g");
        [[ "${remote_file}" =~ "${date}" ]] || remote_file="${date}.${remote_file}"
    };
    remote_file=$(echo "${remote_file}" | sed -E 's/ /-/g;s/--+/-/g' | tr '[A-Z]' '[a-z]');
    local remote="s3://${LibAws__DefaultUploadBucket}/${LibAws__DefaultUploadFolder}/${year}/${remote_file}";
    run "aws s3 cp \"${pathname}\" \"${remote}\"";
    if [[ ${LibRun__LastExitCode} -eq 0 ]]; then
        local remoteUrl="https://s3-${LibAws__DefaultRegion}.amazonaws.com/${LibAws__DefaultUploadBucket}/${LibAws__DefaultUploadFolder}/${year}/${remote_file}";
        [[ -n "${LibAws__ObjectUrlFile}" ]] && echo ${remoteUrl} > "${LibAws__ObjectUrlFile}";
        echo;
        info "NOTE: You should now be able to access your resource at the following URL:";
        hr;
        info "${bldylw}${remoteUrl}";
        hr;
    else
        error "AWS S3 upload failed with code ${LibRun__LastExitCode}";
    fi;
    return ${LibRun__LastExitCode}
}

```
### `bashmatic-set-fqdn`

```
bashmatic-set-fqdn ()
{
    lib::osx::set-fqdn "$@"
}

```
### `bashmatic-term`

```
bashmatic-term ()
{
    open $(bashmatic-term-program)
}

```
### `bashmatic-term-program`

```
bashmatic-term-program ()
{
    if [[ -d /Applications/iTerm.app ]]; then
        printf '%s' /Applications/iTerm.app;
    else
        if [[ -d /Applications/Utilities/Terminal.app ]]; then
            printf '%s' /Applications/Utilities/Terminal.app;
        else
            printf '%s' "echo 'No TERMINAL application found'";
        fi;
    fi
}

```
### `bashmatic.auto-update`

```
bashmatic.auto-update ()
{
    [[ ${Bashmatic__Test} -eq 1 ]] && return 0;
    lib::git::configure-auto-updates;
    lib::git::repo-is-clean || {
        h1 "${BashMatic__Home} has locally modified changes." "Will wait with auto-update until it's sync'd up.";
        return 1
    };
    lib::git::sync
}

```
### `bashmatic.functions`

```
bashmatic.functions ()
{
    bashmatic.functions-from '*.sh' "$@"
}

```
### `bashmatic.functions-from`

```
bashmatic.functions-from ()
{
    local pattern="${1}";
    [[ -n ${pattern} ]] && shift;
    [[ -z ${pattern} ]] && pattern="*.sh";
    cd ${BashMatic__Home} > /dev/null;
    export SCREEN_WIDTH=$(screen-width);
    if [[ ! ${pattern} =~ "*" && ! ${pattern} =~ ".sh" ]]; then
        pattern="${pattern}.sh";
    fi;
    egrep -e '^[_a-zA-Z]+.*\(\)' lib/${pattern} | sed -E 's/^lib\/.*\.sh://g' | sed -E 's/^function //g' | sed -E 's/\(\) *{.*$//g' | sed -E '/^ *$/d' | grep -v '^_' | sort | uniq | columnize "$@";
    cd - > /dev/null
}

```
### `bashmatic.functions.output`

```
bashmatic.functions.output ()
{
    bashmatic.functions-from 'output.sh' "$@"
}

```
### `bashmatic.functions.runtime`

```
bashmatic.functions.runtime ()
{
    bashmatic.functions-from 'run*.sh' "$@"
}

```
### `bashmatic.load-at-login`

```
bashmatic.load-at-login ()
{
    local init_file="${1}";
    local -a init_files=(~/.bashrc ~/.bash_profile ~/.profile);
    [[ -n "${init_file}" && -f "${init_file}" ]] && init_files=("${init_file}");
    for file in "${init_files[@]}";
    do
        if [[ -f "${file}" ]]; then
            grep -q bashmatic "${file}" && {
                success "BashMatic is already loaded from ${bldblu}${file}";
                return 0
            };
            grep -q bashmatic "${file}" || {
                h2 "Adding BashMatic auto-loader to ${bldgrn}${file}...";
                echo "source ${BashMatic__Home}/init.sh" >> "${file}"
            };
            source "${file}";
            break;
        fi;
    done
}

```
### `bashmatic.reload`

```
bashmatic.reload ()
{
    source "${BashMatic__Init}"
}

```
### `bashmatic.version`

```
bashmatic.version ()
{
    cat $(dirname "${BashMatic__Init}")/.version
}

```
### `bashmatic::detect-subshell`

```
bashmatic::detect-subshell ()
{
    bashmatic::subshell-init;
    [[ -n ${BASH_SUBSHELL_DETECTED} && -n ${BASH_IN_SUBSHELL} ]] && return ${BASH_IN_SUBSHELL};
    unset BASH_IN_SUBSHELL;
    export BASH_SUBSHELL_DETECTED=true;
    local len="${#BASH_SOURCE[@]}";
    local last_index=$(( len - 1 ));
    [[ -n ${DEBUG} ]] && {
        echo "BASH_SOURCE[*] = ${BASH_SOURCE[*]}" 1>&2;
        echo "BASH_SOURCE[${last_index}] = ${BASH_SOURCE[${last_index}]}" 1>&2;
        echo "\$0            = $0" 1>&2
    };
    if [[ -n ${ZSH_EVAL_CONEXT} && ${ZSH_EVAL_CONTEXT} =~ :file$ ]] || [[ -n ${BASH_VERSION} && "$0" != "${BASH_SOURCE[${last_index}]}" ]]; then
        export BASH_IN_SUBSHELL=0;
    else
        export BASH_IN_SUBSHELL=1;
    fi;
    return ${BASH_IN_SUBSHELL}
}

```
### `bashmatic::subshell-init`

```
bashmatic::subshell-init ()
{
    export BASH_SUBSHELL_DETECTED=
}

```
### `bashmatic::validate-sourced-in`

```
bashmatic::validate-sourced-in ()
{
    bashmatic::detect-subshell;
    [[ ${BASH_IN_SUBSHELL} -eq 0 ]] || {
        echo "This script to be sourced in, not run in a subshell." 1>&2;
        return 1
    };
    return 0
}

```
### `bashmatic::validate-subshell`

```
bashmatic::validate-subshell ()
{
    bashmatic::detect-subshell;
    [[ ${BASH_IN_SUBSHELL} -eq 1 ]] || {
        echo "This script to be run, not sourced-in" 1>&2;
        return 1
    };
    return 0
}

```
### `bold`

```
bold ()
{
    ansi 1 "$@"
}

```
### `box::blue-in-green`

```
box::blue-in-green ()
{
    __lib::output::box "${bldblu}" "${bldgrn}" "$@"
}

```
### `box::blue-in-yellow`

```
box::blue-in-yellow ()
{
    __lib::output::box "${bldylw}" "${bldblu}" "$@"
}

```
### `box::green-in-cyan`

```
box::green-in-cyan ()
{
    __lib::output::box "${bldgrn}" "${bldcyn}" "$@"
}

```
### `box::green-in-green`

```
box::green-in-green ()
{
    __lib::output::box "${bldgrn}" "${bldgrn}" "$@"
}

```
### `box::green-in-magenta`

```
box::green-in-magenta ()
{
    __lib::output::box "${bldgrn}" "${bldpur}" "$@"
}

```
### `box::green-in-yellow`

```
box::green-in-yellow ()
{
    __lib::output::box "${bldgrn}" "${bldylw}" "$@"
}

```
### `box::magenta-in-blue`

```
box::magenta-in-blue ()
{
    __lib::output::box "${bldblu}" "${bldpur}" "$@"
}

```
### `box::magenta-in-green`

```
box::magenta-in-green ()
{
    __lib::output::box "${bldpur}" "${bldgrn}" "$@"
}

```
### `box::red-in-magenta`

```
box::red-in-magenta ()
{
    __lib::output::box "${bldred}" "${bldpur}" "$@"
}

```
### `box::red-in-red`

```
box::red-in-red ()
{
    __lib::output::box "${bldred}" "${txtred}" "$@"
}

```
### `box::red-in-yellow`

```
box::red-in-yellow ()
{
    __lib::output::box "${bldred}" "${bldylw}" "$@"
}

```
### `box::yellow-in-blue`

```
box::yellow-in-blue ()
{
    __lib::output::box "${bldylw}" "${bldblu}" "$@"
}

```
### `box::yellow-in-red`

```
box::yellow-in-red ()
{
    __lib::output::box "${bldred}" "${bldylw}" "$@"
}

```
### `box::yellow-in-yellow`

```
box::yellow-in-yellow ()
{
    __lib::output::box "${bldylw}" "${txtylw}" "$@"
}

```
### `br`

```
br ()
{
    echo
}

```
### `bundle.gems-with-c-extensions`

```
bundle.gems-with-c-extensions ()
{
    run::set-next show-output-on;
    run "bundle show --paths | ruby -e \"STDIN.each_line {|dep| puts dep.split('/').last if File.directory?(File.join(dep.chomp, 'ext')) }\""
}

```
### `center`

```
center ()
{
    __lib::output::center "$@"
}

```
### `change-underscan`

```
change-underscan ()
{
    set +e;
    local amount_percentage="$1";
    if [[ -z "${amount_percentage}" ]]; then
        printf "%s\n\n" "USAGE: change-underscan percent";
        printf "%s\n" "   eg: change-underscan   5  # underscan by 5%";
        printf "%s\n" "   eg: change-underscan -10  # overscan by 10%";
        return -1;
    fi;
    local file="/var/db/.com.apple.iokit.graphics";
    local backup="/var/db/.com.apple.iokit.graphics.bak.$(date '+%F.%X')";
    local new_value=$(ruby -e "puts (10000.0 + 10000.0 * ${amount_percentage}.to_f / 100.0).to_i");
    h1 'This utility allows you to change underscan/overscan' 'on monitors that do not offer that option via GUI.';
    lib::run::ask "Continue?";
    info "Great! First we need to identify your monitor.";
    hl::yellow "Please make sure that the external monitor is plugged in.";
    lib::run::ask "Is it plugged in?";
    info "Making a backup of your current graphics settings...";
    inf "Please enter your password, if asked: ";
    set -e;
    bash -c 'set -e; sudo ls -1 > /dev/null; set +e';
    ok;
    run "sudo rm -f \"${backup}\"";
    export LibRun__AbortOnError=${True};
    run "sudo cp -v \"${file}\" \"${backup}\"";
    h2 "Now: please change the resolution ${bldylw}on the problem monitor." "NOTE: it's ${italic}not important what resolution you choose," "as long as it's different than what you had previously..." "Finally: exit Display Preferences once you changed resolution.";
    run "open /System/Library/PreferencePanes/Displays.prefPane";
    lib::run::ask "Have you changed the resolution and exited Display Prefs? ";
    local line=$(sudo diff "${file}" "${backup}" 2>/dev/null | head -1 | /usr/bin/env ruby -ne 'puts $_.to_i');
    [[ -n $DEBUG ]] && info "diff line is at ${line}";
    value=;
    if [[ "${line}" -gt 0 ]]; then
        line_pscn_key=$(( $line - 4 ));
        line_pscn_value=$(( $line - 3 ));
        ( awk "NR==${line_pscn_key}{print;exit}" "${file}" | grep -q pscn ) && {
            value=$(awk "NR==${line_pscn_value}{print;exit}" "${file}" | awk 'BEGIN{FS="[<>]"}{print $3}');
            [[ -n $DEBUG ]] && info "current value is ${value}"
        };
    else
        error "It does not appear that anything changed, sorry.";
        return -1;
    fi;
    h2 "Now, please unplug the problem monitor temporarily...";
    lib::run::ask "...and press Enter to continue ";
    if [[ -n ${value} && ${value} -ne ${new_value} ]]; then
        export LibRun__AbortOnError=${True};
        run "sudo sed -i.backup \"${line_pscn_value}s/${value}/${new_value}/g\" \"${file}\"";
        echo;
        h2 "Congratulations!" "Your display underscan value has been changed.";
        info "Previous Value ‚Äî ${bldpur}${value}";
        info "New value:     ‚Äî ${bldgrn}${new_value}";
        hr;
        info "${bldylw}IMPORTANT!";
        info "You must restart your computer for the settings to take affect.";
        echo;
        lib::run::ask "Should I reboot your computer now? ";
        info "Very well, rebooting!";
        run "sudo reboot";
    else
        warning "Unable to find the display scan value to change. ";
        info "Could it be that you haven't restarted since your last run?";
        echo;
        info "Feel free to edit file directly, using:";
        info "eg: ${bldylw}vim ${file} +${line_pscn_value}";
    fi
}

```
### `columnize`

```
columnize ()
{
    local columns="${1:-2}";
    local sw=${SCREEN_WIDTH:-120};
    [[ -z ${sw} ]] && sw=$(screen-width);
    pr -l 10000 -${columns} -e4 -w ${sw} | expand -8 | sed -E '/^ *$/d' | grep -v 'Page '
}

```
### `command-spacer`

```
command-spacer ()
{
    [[ -z ${LibRun__AssignedWidth} || -z ${LibRun__CommandLength} ]] && return;
    printf " ${bldblk}";
    local w;
    w=$(( LibRun__AssignedWidth - LibRun__CommandLength - 10));
    [[ ${w} -gt 0 ]] && __lib::output::replicate-to "‚éØ" "${w}"
}

```
### `cookie-dump`

```
cookie-dump ()
{
    lib::osx::cookie-dump "$@"
}

```
### `cursor.at.x`

```
cursor.at.x ()
{
    __lib::output::cursor-move-to-x "$@"
}

```
### `cursor.at.y`

```
cursor.at.y ()
{
    __lib::output::cursor-move-to-y "$@"
}

```
### `cursor.down`

```
cursor.down ()
{
    __lib::output::cursor-down-by "$@"
}

```
### `cursor.left`

```
cursor.left ()
{
    __lib::output::cursor-left-by "$@"
}

```
### `cursor.rewind`

```
cursor.rewind ()
{
    local x=${1:-0};
    __lib::output::cursor-move-to-x ${x}
}

```
### `cursor.right`

```
cursor.right ()
{
    __lib::output::cursor-right-by "$@"
}

```
### `cursor.up`

```
cursor.up ()
{
    __lib::output::cursor-up-by "$@"
}

```
### `debug`

```
debug ()
{
    [[ -z ${DEBUG} ]] && return;
    printf -- "${LibOutput__LeftPrefix}${txtblk}${bakwht}[ debug ] $*  ${clr}\n"
}

```
### `decrypt.secrets`

```
decrypt.secrets ()
{
    ./bin/decrypt;
    local code=$?;
    [[ ${code} != 0 ]] && {
        error "bin/decrypt returned non-zero exit status ${code}";
        echo;
        exit ${code}
    }
}

```
### `duration`

```
duration ()
{
    local millis="$1";
    local exit_code="$2";
    [[ -n $(which bc) ]] || return;
    if [[ -n ${millis} && ${millis} -ge 0 ]]; then
        local pattern;
        pattern=" %6.6s ms ";
        pattern="${txtblu}„Äî${pattern}„Äï";
        printf "${txtblu}${pattern}" "${millis}";
    fi;
    if [[ -n ${exit_code} ]]; then
        [[ ${exit_code} -eq 0 ]] && printf " ${txtblk}${bakgrn} %3d ${clr}" ${exit_code};
        [[ ${exit_code} -gt 0 ]] && printf " ${bldwht}${bakred} %3d ${clr}" ${exit_code};
    fi
}

```
### `epoch`

```
epoch ()
{
    date +%s
}

```
### `err`

```
err ()
{
    printf -- "${LibOutput__LeftPrefix}${bldylw}${bakred}  ¬´ ERROR! ¬ª  ${clr} ${bldred}$*${clr}" 1>&2
}

```
### `error`

```
error ()
{
    header=$(printf -- "${txtblk}${bakred} ¬´ ERROR ¬ª ${clr}");
    box::red-in-red "${header} ${bldylw}$@" 1>&2
}

```
### `error-text`

```
error-text ()
{
    printf "${txtred}"
}

```
### `error:`

```
error: ()
{
    err $*;
    not_ok:
}

```
### `file::list::filter-existing`

```
file::list::filter-existing ()
{
    for file in $@;
    do
        [[ -f ${file} ]] && echo "${file}";
    done
}

```
### `file::list::filter-non-empty`

```
file::list::filter-non-empty ()
{
    for file in $@;
    do
        [[ -s ${file} ]] && echo "${file}";
    done
}

```
### `file::size`

```
file::size ()
{
    AppCurrentOS=${AppCurrentOS:-$(uname -s)};
    if [[ "Linux" == ${AppCurrentOS} ]]; then
        stat -c %s "$1";
    else
        file::stat "$1" st_size;
    fi
}

```
### `file::size::mb`

```
file::size::mb ()
{
    local file="$1";
    shift;
    local s=$(file::size ${file});
    local mb=$(echo $(($s / 10000)) | hbsed 's/([0-9][0-9])$/.\1/g');
    printf "%.2f MB" ${mb}
}

```
### `file::source-if-exists`

```
file::source-if-exists ()
{
    local file;
    for file in "$@";
    do
        [[ -f "${file}" ]] && source "${file}";
    done
}

```
### `file::stat`

```
file::stat ()
{
    local file="$1";
    local field="$2";
    [[ -f ${file} ]] || {
        error "file ${file} is not found. Usage: file::stat <filename> <stat-field-name>";
        info "eg: ${bldylw}file::stat README.md st_size";
        return 1
    };
    [[ -n ${field} ]] || {
        error "Second argument field is required.";
        info "eg: ${bldylw}file::stat README.md st_size";
        return 2
    };
    eval $(stat -s ${file} | tr ' ' '\n' | sed 's/^/local /g');
    echo ${!field}
}

```
### `ftrace-in`

```
ftrace-in ()
{
    local func=$1;
    shift;
    local args="$*";
    [[ -z ${TraceON} ]] && return;
    export __LibTrace__StackLevel=$(( ${__LibTrace__StackLevel} + 1 ));
    printf "    %*s ${bldylw}%s${bldblu}(%s)${clr}\n" ${__LibTrace__StackLevel} ' ' ${func} "${args}" 1>&2
}

```
### `ftrace-off`

```
ftrace-off ()
{
    unset TraceON
}

```
### `ftrace-on`

```
ftrace-on ()
{
    export TraceON=true
}

```
### `ftrace-out`

```
ftrace-out ()
{
    local func=$1;
    shift;
    local code=$1;
    shift;
    local msg="$*";
    [[ -z ${TraceON} ]] && return;
    local color="${bldgrn}";
    [[ ${code} -ne 0 ]] && color="${bldred}";
    printf "    %*s ${bldylw}%s() ${color} ‚ûú  %d %s\n\n" ${__LibTrace__StackLevel} ' ' ${func} ${code} "${msg}" 1>&2;
    export __LibTrace__StackLevel=$(( ${__LibTrace__StackLevel} - 1 ))
}

```
### `g-i`

```
g-i ()
{
    lib::gem::install "$@"
}

```
### `g-u`

```
g-u ()
{
    lib::gem::uninstall "$@"
}

```
### `gem.clear-cache`

```
gem.clear-cache ()
{
    rm -f ${LibGem__GemListCache}
}

```
### `gvim.off`

```
gvim.off ()
{
    lib::vim::gvim-off
}

```
### `gvim.on`

```
gvim.on ()
{
    lib::vim::gvim-on
}

```
### `h1`

```
h1 ()
{
    box::blue-in-yellow "$@"
}

```
### `h1::blue`

```
h1::blue ()
{
    box::magenta-in-blue "$@"
}

```
### `h1::green`

```
h1::green ()
{
    box::green-in-magenta "$@"
}

```
### `h1::purple`

```
h1::purple ()
{
    box::magenta-in-green "$@"
}

```
### `h1::red`

```
h1::red ()
{
    box::red-in-red "$@"
}

```
### `h1::yellow`

```
h1::yellow ()
{
    box::yellow-in-red "$@"
}

```
### `h2`

```
h2 ()
{
    box::blue-in-green "$@"
}

```
### `h2::green`

```
h2::green ()
{
    box::green-in-cyan "$@"
}

```
### `h3`

```
h3 ()
{
    hl::subtle "$@"
}

```
### `h::black`

```
h::black ()
{
    center "${bldylw}${bakblk}" "$@"
}

```
### `h::blue`

```
h::blue ()
{
    center "${txtblk}${bakblu}" "$@"
}

```
### `h::green`

```
h::green ()
{
    center "${txtblk}${bakgrn}" "$@"
}

```
### `h::red`

```
h::red ()
{
    center "${txtblk}${bakred}" "$@"
}

```
### `h::yellow`

```
h::yellow ()
{
    center "${txtblk}${bakylw}" "$@"
}

```
### `hb::crypt::chef`

```
hb::crypt::chef ()
{
    sym -ck APP_CHEF_SYM_KEY $*
}

```
### `hb::decrypt::file`

```
hb::decrypt::file ()
{
    [[ -f ${1} ]] || {
        error 'usage: hb::decrypt::file <filename.enc>';
        return
    };
    sym -ck APP_SYM_KEY -n "${1}"
}

```
### `hb::decrypt::str`

```
hb::decrypt::str ()
{
    [[ -z ${1} ]] && {
        error 'usage: hb::decrypt::str "string to decrypt"';
        return
    };
    sym -ck APP_SYM_KEY -d -s "$*"
}

```
### `hb::edit::file`

```
hb::edit::file ()
{
    [[ -f ${1} ]] || {
        error 'usage: hb::edit::file <filename>';
        return
    };
    sym -ck APP_SYM_KEY -t "${1}"
}

```
### `hb::encrypt::file`

```
hb::encrypt::file ()
{
    [[ -f ${1} ]] || {
        error 'usage: hb::encrypt::file <filename>';
        return
    };
    sym -ck APP_SYM_KEY -e -f "${1}" -o "${1}.enc"
}

```
### `hb::encrypt::str`

```
hb::encrypt::str ()
{
    [[ -z "${1}" ]] && {
        error 'usage: hb::encrypt::str "string to encrypt"';
        return
    };
    sym -ck APP_SYM_KEY -e -s "$*"
}

```
### `hb::sym`

```
hb::sym ()
{
    sym -cqk APP_SYM_KEY $*
}

```
### `hbsed`

```
hbsed ()
{
    local current=$(which sed);
    local latest=${LibSed__latestVersion:-'/usr/local/bin/gsed'};
    local os=$(uname -s);
    if [[ ! -x "${latest}" ]]; then
        if [[ "${os}" == "Darwin" ]]; then
            [[ -n $(which brew) ]] || return 1;
            brew install gnu-sed > /dev/null 2>&1;
            [[ -x "${latest}" ]] || latest="${current}";
        else
            if [[ "${os}" == "Linux" ]]; then
                latest="${current}";
            fi;
        fi;
    fi;
    latest=${latest:-${current}};
    ${latest} -E "$@"
}

```
### `hdr`

```
hdr ()
{
    h1 "$@"
}

```
### `hl::blue`

```
hl::blue ()
{
    left "${bldwht}${bakpur}" "$@"
}

```
### `hl::desc`

```
hl::desc ()
{
    left "${bakylw}${txtblk}${bakylw}" "$@"
}

```
### `hl::green`

```
hl::green ()
{
    left "${txtblk}${bakgrn}" "$@"
}

```
### `hl::orange`

```
hl::orange ()
{
    left "${white_on_orange}" "$@"
}

```
### `hl::subtle`

```
hl::subtle ()
{
    left "${bldwht}${bakblk}${underlined}" "$@"
}

```
### `hl::white-on-orange`

```
hl::white-on-orange ()
{
    left "${white_on_orange}" "$@"
}

```
### `hl::white-on-salmon`

```
hl::white-on-salmon ()
{
    left "${white_on_salmon}" "$@"
}

```
### `hl::yellow`

```
hl::yellow ()
{
    left "${bakylw}${txtblk}" "$@"
}

```
### `hl::yellow-on-gray`

```
hl::yellow-on-gray ()
{
    left "${yellow_on_gray}" "$@s"
}

```
### `hr`

```
hr ()
{
    [[ -z "$*" ]] || printf $*;
    __lib::output::hr
}

```
### `hr::colored`

```
hr::colored ()
{
    local color="$*";
    [[ -z ${color} ]] && color="${bldred}";
    __lib::output::hr "$(screen-width)" "‚Äî" "${*}"
}

```
### `inf`

```
inf ()
{
    printf -- "${LibOutput__LeftPrefix}${txtblu}${clr}${txtblu}$*${clr}"
}

```
### `info`

```
info ()
{
    inf $@;
    echo
}

```
### `info:`

```
info: ()
{
    inf $*;
    ok:
}

```
### `interrupted`

```
interrupted ()
{
    export BashMatic__Interrupted=true
}

```
### `is-func`

```
is-func ()
{
    lib::util::is-a-function "$@"
}

```
### `is_ask_on_error`

```
is_ask_on_error ()
{
    [[ ${LibRun__AskOnError} -eq ${True} ]]
}

```
### `is_detail`

```
is_detail ()
{
    [[ ${LibRun__Detail} -eq ${True} ]]
}

```
### `is_verbose`

```
is_verbose ()
{
    [[ ${LibRun__Verbose} -eq ${True} ]]
}

```
### `italic`

```
italic ()
{
    ansi 3 "$@"
}

```
### `jm::check`

```
jm::check ()
{
    local JM_Quiet=false;
    local JM_Ruby=false;
    local JM_Stats=false;
    while :; do
        case $1 in
            -q | --quiet)
                shift;
                export JM_Quiet=true
            ;;
            -r | --ruby)
                shift;
                export JM_Ruby=true
            ;;
            -s | --stats)
                shift;
                export JM_Stats=true;
                exit $?
            ;;
            -h | -\? | --help)
                shift;
                jm::usage;
                exit 0
            ;;
            --)
                shift;
                break
            ;;
            *)
                break
            ;;
        esac;
    done;
    ${JM_Ruby} && {
        jm::ruby::report;
        exit 0
    };
    ${JM_Quiet} && {
        jm::jemalloc::detect-quiet;
        code=$?;
        exit ${code}
    };
    ${JM_Stats} && {
        jm::jemalloc::stats;
        exit 0
    };
    jm::jemalloc::detect-loud
}

```
### `jm::jemalloc::detect-loud`

```
jm::jemalloc::detect-loud ()
{
    jm::jemalloc::detect-quiet;
    local code=$?;
    local local_ruby=$(jm::ruby::detect);
    printf "${ColorBlue}Checking if ruby ${ColorYellow}${local_ruby}${ColorBlue} is linked with jemalloc... \n\n ";
    if [[ ${code} -eq 0 ]]; then
        printf " ‚úÖ ${ColorGreen} ‚Äî¬†jemalloc was detected.\n";
    else
        printf " üö´ ${ColorRed} ‚Äî jemalloc was not detected.\n";
    fi;
    printf "${ColorReset}\n";
    return ${code}
}

```
### `jm::jemalloc::detect-quiet`

```
jm::jemalloc::detect-quiet ()
{
    MALLOC_CONF=stats_print:true ruby -e "exit" 2>&1 | grep -q "jemalloc statistics";
    return $?
}

```
### `jm::jemalloc::stats`

```
jm::jemalloc::stats ()
{
    jm::jemalloc::detect-quiet || {
        printf "No Jemalloc was found for the curent ruby $(jm::ruby::detect)\n";
        return 1
    };
    MALLOC_CONF=stats_print:true ruby -e "exit" 2>&1 | less -S
}

```
### `jm::ruby::detect`

```
jm::ruby::detect ()
{
    local ruby_loc;
    if [[ -n $(which rbenv) ]]; then
        ruby_loc=$(rbenv versions | grep '*' | awk '{print $2}');
        [[ -n ${ruby_loc} ]] && ruby_loc="(rbenv) ${ruby_loc}";
    else
        ruby_loc="$(which ruby) $(ruby -e 'puts "#{RUBY_VERSION} (#{RUBY_PLATFORM})"')";
    fi;
    printf "%s" "${ruby_loc}"
}

```
### `jm::ruby::report`

```
jm::ruby::report ()
{
    printf "Ruby version being tested:\n  ‚Üí  ${ColorBlue}$(which ruby) ${ColorYellow}$(jm::ruby::detect)${ColorReset}\n"
}

```
### `jm::usage`

```
jm::usage ()
{
    printf "
${ColorBlue}USAGE:${ColorReset}
  $(basename $0) [ -q/--quiet ]
                 [ -r/--ruby  ]
                 [ -s/--stats ]
                 [ -h/--help  ]

${ColorBlue}DESCRIPTION:${ColorReset}
  Determines whether the currently defined in the PATH ruby
  interpreter is linked with libjemalloc memory allocator.

${ColorBlue}OPTIONS${ColorReset}
  -q/--quiet        Do not print output, exit with 1 if no jemalloc
  -r/--ruby         Print which ruby is currently in the PATH
  -s/--stats        Print the jemalloc stats
  -h/--help         This page.
";
    exit 0
}

```
### `kind_of_ok`

```
kind_of_ok ()
{
    __lib::output::cursor-left-by 1000;
    printf " ${bakylw}${bldwht} ‚ùñ ${clr} "
}

```
### `kind_of_ok:`

```
kind_of_ok: ()
{
    kind_of_ok $@;
    echo
}

```
### `left`

```
left ()
{
    __lib::output::left-justify "$@"
}

```
### `left-prefix`

```
left-prefix ()
{
    [[ -z ${LibOutput__LeftPrefix} ]] && {
        export LibOutput__LeftPrefix=$(__lib::output::replicate-to " " "${LibOutput__LeftPrefixLen}")
    };
    printf "${LibOutput__LeftPrefix}"
}

```
### `lib::7z::install`

```
lib::7z::install ()
{
    [[ -n $(which 7z) ]] || run "brew install p7zip";
    [[ -n $(which 7z) ]] || {
        error "7z is not found after installation";
        return 1
    };
    return 0
}

```
### `lib::7z::unzip`

```
lib::7z::unzip ()
{
    lib::7z::install;
    while [[ -n "$*" ]]; do
        local archive="$1";
        shift;
        run "7z x -bt -mmt16 \"${archive}\"";
    done
}

```
### `lib::7z::zip`

```
lib::7z::zip ()
{
    lib::7z::install;
    while [[ -n "$*" ]]; do
        local folder="$1";
        shift;
        run "7z a -bt -mmt16 \"${folder}\".7z \"${folder}\"";
    done
}

```
### `lib::array::complain-unless-includes`

```
lib::array::complain-unless-includes ()
{
    lib::array::contains-element "$@" || {
        element="$1";
        shift;
        local -a output=();
        while true; do
            [[ -z "$1" ]] && break;
            if [[ "$1" =~ " " ]]; then
                output=("${output[@]}" "$1");
            else
                output=("$1");
            fi;
            shift;
        done;
        if [[ ${#output[@]} -gt 10 ]]; then
            error "Value ${element} must be one of the supplied values.";
        else
            error "Value ${element} must be one of the supplied values:" "${output[@:0:10]}";
        fi;
        echo;
        return 0
    };
    return 1
}

```
### `lib::array::contains-element`

```
lib::array::contains-element ()
{
    local search="$1";
    shift;
    [[ "$*" =~ ${search} ]] || return 1;
    for e in "${@}";
    do
        [[ "$e" == "${search}" ]] && {
            return 0
        };
    done;
    return 1
}

```
### `lib::array::exit-unless-includes`

```
lib::array::exit-unless-includes ()
{
    lib::array::complain-unless-includes "$@" || exit 1
}

```
### `lib::array::from-command-output`

```
lib::array::from-command-output ()
{
    local array_name=$1;
    shift;
    local script="while IFS='' read -r line; do ${array_name}+=(\"\$line\"); done < <($*)";
    eval "${script}"
}

```
### `lib::array::join`

```
lib::array::join ()
{
    local sep="$1";
    shift;
    local lines="$1";
    if [[ ${lines} == true || ${lines} == false ]]; then
        shift;
    else
        lines=false;
    fi;
    local elem;
    local len="$#";
    local last_index=$(( len - 1 ));
    local index=0;
    for elem in "$@";
    do
        if ${lines}; then
            printf "${sep}%s\n" "${elem}";
        else
            printf "%s" "${elem}";
            [[ ${index} -lt ${last_index} ]] && printf '%s' "${sep}";
        fi;
        index=$(( index + 1 ));
    done
}

```
### `lib::array::piped`

```
lib::array::piped ()
{
    lib::array::join ' | ' false "$@"
}

```
### `lib::audio::wav-to-mp3`

```
lib::audio::wav-to-mp3 ()
{
    local file="$1";
    shift;
    [[ -z "${file}" ]] && {
        h2 "USAGE: wav2mp3 <file.wav>" "NOTE: wave file sampling rate will be auto-detected.";
        return
    };
    [[ -n "$(which lame)" ]] || lib::brew::package::install lame;
    nfile=$(echo "${file}" | sed -E 's/\.wav$/\.mp3/ig');
    khz=$(lib::audio::wave-file-frequency "${file}");
    info "${bldgrn}Source: ${bldylw}$(basename "${file}")";
    info "${bldpur}Output: ${bldylw}${nfile}$(txt-info) | (sampling rate: ${bldgrn}${khz:-'Unknown'}kHz)";
    [[ -n ${khz} ]] && khz=" -s ${khz} ";
    run::set-next show-output-on;
    hr;
    run "lame --disptime 1 -m s -r -q 0 -b 320 ${khz} --cbr $* ${file} ${nfile}";
    hr
}

```
### `lib::audio::wave-file-frequency`

```
lib::audio::wave-file-frequency ()
{
    local file="$1";
    [[ -z $(which mdls) ]] && return 1;
    local frequency=$(mdls ${file} | grep kMDItemAudioSampleRate | sed 's/.*= //g');
    local kHz=$(( ${frequency} / 1000 ));
    printf ${kHz}
}

```
### `lib::brew::cache-reset`

```
lib::brew::cache-reset ()
{
    rm -f ${LibBrew__PackageCacheList} ${LibBrew__CaskCacheList}
}

```
### `lib::brew::cache-reset::delayed`

```
lib::brew::cache-reset::delayed ()
{
    (( ${BASH_IN_SUBSHELL} )) || lib::brew::cache-reset;
    (( ${BASH_IN_SUBSHELL} )) && trap "rm -f ${LibBrew__PackageCacheList} ${LibBrew__CaskCacheList}" EXIT
}

```
### `lib::brew::cask::is-installed`

```
lib::brew::cask::is-installed ()
{
    local cask="${1}";
    local -a installed_casks=($(lib::brew::cask::list));
    array-contains-element $(basename "${cask}") "${installed_casks[@]}"
}

```
### `lib::brew::cask::list`

```
lib::brew::cask::list ()
{
    lib::cache-or-command "${LibBrew__CaskCacheList}" 30 "brew cask ls -1"
}

```
### `lib::brew::cask::tap`

```
lib::brew::cask::tap ()
{
    run "brew tap homebrew/cask-cask"
}

```
### `lib::brew::install`

```
lib::brew::install ()
{
    declare -a brew_packages=$@;
    local brew=$(which brew 2>/dev/null);
    if [[ -z "${brew}" ]]; then
        info "Installing Homebrew, please wait...";
        /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)";
    else
        info "Homebrew is already installed.";
        info "Detected Homebrew Version: ${bldylw}$(brew --version 2>/dev/null | head -1)";
    fi
}

```
### `lib::brew::install::cask`

```
lib::brew::install::cask ()
{
    local cask=$1;
    local force=;
    local verbose=;
    [[ -n ${opts_force} ]] && force="--force";
    [[ -n ${opts_verbose} ]] && verbose="--verbose";
    inf "verifying brew cask ${bldylw}${cask}";
    if [[ -n $(ls -al /Applications/*.app | grep -i ${cask}) && -z ${opts_force} ]]; then
        ok:;
    else
        if [[ $(lib::brew::cask::is-installed ${cask}) == "true" ]]; then
            ok:;
            return 0;
        else
            kind_of_ok:;
            run "brew cask install ${cask} ${force} ${verbose}";
        fi;
    fi;
    lib::brew::cache-reset::delayed
}

```
### `lib::brew::install::package`

```
lib::brew::install::package ()
{
    local package=$1;
    local force=;
    local verbose=;
    [[ -n ${opts_force} ]] && force="--force";
    [[ -n ${opts_verbose} ]] && verbose="--verbose";
    inf "checking if package ${bldylw}${package}$(txt-info) is already installed...";
    if [[ $(lib::brew::package::is-installed ${package}) == "true" ]]; then
        ok:;
    else
        printf "${bldred}not found.${clr}\n";
        run "brew install ${package} ${force} ${verbose}";
        if [[ ${LibRun__LastExitCode} != 0 ]]; then
            info "NOTE: ${bldred}${package}$(txt-info) failed to install, attempting to reinstall...";
            lib::brew::reinstall::package "${package}";
        fi;
        lib::brew::cache-reset::delayed;
    fi
}

```
### `lib::brew::install::packages`

```
lib::brew::install::packages ()
{
    local force=;
    [[ -n ${opts_force} ]] && force="--force";
    for package in $@;
    do
        lib::brew::install::package ${package};
    done
}

```
### `lib::brew::package::is-installed`

```
lib::brew::package::is-installed ()
{
    local package="${1}";
    local -a installed_packages=($(lib::brew::package::list));
    array-contains-element $(basename "${package}") "${installed_packages[@]}"
}

```
### `lib::brew::package::list`

```
lib::brew::package::list ()
{
    lib::cache-or-command "${LibBrew__PackageCacheList}" 30 "brew ls -1"
}

```
### `lib::brew::reinstall::package`

```
lib::brew::reinstall::package ()
{
    local package="${1}";
    local force=;
    local verbose=;
    [[ -n ${opts_force} ]] && force="--force";
    [[ -n ${opts_verbose} ]] && verbose="--verbose";
    run "brew unlink ${package} ${force} ${verbose}; true";
    run "brew uninstall ${package}  ${force} ${verbose}; true";
    run "brew install ${package} ${force} ${verbose}";
    run "brew link ${package} --overwrite ${force} ${verbose}";
    lib::brew::cache-reset::delayed
}

```
### `lib::brew::reinstall::packages`

```
lib::brew::reinstall::packages ()
{
    local force=;
    [[ -n ${opts_force} ]] && force="--force";
    for package in $@;
    do
        lib::brew::uninstall::package ${package};
        lib::brew::install::package ${package};
    done
}

```
### `lib::brew::relink`

```
lib::brew::relink ()
{
    local package=${1};
    local verbose=;
    [[ -n ${opts_verbose} ]] && verbose="--verbose";
    run "brew link ${verbose} ${package} --overwrite"
}

```
### `lib::brew::setup`

```
lib::brew::setup ()
{
    lib::brew::upgrade
}

```
### `lib::brew::uninstall::package`

```
lib::brew::uninstall::package ()
{
    local package=$1;
    local force=;
    local verbose=;
    [[ -n ${opts_force} ]] && force="--force";
    [[ -n ${opts_verbose} ]] && verbose="--verbose";
    export LibRun__AbortOnError=${False};
    run "brew unlink ${package} ${force} ${verbose}";
    export LibRun__AbortOnError=${False};
    run "brew uninstall ${package} ${force} ${verbose}";
    lib::brew::cache-reset::delayed
}

```
### `lib::brew::uninstall::packages`

```
lib::brew::uninstall::packages ()
{
    local force=;
    [[ -n ${opts_force} ]] && force="--force";
    for package in $@;
    do
        lib::brew::uninstall::package ${package};
    done
}

```
### `lib::brew::upgrade`

```
lib::brew::upgrade ()
{
    lib::brew::install;
    if [[ -z "$(which brew)" ]]; then
        warn "brew is not installed....";
        return 1;
    fi;
    run "brew update --force";
    run "brew upgrade";
    run "brew cleanup -s"
}

```
### `lib::cache-or-command`

```
lib::cache-or-command ()
{
    local file="$1";
    shift;
    local stale_minutes="$1";
    shift;
    local command="$*";
    lib::file::exists_and_newer_than "${file}" ${stale_minutes} && {
        cat "${file}";
        return 0
    };
    cp /dev/null ${file} > /dev/null;
    eval "${command}" | tee -a "${file}"
}

```
### `lib::caller::stack`

```
lib::caller::stack ()
{
    local index=${1:-"-1"};
    while true; do
        index=$(( index + 1 ));
        caller ${index} 2>&1 > /dev/null || break;
        local -a frame=($(caller ${index} | tr ' ' '\n'));
        printf "%3d [ %-40.40s ]: %s\n" ${index} "${frame[2]}:${frame[0]}" "${frame[1]}";
    done
}

```
### `lib::color::disable`

```
lib::color::disable ()
{
    export clr='\e[0m';
    unset txtblk;
    unset txtred;
    unset txtgrn;
    unset txtylw;
    unset txtblu;
    unset txtpur;
    unset txtcyn;
    unset txtwht;
    unset bldblk;
    unset bldred;
    unset bldgrn;
    unset bldylw;
    unset bldblu;
    unset bldpur;
    unset bldcyn;
    unset bldwht;
    unset unkblk;
    unset undred;
    unset undgrn;
    unset undylw;
    unset undblu;
    unset undpur;
    unset undcyn;
    unset undwht;
    unset bakblk;
    unset bakred;
    unset bakgrn;
    unset bakylw;
    unset bakblu;
    unset bakpur;
    unset bakcyn;
    unset bakwht;
    unset txtrst;
    unset italic;
    unset bold;
    unset strikethrough;
    unset underlined;
    unset white_on_orange;
    unset white_on_yellow;
    unset white_on_red;
    unset white_on_pink;
    unset white_on_salmon;
    unset yellow_on_gray;
    export AppColorsLoaded=1;
    trap reset-color EXIT
}

```
### `lib::color::enable`

```
lib::color::enable ()
{
    if [[ -z "${AppColorsLoaded}" ]]; then
        export txtblk='\e[0;30m';
        export txtred='\e[0;31m';
        export txtgrn='\e[0;32m';
        export txtylw='\e[0;33m';
        export txtblu='\e[0;34m';
        export txtpur='\e[0;35m';
        export txtcyn='\e[0;36m';
        export txtwht='\e[0;37m';
        export bldblk='\e[1;30m';
        export bldred='\e[1;31m';
        export bldgrn='\e[1;32m';
        export bldylw='\e[1;33m';
        export bldblu='\e[1;34m';
        export bldpur='\e[1;35m';
        export bldcyn='\e[1;36m';
        export bldwht='\e[1;37m';
        export unkblk='\e[4;30m';
        export undred='\e[4;31m';
        export undgrn='\e[4;32m';
        export undylw='\e[4;33m';
        export undblu='\e[4;34m';
        export undpur='\e[4;35m';
        export undcyn='\e[4;36m';
        export undwht='\e[4;37m';
        export bakblk='\e[40m';
        export bakred='\e[41m';
        export bakgrn='\e[42m';
        export bakylw='\e[43m';
        export bakblu='\e[44m';
        export bakpur='\e[45m';
        export bakcyn='\e[46m';
        export bakwht='\e[47m';
        export txtrst='\e[0m';
        export rst='\e[0m';
        export clr='\e[0m';
        export bold='\e[1m';
        export italic='\e[3m';
        export underlined='\e[4m';
        export strikethrough='\e[9m';
        export white_on_orange="\e[48;5;208m";
        export white_on_yellow="\e[48;5;214m";
        export white_on_red="\e[48;5;9m";
        export white_on_pink="\e[48;5;199m";
        export white_on_salmon="\e[48;5;196m";
        export yellow_on_gray="\e[38;5;220m\e[48;5;242m";
        export AppColorsLoaded=1;
    else
        [[ -n ${DEBUG} ]] && echo "colors already loaded...";
    fi;
    trap reset-color EXIT
}

```
### `lib::db::datetime`

```
lib::db::datetime ()
{
    date '+%Y%m%d-%H%M%S'
}

```
### `lib::db::dump`

```
lib::db::dump ()
{
    local dbname=${1};
    shift;
    local psql_args="$*";
    [[ -z "${psql_args}" ]] && psql_args="-U postgres -h localhost";
    local filename=$(__lib::db::backup-filename ${dbname});
    [[ $? != 0 ]] && return;
    [[ ${LibRun__Verbose} -eq ${True} ]] && {
        info "dumping from: ${bldylw}${dbname}";
        info "saving to...: ${bldylw}${filename}"
    };
    cmd="pg_dump -Fc -Z5 ${psql_args} -f ${filename} ${dbname}";
    run "${cmd}";
    code=${LibRun__LastExitCode};
    if [[ ${code} != 0 ]]; then
        not_ok:;
        error "pg_dump exited with code ${code}";
        return ${code};
    else
        ok:;
        return 0;
    fi
}

```
### `lib::db::num_procs`

```
lib::db::num_procs ()
{
    ps -ef | grep [p]ostgres | wc -l | awk '{print $1}'
}

```
### `lib::db::psql-args`

```
lib::db::psql-args ()
{
    lib::db::psql::args:: "$@"
}

```
### `lib::db::psql::args::`

```
lib::db::psql::args:: ()
{
    printf -- "-U ${AppPostgresUsername} -h ${AppPostgresHostname} $*"
}

```
### `lib::db::psql::args::default`

```
lib::db::psql::args::default ()
{
    printf -- "-U postgres -h localhost $*"
}

```
### `lib::db::psql::args::maint`

```
lib::db::psql::args::maint ()
{
    printf -- "-U postgres -h localhost --maintenance-db=postgres $*"
}

```
### `lib::db::rails::schema::checksum`

```
lib::db::rails::schema::checksum ()
{
    if [[ -d db/migrate ]]; then
        find db/migrate -type f -ls | awk '{printf("%10d-%s\n",$7,$11)}' | sort | shasum | awk '{print $1}';
    else
        local schema=$(lib::db::rails::schema::file);
        [[ -s ${schema} ]] || error "can not find Rails schema in either ${RAILS_SCHEMA_RB} or ${RAILS_SCHEMA_SQL}";
        [[ -s ${schema} ]] && lib::util::checksum::files "${schema}";
    fi
}

```
### `lib::db::rails::schema::file`

```
lib::db::rails::schema::file ()
{
    if [[ -f "${RAILS_SCHEMA_RB}" && -f "${RAILS_SCHEMA_SQL}" ]]; then
        if [[ "${RAILS_SCHEMA_RB}" -nt "${RAILS_SCHEMA_SQL}" ]]; then
            printf "${RAILS_SCHEMA_RB}";
        else
            printf "${RAILS_SCHEMA_SQL}";
        fi;
    else
        if [[ -f "${RAILS_SCHEMA_RB}" ]]; then
            printf "${RAILS_SCHEMA_RB}";
        else
            if [[ -f "${RAILS_SCHEMA_SQL}" ]]; then
                printf "${RAILS_SCHEMA_SQL}";
            fi;
        fi;
    fi
}

```
### `lib::db::restore`

```
lib::db::restore ()
{
    local dbname="$1";
    shift;
    local filename="$1";
    [[ -n ${filename} ]] && shift;
    [[ -z ${filename} ]] && filename=$(__lib::db::backup-filename ${dbname});
    [[ dbname =~ 'production' ]] && {
        error 'This script is not meant for production';
        return 1
    };
    [[ -s ${filename} ]] || {
        error "can't find valid backup file in ${bldylw}${filename}";
        return 2
    };
    psql_args=$(lib::db::psql::args::default);
    maint_args=$(lib::db::psql::args::maint);
    run "dropdb ${maint_args} ${dbname} 2>/dev/null; true";
    export LibRun__AbortOnError=${True};
    run "createdb ${maint_args} ${dbname} ${psql_args}";
    [[ ${LibRun__Verbose} -eq ${True} ]] && {
        info "restoring from..: ${bldylw}${filename}";
        info "restoring to....: ${bldylw}${dbname}"
    };
    run "pg_restore -Fc -j 8 ${psql_args} -d ${dbname} ${filename}";
    code=${LibRun__LastExitCode};
    if [[ ${code} != 0 ]]; then
        warning "pg_restore completed with exit code ${code}";
        return ${code};
    fi;
    return ${LibRun__LastExitCode}
}

```
### `lib::db::top`

```
lib::db::top ()
{
    local dbnames=$@;
    h1 "Please wait while we resolve DB names using AWSCLI...";
    local db;
    local dbtype;
    local width_min=90;
    local height_min=50;
    local width=$(__lib::output::screen-width);
    local height=$(__lib::output::screen-height);
    if [[ ${width} -lt ${width_min} || ${height} -lt ${height_min} ]]; then
        error "Your screen is too small for db.top.";
        info "Minimum required screen dimensions are ${width_min} columns, ${height_min} rows.";
        info "Your screen is ${bldred}${width}x${height}.";
        return;
    fi;
    declare -A connections=();
    declare -a connection_names=();
    local i=0;
    for dbname in $dbnames;
    do
        declare -a results=($(__lib::db::by_shortname $dbname));
        if [[ -n ${#results[@]} ]]; then
            dbtype="${results[0]}";
            i=$(($i + 1));
            db="${results[@]:1}";
            if [[ -n ${dbtype} ]]; then
                [[ ${dbtype} == "master" ]] && dbname="master";
                [[ ${dbtype} == "replica" ]] && dbname="replica-${dbname}";
                connections[${dbname}]="${db}";
                connection_names[$i]=${dbname};
            fi;
        fi;
    done;
    if [[ ${#connections[@]} == 0 ]]; then
        error "usage: $0 db1, db2, ... ";
        info "eg: lib::db::top m r2 ";
        ((${BASH_IN_SUBSHELL})) && exit 1 || return 1;
    fi;
    trap "clear" TERM;
    trap "clear" EXIT;
    local clear=0;
    local interval=${DB_TOP_REFRESH_RATE:-0.5};
    local num_dbs=${#connection_names[@]};
    local tof="$(mktemp -d "${TMPDIR:-/tmp/}.XXXXXXXXXXXX")/.db.top.$$";
    cp /dev/null ${tof};
    while true; do
        local index=0;
        cursor.at.y 0;
        local screen_height=$(screen.height);
        for __dbtype in "${connection_names[@]}";
        do
            index=$((${index} + 1));
            local percent_total_height=0;
            if [[ ${num_dbs} -eq 2 ]]; then
                [[ ${index} -eq 2 ]] && percent_total_height=66;
            else
                if [[ ${num_dbs} -eq 3 ]]; then
                    [[ ${index} -eq 2 ]] && percent_total_height=50;
                    [[ ${index} -eq 3 ]] && percent_total_height=80;
                else
                    if [[ ${num_dbs} -eq 4 ]]; then
                        [[ ${index} -eq 2 ]] && percent_total_height=40;
                        [[ ${index} -eq 3 ]] && percent_total_height=60;
                        [[ ${index} -eq 4 ]] && percent_total_height=80;
                    fi;
                fi;
            fi;
            local vertical_shift=$((${percent_total_height} * ${screen_height} / 100));
            cursor.at.y ${vertical_shift} >> ${tof};
            [[ -n ${DEBUG} ]] && h::blue "screen_height = ${screen_height} | percent_total_height = ${percent_total_height} | vertical_shift = ${vertical_shift}" >> ${tof};
            hr::colored ${bldpur} >> ${tof};
            __lib::db::top::page "${tof}" "${__dbtype}" "${connections[${__dbtype}]}";
        done;
        clear;
        h::yellow " ¬´   DB-TOP V0.1.2 ¬© 2018-2019 Konstantin Gredeskoul, ReinventONE Inc. ¬ª ";
        cat ${tof};
        cursor.at.y $(($(__lib::output::screen-height) + 1));
        printf "${bldwht}Press Ctrl-C to quit.${clr}";
        cp /dev/null ${tof};
        sleep ${interval};
    done
}

```
### `lib::db::wait-until-db-online`

```
lib::db::wait-until-db-online ()
{
    local db=${1};
    inf 'waiting for the database to come up...';
    while true; do
        out=$(psql -c "select count(*) from accounts" $(lib::db::psql::args:: ${db}) 2>&1);
        code=$?;
        [[ ${code} == 0 ]] && break;
        [[ ${code} == 1 ]] && break;
        sleep 1;
        [[ ${out} =~ 'does not exist' ]] && break;
    done;
    ok:;
    return 0
}

```
### `lib::deploy::slack`

```
lib::deploy::slack ()
{
    local original_text="$*";
    [[ -z ${LibDeploy__SlackHookUrl} ]] && return 1;
    local text=$(echo "${original_text}" | sed -E 's/"/\"/g' | sed -E "s/'/\'/g");
    local json="{\"text\": \"$text\"}";
    local slack_url="${LibDeploy__SlackHookUrl}";
    [[ ${LibRun__DryRun} -eq ${False} ]] && {
        if ${LibDeploy__NoSlack}; then
            hl::green "${original_text}";
        else
            curl -s -d "payload=$json" "${slack_url}" > /dev/null;
            if [[ $? -eq 0 ]]; then
                info: "sent to Slack: [${text}]";
            else
                warning: "error sending to Slack, is your SLACK_URL set?";
            fi;
        fi
    };
    [[ ${LibRun__DryRun} -eq ${True} ]] && run "send to slack [${text}]"
}

```
### `lib::deploy::slack-ding`

```
lib::deploy::slack-ding ()
{
    lib::deploy::slack "<!here> $@"
}

```
### `lib::deploy::validate-vpn`

```
lib::deploy::validate-vpn ()
{
    __lib::deploy::check-vpn "$@" || __lib::deploy::vpn-error "$@"
}

```
### `lib::dir::count-slashes`

```
lib::dir::count-slashes ()
{
    local dir="${1}";
    echo "${dir}" | sed 's/[^/]//g' | tr -d '\n' | wc -c | tr -d ' '
}

```
### `lib::dir::expand-dir`

```
lib::dir::expand-dir ()
{
    local dir="${1}";
    if [[ "${dir:0:1}" != "/" && "${dir:0:1}" != "~" ]]; then
        dir="$(pwd)/${dir}";
    else
        if [[ "${dir:0:1}" == "~" ]]; then
            dir="${HOME}/${dir:1:1000}";
        fi;
    fi;
    printf "${dir}"
}

```
### `lib::dir::is-a-dir`

```
lib::dir::is-a-dir ()
{
    local dir="${1}";
    [[ -d "${dir}" ]]
}

```
### `lib::docker::abort-if-down`

```
lib::docker::abort-if-down ()
{
    local should_exit="${1:-true}";
    inf 'Checking if Docker is running...';
    docker ps 2> /dev/null > /dev/null;
    code=$?;
    if [[ ${code} == 0 ]]; then
        ok:;
    else
        not_ok:;
        error "docker ps returned ${code}, is Docker running?";
        [[ "${should_exit}" == "true" ]] && exit 127;
        return 127;
    fi
}

```
### `lib::docker::actions::build`

```
lib::docker::actions::build ()
{
    lib::docker::build::container "$@"
}

```
### `lib::docker::actions::clean`

```
lib::docker::actions::clean ()
{
    __lib::docker::exec "docker-compose rm"
}

```
### `lib::docker::actions::pull`

```
lib::docker::actions::pull ()
{
    local tag=${1:-'latest'};
    __lib::docker::check-repo "${2}" || return 1;
    __lib::docker::exec "docker pull ${AppDockerRepo}:${tag}"
}

```
### `lib::docker::actions::push`

```
lib::docker::actions::push ()
{
    local tag=${1:-$(__lib::docker::next-version)};
    __lib::docker::check-repo "${2}" || return 1;
    lib::docker::actions::tag latest;
    [[ -n ${tag} ]] && lib::docker::actions::tag "${tag}";
    __lib::docker::check-repo || return 1;
    __lib::docker::exec docker push "${AppDockerRepo}:${tag}";
    [[ ${tag} != 'latest' ]] && __lib::docker::exec docker push "${AppDockerRepo}:latest"
}

```
### `lib::docker::actions::setup`

```
lib::docker::actions::setup ()
{
    lib::setup::docker;
    lib::docker::pull;
    lib::docker::build
}

```
### `lib::docker::actions::start`

```
lib::docker::actions::start ()
{
    __lib::docker::exec "docker-compose start"
}

```
### `lib::docker::actions::stop`

```
lib::docker::actions::stop ()
{
    __lib::docker::exec "docker-compose stop"
}

```
### `lib::docker::actions::tag`

```
lib::docker::actions::tag ()
{
    local tag=${1};
    [[ -z ${tag} ]] && return 1;
    __lib::docker::check-repo "${2}" || return 1;
    __lib::docker::exec docker tag "${AppDockerRepo}" "${AppDockerRepo}:${tag}"
}

```
### `lib::docker::actions::up`

```
lib::docker::actions::up ()
{
    __lib::docker::exec "docker-compose up"
}

```
### `lib::docker::actions::update`

```
lib::docker::actions::update ()
{
    lib::docker::build;
    lib::docker::push
}

```
### `lib::docker::build::container`

```
lib::docker::build::container ()
{
    __lib::docker::check-repo "${1}" || return 1;
    local tag=${AppDockerRepo};
    __lib::docker::exec "docker build -m 3G -c 4 --pull -t ${tag} . $*"
}

```
### `lib::docker::containers::clean`

```
lib::docker::containers::clean ()
{
    local -a args=("$@");
    run "docker rm $(docker ps -q -a) ${args[*]}"
}

```
### `lib::docker::image::inspect`

```
lib::docker::image::inspect ()
{
    run::set-next show-output-on;
    local jq=" | jq";
    [[ -z $(command -v jq) ]] && jq=;
    run "docker image inspect ${*} $jq"
}

```
### `lib::docker::image::rm`

```
lib::docker::image::rm ()
{
    run "docker image rm ${*}"
}

```
### `lib::docker::images-named`

```
lib::docker::images-named ()
{
    local name="${1}";
    local func="${2}";
    lib::docker::abort-if-down false || return 127;
    hl::subtle "Processing Docker images matching ${name} with function ${func}...";
    local images="$(docker images | grep "^${name}" | sed 's/  */ /g' | cut -d ' ' -f 3 | tr '\n' ' ')";
    ${func} ${images}
}

```
### `lib::docker::images::clean`

```
lib::docker::images::clean ()
{
    local name=${1:-"<none>"};
    lib::docker::images-named "${name}" "lib::docker::image::rm"
}

```
### `lib::docker::images::inspect`

```
lib::docker::images::inspect ()
{
    local name=${1:-"<none>"};
    lib::docker::images-named "${name}" "lib::docker::image::inspect"
}

```
### `lib::docker::last-version`

```
lib::docker::last-version ()
{
    __lib::docker::check-repo "${1}" || return 1;
    [[ -z ${AppDockerRepo} ]] && {
        error "usage: lib::docker::last-version organization/reponame:version";
        return 1
    };
    __lib::docker::last-version "$@"
}

```
### `lib::docker::next-version`

```
lib::docker::next-version ()
{
    __lib::docker::check-repo "${1}" || return 1;
    [[ -z ${AppDockerRepo} ]] && {
        error "usage: lib::docker::next-version [ organization/repo-name:version ]";
        return 1
    };
    __lib::docker::next-version "$@"
}

```
### `lib::docker::set-repo`

```
lib::docker::set-repo ()
{
    [[ -n "$1" ]] && export AppDockerRepo="$1"
}

```
### `lib::file::exists_and_newer_than`

```
lib::file::exists_and_newer_than ()
{
    local file="${1}";
    shift;
    local minutes="${1}";
    shift;
    if [[ -n "$(find ${file} -mmin -${minutes} -print 2>/dev/null)" ]]; then
        return 0;
    else
        return 1;
    fi
}

```
### `lib::file::gsub`

```
lib::file::gsub ()
{
    local file="$1";
    shift;
    local find="$1";
    shift;
    local replace="$1";
    shift;
    local runtime_options="$*";
    [[ ! -s "${file}" || -z "${find}" || -z "${replace}" ]] && {
        error "Invalid usage of lib::file::sub ‚Äî " "USAGE: lib::file::gsub <file>    <find-regex>        <replace-regex>" "EG:    lib::file::gsub ~/.bashrc '^export EDITOR=vi' 'export EDITOR=gvim'";
        return 1
    };
    egrep -q "${find}" "${file}" || return 0;
    [[ -z "${runtime_options}" ]] || run::set-next ${runtime_options};
    run "sed -i'' -E -e 's/${find}/${replace}/g' \"${file}\""
}

```
### `lib::file::install_with_backup`

```
lib::file::install_with_backup ()
{
    local source=$1;
    local dest=$2;
    if [[ ! -f ${source} ]]; then
        error "file ${source} can not be found";
        return -1;
    fi;
    if [[ -f "${dest}" ]]; then
        if [[ -z $(diff ${dest} ${source} 2>/dev/null) ]]; then
            info: "${dest} is up to date";
            return 0;
        else
            ((${LibFile__ForceOverwrite})) || {
                info "file ${dest} already exists, skipping (use -f to overwrite)";
                return 0
            };
            inf "making a backup of ${dest} (${dest}.bak)";
            cp "${dest}" "${dest}.bak" > /dev/null;
            ok:;
        fi;
    fi;
    run "mkdir -p $(dirname ${dest}) && cp ${source} ${dest}"
}

```
### `lib::file::last-modified-date`

```
lib::file::last-modified-date ()
{
    stat -f "%Sm" -t "%Y-%m-%d" "$1"
}

```
### `lib::file::last-modified-year`

```
lib::file::last-modified-year ()
{
    stat -f "%Sm" -t "%Y" "$1"
}

```
### `lib::gem::cache-installed`

```
lib::gem::cache-installed ()
{
    lib::gem::configure-cache;
    if [[ ! -s "${LibGem__GemListCache}" || -z $(find "${LibGem__GemListCache}" -mmin -30 2>/dev/null) ]]; then
        run "gem list > ${LibGem__GemListCache}";
    fi
}

```
### `lib::gem::cache-refresh`

```
lib::gem::cache-refresh ()
{
    lib::gem::configure-cache;
    gem.clear-cache;
    lib::gem::cache-installed
}

```
### `lib::gem::configure-cache`

```
lib::gem::configure-cache ()
{
    export LibGem__GemListCacheBase=/tmp/.bashmatic/.gem/gem.list;
    export LibGem__GemListCache=;
    export LibGem__GemInstallFlags=" -N --force --quiet ";
    local ruby_version=$(ruby.numeric-version);
    export LibGem__GemListCache="${LibGem__GemListCacheBase}.${ruby_version}";
    local dir=$(dirname ${LibGem__GemListCache});
    [[ -d ${dir} ]] || run "mkdir -p ${dir}"
}

```
### `lib::gem::ensure-gem-version`

```
lib::gem::ensure-gem-version ()
{
    local gem=$1;
    local gem_version=$2;
    [[ -z ${gem} || -z ${gem_version} ]] && return;
    lib::gem::cache-installed;
    if [[ -z $(cat ${LibGem__GemListCache} | grep "${gem} (${gem_version})") ]]; then
        lib::gem::uninstall ${gem};
        lib::gem::install ${gem} ${gem_version};
    else
        info "gem ${gem} version ${gem_version} is already installed.";
    fi
}

```
### `lib::gem::gemfile::version`

```
lib::gem::gemfile::version ()
{
    local gem=$1;
    [[ -z ${gem} ]] && return;
    if [[ -f Gemfile.lock ]]; then
        egrep "^    ${gem} \([0-9]+\.[0-9]+\.[0-9]\)" Gemfile.lock | awk '{print $2}' | sed 's/[()]//g';
    fi
}

```
### `lib::gem::global::latest-version`

```
lib::gem::global::latest-version ()
{
    local gem=$1;
    [[ -z ${gem} ]] && return;
    declare -a versions=($(lib::gem::global::versions ${gem}));
    local max=0;
    local max_version=;
    for v in ${versions[@]};
    do
        vi=$(lib::util::ver-to-i ${v});
        if [[ ${vi} -gt ${max} ]]; then
            max=${vi};
            max_version=${v};
        fi;
    done;
    printf "%s" "${max_version}"
}

```
### `lib::gem::global::versions`

```
lib::gem::global::versions ()
{
    local gem=$1;
    [[ -z ${gem} ]] && return;
    lib::gem::cache-installed;
    cat ${LibGem__GemListCache} | egrep "^${gem} " | hbsed "s/^${gem} //g;s/[(),]//g"
}

```
### `lib::gem::install`

```
lib::gem::install ()
{
    local gem_name=$1;
    local gem_version=$2;
    local gem_version_flags=;
    local gem_version_name=;
    gem_version=${gem_version:-$(lib::gem::version ${gem_name})};
    if [[ -z ${gem_version} ]]; then
        gem_version_name=latest;
        gem_version_flags=;
    else
        gem_version_name="${gem_version}";
        gem_version_flags="--version ${gem_version}";
    fi;
    if [[ -z $(lib::gem::is-installed ${gem_name} ${gem_version}) ]]; then
        info "installing ${bldylw}${gem_name} ${bldgrn}(${gem_version_name})${txtblu}...";
        run "gem install ${gem_name} ${gem_version_flags} ${LibGem__GemInstallFlags}";
        if [[ ${LibRun__LastExitCode} -eq 0 ]]; then
            rbenv rehash > /dev/null 2> /dev/null;
            lib::gem::cache-refresh;
        else
            error "Unable to install gem ${bldylw}${gem_name}";
        fi;
        return ${LibRun__LastExitCode};
    else
        info: "gem ${bldylw}${gem_name} (${bldgrn}${gem_version_name}${bldylw})${txtblu} is already installed";
    fi
}

```
### `lib::gem::is-installed`

```
lib::gem::is-installed ()
{
    local gem=$1;
    local version=$2;
    lib::gem::cache-installed;
    if [[ -z ${version} ]]; then
        egrep "^${gem} \(" "${LibGem__GemListCache}";
    else
        egrep "^${gem} \(" "${LibGem__GemListCache}" | grep "${version}";
    fi
}

```
### `lib::gem::uninstall`

```
lib::gem::uninstall ()
{
    local gem_name=$1;
    local gem_version=$2;
    if [[ -z $(lib::gem::is-installed ${gem_name} ${gem_version}) ]]; then
        info "gem ${bldylw}${gem_name}${txtblu} is not installed";
        return;
    fi;
    local gem_flags="-x -I --force";
    if [[ -z ${gem_version} ]]; then
        gem_flags="${gem_flags} -a";
    else
        gem_flags="${gem_flags} --version ${gem_version}";
    fi;
    run "gem uninstall ${gem_name} ${gem_flags}";
    lib::gem::cache-refresh
}

```
### `lib::gem::version`

```
lib::gem::version ()
{
    local gem=$1;
    local default=$2;
    [[ -z ${gem} ]] && return;
    local version;
    [[ -f Gemfile.lock ]] && version=$(lib::gem::gemfile::version ${gem});
    [[ -z ${version} ]] && version=$(lib::gem::global::latest-version ${gem});
    [[ -z ${version} && -n ${default} ]] && version=${default};
    printf "%s" "${version}"
}

```
### `lib::git::configure-auto-updates`

```
lib::git::configure-auto-updates ()
{
    export LibGit__StaleAfterThisManyHours="${LibGit__StaleAfterThisManyHours:-"1"}";
    export LibGit__LastUpdateTimestampFile="/tmp/.bashmatic/.config/$(echo ${USER} | lib::util::checksum::stdin)";
    mkdir -p $(dirname ${LibGit__LastUpdateTimestampFile})
}

```
### `lib::git::last-update-at`

```
lib::git::last-update-at ()
{
    lib::git::configure-auto-updates;
    local file="${1:-"${LibGit__LastUpdateTimestampFile}"}";
    local last_update=0;
    [[ -f ${file} ]] && last_update="$(cat $file | tr -d '\n')";
    printf "%d" ${last_update}
}

```
### `lib::git::local-vs-remote`

```
lib::git::local-vs-remote ()
{
    local upstream=${1:-'@{u}'};
    local local_repo=$(git rev-parse @);
    local remote_repo=$(git rev-parse "$upstream");
    local base=$(git merge-base @ "$upstream");
    if [[ -n ${DEBUG} ]]; then
        printf "
      pwd         = $(pwd)
      remote      = $(lib::git::remotes)
      base        = ${base}
      upstream    = ${upstream}
      local_repo  = ${local_repo}
      remote_repo = ${remote_repo}
    ";
    fi;
    local result=;
    if [[ "${local_repo}" == "${remote_repo}" ]]; then
        result="ok";
    else
        if [[ "${local_repo}" == "${base}" ]]; then
            result="behind";
        else
            if [[ "${remote_repo}" == "${base}" ]]; then
                result="ahead";
            else
                result="diverged";
            fi;
        fi;
    fi;
    printf '%s' ${result};
    [[ ${result} == "ok" ]] && return 0;
    return 1
}

```
### `lib::git::quiet`

```
lib::git::quiet ()
{
    [[ -n ${LibGit__QuietUpdate} ]]
}

```
### `lib::git::remotes`

```
lib::git::remotes ()
{
    git remote -v | awk '{print $2}' | uniq
}

```
### `lib::git::repo-is-clean`

```
lib::git::repo-is-clean ()
{
    local repo="${1:-${BashMatic__Home}}";
    cd "${repo}" > /dev/null;
    if [[ -z $(git status -s) ]]; then
        cd - > /dev/null;
        return 0;
    else
        cd - > /dev/null;
        return 1;
    fi
}

```
### `lib::git::save-last-update-at`

```
lib::git::save-last-update-at ()
{
    echo $(epoch) > ${LibGit__LastUpdateTimestampFile}
}

```
### `lib::git::seconds-since-last-pull`

```
lib::git::seconds-since-last-pull ()
{
    local last_update="$1";
    local now=$(epoch);
    printf $((now - last_update))
}

```
### `lib::git::sync`

```
lib::git::sync ()
{
    local dir="$(pwd)";
    cd "${BashMatic__Home}" > /dev/null;
    lib::git::repo-is-clean || {
        warning "${bldylw}${BashMatic__Home} has locally modified files." "Please commit or stash them to allow auto-upgrade to function as designed." 1>&2;
        cd "${dir}" > /dev/null;
        return 1
    };
    lib::git::update-repo-if-needed;
    cd "${dir}" > /dev/null;
    return 0
}

```
### `lib::git::sync-remote`

```
lib::git::sync-remote ()
{
    if lib::git::quiet; then
        ( git remote update && git fetch ) 2>&1 > /dev/null;
    else
        run "git remote update && git fetch";
    fi;
    local status=$(lib::git::local-vs-remote);
    if [[ ${status} == "behind" ]]; then
        lib::git::quiet || run "git pull --rebase";
        lib::git::quiet && git pull --rebase 2>&1 > /dev/null;
    else
        if [[ ${status} != "ahead" ]]; then
            lib::git::save-last-update-at;
        else
            if [[ ${status} != "ok" ]]; then
                error "Report $(pwd) is ${status} compared to the remote." "Please fix manually to continue.";
                return 1;
            fi;
        fi;
    fi;
    lib::git::save-last-update-at;
    return 0
}

```
### `lib::git::update-repo-if-needed`

```
lib::git::update-repo-if-needed ()
{
    local last_update_at=$(lib::git::last-update-at);
    local second_since_update=$(lib::git::seconds-since-last-pull ${last_update_at});
    local update_period_seconds=$((LibGit__StaleAfterThisManyHours * 60 * 60));
    if [[ ${second_since_update} -gt ${update_period_seconds} ]]; then
        lib::git::sync-remote;
    else
        if [[ -n ${DEBUG} ]]; then
            lib::git::quiet || info "${BashMatic__Home} will update in $((update_period_seconds - second_since_update)) seconds...";
        fi;
    fi
}

```
### `lib::json::begin-array`

```
lib::json::begin-array ()
{
    [[ -n "$1" ]] && lib::json::begin-key "$1";
    echo " ["
}

```
### `lib::json::begin-hash`

```
lib::json::begin-hash ()
{
    [[ -n "$1" ]] && lib::json::begin-key "$1";
    echo "{"
}

```
### `lib::json::begin-key`

```
lib::json::begin-key ()
{
    if [[ -n "$1" ]]; then
        printf "\"${1}\": ";
    fi
}

```
### `lib::json::end-array`

```
lib::json::end-array ()
{
    printf "]";
    [[ "$1" == "true" ]] && printf ",";
    echo
}

```
### `lib::json::end-hash`

```
lib::json::end-hash ()
{
    printf "}";
    [[ "$1" == "true" ]] && printf ",";
    echo
}

```
### `lib::json::file-to-array`

```
lib::json::file-to-array ()
{
    lib::json::begin-array "$1";
    cat $2 | tr -d '\r' | tr -d '\015' | sed 's/^/"/g;s/$/",/g' | tail -r | awk -F, '{if (FNR!=1) print; else print $1} ' | tail -r;
    lib::json::end-array $3
}

```
### `lib::osx::cookie-dump`

```
lib::osx::cookie-dump ()
{
    local file="$1";
    local tmp;
    if [[ ! -s ${file} ]]; then
        tmp=$(mktemp);
        file=${tmp};
        pbpaste > ${file};
        local size=$(file::size ${file});
        if [[ ${size} -lt 4 ]]; then
            error "Pasted data is too small to be a valid cookie?";
            info "Here is what we got in your clipboard:\n\n$(cat ${file})\n";
            return 1;
        fi;
    fi;
    if [[ -s ${file} ]]; then
        cat "${file}" | tr '; ' '\n' | sed '/^$/d' | awk 'BEGIN{FS="="}{printf( "%10d = %s\n", length($2), $1) }' | sort -n;
    else
        info "File ${file} does not exist or is empty. ";
        info "Copy the value of the ${bldylw}Set-Cookie:${txtblu} header into the clipboard,";
        info "and rerun this function.";
    fi;
    [[ -z ${tmp} ]] || rm -f ${tmp}
}

```
### `lib::osx::env-print`

```
lib::osx::env-print ()
{
    local var="$1";
    printf "${bldylw}%20s: ${bldgrn}%s\n" ${var} ${!var}
}

```
### `lib::osx::local-servers`

```
lib::osx::local-servers ()
{
    local protocol="${1:-"ssh"}";
    run::set-next show-output-on;
    run "timeout 20 dns-sd -B _${protocol}._tcp ."
}

```
### `lib::osx::ramdisk::mount`

```
lib::osx::ramdisk::mount ()
{
    [[ $(uname -s) != "Darwin" ]] && {
        error "This function only works on OSX";
        return 1
    };
    if [[ -z $(df -h | grep ramdisk) ]]; then
        diskutil erasevolume HFS+ 'ramdisk' `hdiutil attach -nomount ram://8192`;
    fi
}

```
### `lib::osx::ramdisk::unmount`

```
lib::osx::ramdisk::unmount ()
{
    [[ $(uname -s) != "Darwin" ]] && {
        error "This function only works on OSX";
        return 1
    };
    if [[ -n $(df -h | grep ramdisk) ]]; then
        umount /Volumes/ramdisk;
    fi
}

```
### `lib::osx::scutil-print`

```
lib::osx::scutil-print ()
{
    local var="$1";
    printf "${bldylw}%20s: ${bldgrn}%s\n" ${var} $(sudo scutil --get ${var} | tr -d '\n')
}

```
### `lib::osx::set-fqdn`

```
lib::osx::set-fqdn ()
{
    local fqdn="$1";
    local domain=$(echo ${fqdn} | sed -E 's/^[^.]*\.//g');
    local host=$(echo ${fqdn} | sed -E 's/\..*//g');
    h1 "Current HostName: ${bldylw}${HOSTNAME}";
    echo;
    info "‚Ä¢ You provided the following FQDN : ${bldylw}${fqdn}";
    echo;
    info "‚Ä¢ Hostname will be set to: ${bldgrn}${host}";
    info "‚Ä¢ Domain will also change: ${bldgrn}${domain}";
    echo;
    lib::run::ask "Does that look correct to you?";
    echo;
    inf "Now, please provide your SUDO password, if asked: ";
    sudo printf '' || {
        not_ok:;
        exit 1
    };
    ok:;
    run "sudo scutil --set HostName ${fqdn}";
    run "sudo scutil --set LocalHostName ${host}.local 2>/dev/null|| true";
    run "sudo scutil --set ComputerName ${host}";
    run "dscacheutil -flushcache";
    echo;
    h2 "Result of the changes:";
    lib::osx::scutil-print HostName;
    lib::osx::scutil-print LocalHostName;
    lib::osx::scutil-print ComputerName;
    lib::osx::env-print HOSTNAME;
    echo;
    hr
}

```
### `lib::output::color::off`

```
lib::output::color::off ()
{
    reset-color: 1>&2;
    reset-color: 1>&1
}

```
### `lib::output::color::on`

```
lib::output::color::on ()
{
    printf "${bldred}" 1>&2;
    printf "${bldblu}" 1>&1
}

```
### `lib::output::is_pipe`

```
lib::output::is_pipe ()
{
    [[ -p /dev/stdout ]]
}

```
### `lib::output::is_redirect`

```
lib::output::is_redirect ()
{
    [[ ! -t 1 && ! -p /dev/stdout ]]
}

```
### `lib::output::is_ssh`

```
lib::output::is_ssh ()
{
    [[ -n "${SSH_CLIENT}" || -n "${SSH_CONNECTION}" ]]
}

```
### `lib::output::is_terminal`

```
lib::output::is_terminal ()
{
    lib::output::is_tty || lib::output::is_redirect || lib::output::is_pipe || lib::output::is_ssh
}

```
### `lib::output::is_tty`

```
lib::output::is_tty ()
{
    [[ -t 1 ]]
}

```
### `lib::progress::bar`

```
lib::progress::bar ()
{
    __lib::progress::reset;
    __lib::progress::bar "$@";
    code=$?;
    if [[ ${code} -ne 0 ]]; then
        __lib::progress::reset;
        return 1;
    fi;
    return 0
}

```
### `lib::psql::db-settings`

```
lib::psql::db-settings ()
{
    psql $* -X -q -c 'show all' | sort | awk '{ printf("%s=%s\n", $1, $3) }' | sed -E 's/[()\-]//g;/name=setting/d;/^[-+=]*$/d;/^[0-9]*=$/d'
}

```
### `lib::repo::rebase`

```
lib::repo::rebase ()
{
    run "git pull origin master --rebase"
}

```
### `lib::repo::stash-and-rebase`

```
lib::repo::stash-and-rebase ()
{
    run "git stash >/dev/null";
    run "git reset --hard";
    lib::repo::rebase
}

```
### `lib::repo::update`

```
lib::repo::update ()
{
    local folder="$1";
    h2 "Entering repo ‚ñ∫ ${bldgren}${folder}";
    [[ -d "${folder}" ]] || return 1;
    [[ -d "${folder}/.git" ]] || return 1;
    [[ "$(pwd)" != "${folder}" ]] && {
        cd "${folder}" || return 2
    };
    if [[ -z "$(git status -s)" ]]; then
        lib::repo::rebase;
    else
        lib::repo::stash-and-rebase;
    fi
}

```
### `lib::repos::catch-interrupt`

```
lib::repos::catch-interrupt ()
{
    export LibRepo__Interrupted=true
}

```
### `lib::repos::init-interrupt`

```
lib::repos::init-interrupt ()
{
    export LibRepo__Interrupted=false;
    trap 'lib::repos::catch-interrupt' SIGINT
}

```
### `lib::repos::recursive-update`

```
lib::repos::recursive-update ()
{
    local repo="${1}";
    run::set-all show-output-off;
    if [[ ${LibRepo__Interrupted} == true ]]; then
        warn "Detected SINGINT, exiting...";
        return 2;
    fi;
    if [[ -n "$repo" ]]; then
        lib::repo::update "$repo";
    else
        for dir in $(find . -type d -name '.git');
        do
            local subdir=$(dirname "$dir");
            [[ -n "${DEBUG}" ]] && info "checking out sub-folder ${bldcyn}${subdir}...";
            lib::repos::recursive-update "${subdir}";
            if [[ $? -eq 2 ]]; then
                error "folder ${bldylw}${subdir}${bldred} return error!";
                return 2;
            fi;
        done;
    fi;
    if [[ -n ${repo} ]]; then
        info "returning to the root dir ${bldylw}${root_folder}...";
        cd "${root_folder}" > /dev/null || return 2;
    fi
}

```
### `lib::repos::was-interrupted`

```
lib::repos::was-interrupted ()
{
    [[ ${LibRepo__Interrupted} == true ]]
}

```
### `lib::ruby::bundler-version`

```
lib::ruby::bundler-version ()
{
    if [[ ! -f Gemfile.lock ]]; then
        error "Can not find Gemfile.lock";
        return 1;
    fi;
    tail -1 Gemfile.lock | hbsed 's/ //g'
}

```
### `lib::ruby::gemfile-lock-version`

```
lib::ruby::gemfile-lock-version ()
{
    local gem=${1};
    if [[ ! -f Gemfile.lock ]]; then
        error "Can not find Gemfile.lock";
        return 1;
    fi;
    egrep " ${gem} \([0-9]" Gemfile.lock | sed -e 's/[\(\)]//g' | awk '{print $2}'
}

```
### `lib::ruby::install-ruby`

```
lib::ruby::install-ruby ()
{
    local version="$1";
    local version_source="provided as an argument";
    if [[ -z ${version} && -f .ruby-version ]]; then
        version="$(cat .ruby-version | tr -d '\n')";
        version_source="auto-detected from .ruby-version file";
    fi;
    [[ -z ${version} ]] && {
        error "usage: ${BASH_SOURCE[*]} ruby-version" "Alternatively, create .ruby-version file";
        return 1
    };
    hl::subtle "Installing Ruby Version ${version} ${version_source}.";
    lib::ruby::validate-version "${version}" || return 1;
    lib::brew::install::packages rbenv ruby-build jemalloc;
    eval "$(rbenv init -)";
    run "RUBY_CONFIGURE_OPTS=--with-jemalloc rbenv install -s ${version}";
    return "${LibRun__LastExitCode:-"0"}"
}

```
### `lib::ruby::install-ruby-with-deps`

```
lib::ruby::install-ruby-with-deps ()
{
    local version="$1";
    declare -a packages=(cask bash bash-completion git go haproxy htop jemalloc libxslt jq libiconv libzip netcat nginx openssl pcre pstree p7zip rbenv redis ruby_build tree vim watch wget zlib);
    run::set-next show-output-on;
    run "brew install --display-times ${packages[*]}"
}

```
### `lib::ruby::validate-version`

```
lib::ruby::validate-version ()
{
    local version="$1";
    local -a ruby_versions=();
    run "brew upgrade ruby-build || true";
    [[ -d ~/.rbenv/plugins/ruby-build ]] && {
        run "cd ~/.rbenv/plugins/ruby-build && git reset --hard && git pull --rebase"
    };
    lib::array::from-command-output ruby_versions 'rbenv install --list | sed -E "s/\s+//g"';
    lib::array::contains-element "${version}" "${ruby_versions[@]}" || {
        error "Ruby Version provided was found by rbenv: ${bldylw}${version}";
        return 1
    };
    return 0
}

```
### `lib::run`

```
lib::run ()
{
    __lib::run "$@";
    return ${LibRun__LastExitCode}
}

```
### `lib::run::ask`

```
lib::run::ask ()
{
    local question=$*;
    echo;
    inf "${bldcyn}${question}${clr} [Y/n] ${bldylw}";
    read a 2> /dev/null;
    code=$?;
    if [[ ${code} != 0 ]]; then
        error "Unable to read from STDIN.";
        exit 12;
    fi;
    echo;
    if [[ ${a} == 'y' || ${a} == 'Y' || ${a} == '' ]]; then
        info "${bldblu}Roger that.";
        info "Let's just hope it won't go nuclear on us :) üí•";
        hr;
        echo;
    else
        info "${bldred}(Great idea!) Abort! Abandon ship!  üõ≥  ";
        hr;
        echo;
        exit 1;
    fi
}

```
### `lib::run::inspect`

```
lib::run::inspect ()
{
    if [[ ${#@} -eq 0 || $(array-contains-element "config" "$@") == "true" ]]; then
        lib::run::inspect-variables-that-are starting-with LibRun;
    fi;
    if [[ ${#@} -eq 0 || $(array-contains-element "totals" "$@") == "true" ]]; then
        hl::subtle "TOTALS";
        info "${bldgrn}${commands_completed} commands completed successfully";
        [[ ${commands_failed} -gt 0 ]] && info "${bldred}${commands_failed} commands failed";
        [[ ${commands_ignored} -gt 0 ]] && info "${bldylw}${commands_ignored} commands failed, but were ignored.";
        echo;
    fi;
    if [[ ${#@} -eq 0 || $(array-contains-element "current" "$@") == "true" ]]; then
        lib::run::inspect-variables-that-are ending-with __LastExitCode;
    fi;
    reset-color
}

```
### `lib::run::inspect-variable`

```
lib::run::inspect-variable ()
{
    local var_name=${1};
    local var_value=${!var_name};
    local value="";
    local print_value=;
    local max_len=120;
    local avail_len=$(($(screen.width) - 45));
    local lcase_var_name="$(echo ${var_name} | tr 'A-Z' 'a-z')";
    local print_value=1;
    local color="${bldblu}";
    local value_off=" ‚úò   ";
    local value_check="‚úîÔ∏é";
    if [[ -n "${var_value}" ]]; then
        if [[ ${lcase_var_name} =~ 'exit' ]]; then
            if [[ ${var_value} -eq 0 ]]; then
                value=${value_check};
                color="${bldgrn}";
            else
                print_value=1;
                value=${var_value};
                color="${bldred}";
            fi;
        else
            if [[ "${var_value}" == "${True}" ]]; then
                value="${value_check}";
                color="${bldgrn}";
            else
                if [[ "${var_value}" == "${False}" ]]; then
                    value="${value_off}";
                    color="${bldred}";
                fi;
            fi;
        fi;
    else
        value="${value_off}";
        color="${bldred}";
    fi;
    if [[ ${LibRun__Inspect__SkipFalseOrBlank} -eq ${True} && "${value}" == "${value_off}" ]]; then
        return 0;
    fi;
    printf "    ${bldylw}%-35s ${txtblk}${color} " ${var_name};
    [[ ${avail_len} -gt ${max_len} ]] && avail_len=${max_len};
    if [[ "${print_value}" -eq 1 ]]; then
        if [[ -n "${value}" ]]; then
            printf "%*.*s" ${avail_len} ${avail_len} "${value}";
        else
            if $(lib::util::is-numeric "${var_value}"); then
                avail_len=$((${avail_len} - 5));
                if [[ "${var_value}" =~ '.' ]]; then
                    printf "%*.2f" ${avail_len} "${var_value}";
                else
                    printf "%*d" ${avail_len} "${var_value}";
                fi;
            else
                avail_len=$((${avail_len} - 5));
                printf "%*.*s" ${avail_len} ${avail_len} "${var_value}";
            fi;
        fi;
    else
        printf "%*.*s" ${avail_len} ${avail_len} "${value}";
    fi;
    echo
}

```
### `lib::run::inspect-variables`

```
lib::run::inspect-variables ()
{
    local title=${1};
    shift;
    hl::subtle "${title}";
    for var in $@;
    do
        lib::run::inspect-variable "${var}";
    done
}

```
### `lib::run::inspect-variables-that-are`

```
lib::run::inspect-variables-that-are ()
{
    local pattern_type="${1}";
    local pattern="${2}";
    lib::run::inspect-variables "VARIABLES $(echo ${pattern_type} | tr 'a-z' 'A-Z') ${pattern}" "$(lib::run::variables-${pattern_type} ${pattern} | tr '\n' ' ')"
}

```
### `lib::run::inspect::set-skip-false-or-blank`

```
lib::run::inspect::set-skip-false-or-blank ()
{
    local value="${1}";
    [[ -n "${value}" ]] && export LibRun__Inspect__SkipFalseOrBlank=${value};
    [[ -z "${value}" ]] && export LibRun__Inspect__SkipFalseOrBlank=${True}
}

```
### `lib::run::print-variable`

```
lib::run::print-variable ()
{
    lib::run::inspect-variable $1
}

```
### `lib::run::print-variables`

```
lib::run::print-variables ()
{
    local title=${1};
    shift;
    hl::yellow "${title}";
    for var in $@;
    do
        lib::run::print-variable "${var}";
    done
}

```
### `lib::run::variables-ending-with`

```
lib::run::variables-ending-with ()
{
    local suffix="${1}";
    env | egrep ".*${suffix}=.*\$" | grep '=' | hbsed 's/=.*//g' | sort
}

```
### `lib::run::variables-starting-with`

```
lib::run::variables-starting-with ()
{
    local prefix="${1}";
    env | egrep "^${prefix}" | grep '=' | hbsed 's/=.*//g' | sort
}

```
### `lib::run::with-min-duration`

```
lib::run::with-min-duration ()
{
    local min_duration=$1;
    shift;
    local command="$*";
    local started=$(millis);
    info "starting a command with the minimum duration of ${bldylw}${min_duration} seconds";
    run "${command}";
    local result=$?;
    local duration=$((($(millis) - ${started}) / 1000));
    if [[ ${result} -eq 0 && ${duration} -lt ${min_duration} ]]; then
        local cmd="$(echo ${command} | hbsed 's/\"//g')";
        error "An operation finished too quickly. The threshold was set to ${bldylw}${min_duration} sec." "The command took ${bldylw}${duration}${txtred} secs." "${bldylw}${cmd}${txtred}";
        ((${BASH_IN_SUBSHELL})) && exit 1 || return 1;
    else
        if [[ ${duration} -gt ${min_duration} ]]; then
            info "minimum duration operation ran in ${duration} seconds.";
        fi;
    fi;
    return ${result}
}

```
### `lib::ssh::load-keys`

```
lib::ssh::load-keys ()
{
    local pattern="$1";
    find ${HOME}/.ssh -type f -name "id_*${pattern}*" -and -not -name '*.pub' -print -exec ssh-add {} \;
}

```
### `lib::time::date-from-epoch`

```
lib::time::date-from-epoch ()
{
    local epoch_ts="$1";
    if [[ "${AppCurrentOS}" == "Darwin" ]]; then
        printf "date -r ${epoch_ts}";
    else
        printf "date --date='@${epoch_ts}'";
    fi
}

```
### `lib::time::duration::humanize`

```
lib::time::duration::humanize ()
{
    local seconds=${1};
    local hours=$((${seconds} / 3600));
    local remainder=$((${seconds} - ${hours} * 3600));
    local mins=$((${remainder} / 60));
    local secs=$((${seconds} - ${hours} * 3600 - ${mins} * 60));
    local prefixed=0;
    [[ ${hours} -gt 0 ]] && {
        printf "%02dh:" ${hours};
        prefixed=1
    };
    [[ ${mins} -gt 0 || ${prefixed} == 1 ]] && {
        printf "%02dm:" ${mins};
        prefixed=1
    };
    {
        printf "%02ds" ${secs}
    }
}

```
### `lib::time::duration::millis-to-secs`

```
lib::time::duration::millis-to-secs ()
{
    local duration="$1";
    local format="${2:-"%d.%d"}";
    local seconds=$(( duration / 1000 ));
    local leftover=$(( duration - 1000 * seconds ));
    printf "${format}" ${seconds} ${leftover}
}

```
### `lib::time::epoch-to-iso`

```
lib::time::epoch-to-iso ()
{
    local epoch_ts=$1;
    eval "$(lib::time::date-from-epoch ${epoch_ts}) -u \"+%Y-%m-%dT%H:%M:%S%z\"" | sed 's/0000/00:00/g'
}

```
### `lib::time::epoch-to-local`

```
lib::time::epoch-to-local ()
{
    local epoch_ts=$1;
    [[ -z ${epoch_ts} ]] && epoch_ts=$(epoch);
    eval "$(lib::time::date-from-epoch ${epoch_ts}) \"+%m/%d/%Y, %r\""
}

```
### `lib::time::epoch::minutes-ago`

```
lib::time::epoch::minutes-ago ()
{
    local mins=${1};
    [[ -z ${mins} ]] && mins=1;
    local seconds=$((${mins} * 60));
    local epoch=$(epoch);
    echo $((${epoch} - ${seconds}))
}

```
### `lib::trap-setup`

```
lib::trap-setup ()
{
    __lib::trap-remove;
    local signal="${1:-"SIGINT"}";
    trap '__lib::trap-catch' "${signal}";
    export __int_signal__="${signal}"
}

```
### `lib::trap-was-fired`

```
lib::trap-was-fired ()
{
    if [[ -f ${__int_marker__} ]]; then
        rm -f "${__int_marker__}";
        return 0;
    fi;
    return 1
}

```
### `lib::trapped`

```
lib::trapped ()
{
    if [[ ${__int_flag__} -eq 1 ]]; then
        unset __int__flag__;
        return 0;
    fi;
    return 1
}

```
### `lib::url::downloader`

```
lib::url::downloader ()
{
    local downloader=;
    if [[ -z "${LibUrl__Downloader}" ]]; then
        [[ -z "${downloader}" && -n $(which curl) ]] && downloader="$(which curl) ${LibUrl__CurlDownloaderFlags}";
        [[ -z "${downloader}" && -n $(which wget) ]] && downloader="$(which wget) ${LibUrl__WgetDownloaderFlags}";
        [[ -z "${downloader}" ]] && {
            error "Neither Curl nor WGet appear in the \$PATH... HALP?";
            return 1
        };
        export LibUrl__Downloader="${downloader}";
    fi;
    printf "${LibUrl__Downloader}"
}

```
### `lib::url::http-code`

```
lib::url::http-code ()
{
    local url="$1";
    local quiet="${2:-false}";
    [[ -z $(which wget) ]] && {
        echo 1>&2;
        err "This function currently only supports ${bldylw}wget.\n" 1>&2;
        echo 1>&2;
        return 100
    };
    lib::url::is-valid "$url" || {
        echo 1>&2;
        err "The URL provided is not a valid URL: ${bldylw}${url}\n" 1>&2;
        echo 1>&2;
        return 101
    };
    local result=$(wget -v --spider "${url}" 2>&1 | egrep "response" | awk '{print $6}' | tr -d ' ' | tail -1);
    export LibUrl__LastHttpCode="${result}";
    if [[ ${quiet} == true ]]; then
        if [[ ${result} -gt 199 && ${result} -lt 210 ]]; then
            return 0;
        else
            return 1;
        fi;
    else
        [[ -n "${result}" ]] && printf ${result} || printf "404";
    fi
}

```
### `lib::url::is-valid`

```
lib::url::is-valid ()
{
    local url="$1";
    if [[ $(lib::url::valid-status "$url") = "ok" ]]; then
        return 0;
    else
        return 1;
    fi
}

```
### `lib::url::shorten`

```
lib::url::shorten ()
{
    local longUrl="$1";
    if [[ -z "${BITLY_LOGIN}" || -z "${BITLY_API_KEY}" ]]; then
        printf "${longUrl}";
    else
        export BITLY_LOGIN=$(printf '%s' "${BITLY_LOGIN}" | tr -d '\r' | tr -d '\n');
        export BITLY_API_KEY=$(printf '%s' "${BITLY_API_KEY}" | tr -d '\r' | tr -d '\n');
        if [[ -n $(which ruby) ]]; then
            longUrl=$(ruby -e "require 'uri'; str = '${longUrl}'.force_encoding('ASCII-8BIT'); puts URI::encode(str)");
        fi;
        bitlyUrl="http://api.bit.ly/v3/shorten?login=${BITLY_LOGIN}&apiKey=${BITLY_API_KEY}&format=txt&longURL=${longUrl}";
        $(lib::url::downloader) "${bitlyUrl}" | tr -d '\n' | tr -d ' ';
    fi
}

```
### `lib::url::valid-status`

```
lib::url::valid-status ()
{
    local url="$1";
    echo "${url}" | ruby -ne '
    require "uri"
    u = URI::parse("#{$_}".chomp)
    if u && u.host && u.host&.include?(".") && u&.scheme =~ /^http/
      print "ok"
    else
      print "invalid"
    end'
}

```
### `lib::user`

```
lib::user ()
{
    local user;
    user=$(lib::user::finger::name);
    [[ -z "${user}" ]] && user="$(lib::user::gitconfig::name)";
    [[ -z "${user}" ]] && user="$(lib::user::gitconfig::email)";
    [[ -z "${user}" ]] && user="$(lib::user::username)";
    echo "${user}"
}

```
### `lib::user::finger::name`

```
lib::user::finger::name ()
{
    [[ -n $(which finge) ]] && finger ${USER} | head -1 | hbsed 's/.*Name: //g'
}

```
### `lib::user::first`

```
lib::user::first ()
{
    lib::user | tr '\n' ' ' | ruby -ne 'puts $_.split(/ /).first.capitalize'
}

```
### `lib::user::gitconfig::email`

```
lib::user::gitconfig::email ()
{
    if [[ -s ${HOME}/.gitconfig ]]; then
        grep email ${HOME}/.gitconfig | hbsed 's/.*=\s?//g';
    fi
}

```
### `lib::user::gitconfig::name`

```
lib::user::gitconfig::name ()
{
    if [[ -s ${HOME}/.gitconfig ]]; then
        grep name ${HOME}/.gitconfig | hbsed 's/.*=\s?//g';
    fi
}

```
### `lib::user::host`

```
lib::user::host ()
{
    local host=;
    host=$(lib::user::my::reverse-ip);
    [[ -z ${host} ]] && host=$(lib::user::my::ip);
    printf "${host}"
}

```
### `lib::user::my::ip`

```
lib::user::my::ip ()
{
    dig +short myip.opendns.com @resolver1.opendns.com
}

```
### `lib::user::my::reverse-ip`

```
lib::user::my::reverse-ip ()
{
    nslookup $(lib::user::my::ip) | grep 'name =' | hbsed 's/.*name = //g'
}

```
### `lib::user::username`

```
lib::user::username ()
{
    echo ${USER:-$(whoami)}
}

```
### `lib::util::append-to-init-files`

```
lib::util::append-to-init-files ()
{
    local string="$1";
    local search="${2:-$1}";
    is_installed=;
    declare -a shell_files=($(lib::util::shell-init-files));
    for init_file in ${shell_files[@]};
    do
        file=${HOME}/${init_file};
        [[ -f ${file} && -n $(grep "${search}" ${file}) ]] && {
            is_installed=${file};
            break
        };
    done;
    if [[ -z "${is_installed}" ]]; then
        for init_file in ${shell_files[@]};
        do
            file=${HOME}/${init_file};
            [[ -f ${file} ]] && {
                echo "${string}" >> ${file};
                is_installed="${file}";
                break
            };
        done;
    fi;
    printf "${is_installed}"
}

```
### `lib::util::arch`

```
lib::util::arch ()
{
    echo -n "${AppCurrentOS}-$(uname -m)-$(uname -p)" | tr 'A-Z' 'a-z'
}

```
### `lib::util::call-if-function`

```
lib::util::call-if-function ()
{
    local func="$1";
    shift;
    lib::util::is-a-function "${func}" && {
        ${func} "$@"
    }
}

```
### `lib::util::checksum::files`

```
lib::util::checksum::files ()
{
    cat $* | shasum | awk '{print $1}'
}

```
### `lib::util::checksum::stdin`

```
lib::util::checksum::stdin ()
{
    shasum | awk '{print $1}'
}

```
### `lib::util::functions-matching`

```
lib::util::functions-matching ()
{
    local prefix=${1};
    local extra_command=${2:-"cat"};
    set | egrep "^${prefix}" | sed -E 's/.*:://g; s/[\(\)]//g;' | ${extra_command} | tr '\n ' ' '
}

```
### `lib::util::generate-password`

```
lib::util::generate-password ()
{
    local len=${1:-32};
    local val=$(($(date '+%s') - 100000 * $RANDOM));
    [[ ${val:0:1} == "-" ]] && val=${val/-//};
    printf "$(echo ${val} | shasum -a 512 | awk '{print $1}' | base64 | head -c ${len})"
}

```
### `lib::util::i-to-ver`

```
lib::util::i-to-ver ()
{
    version=${1};
    /usr/bin/env ruby -e "ver='${version}'; printf %Q{%d.%d.%d}, ver[1..2].to_i, ver[3..5].to_i, ver[6..8].to_i"
}

```
### `lib::util::install-direnv`

```
lib::util::install-direnv ()
{
    [[ -n $(which direnv) ]] || lib::brew::install::package direnv;
    local init_file=;
    local init_file=$(lib::util::append-to-init-files 'eval "$(direnv hook bash)"; export DIRENV_LOG_FORMAT=' 'direnv hook');
    if [[ -f ${init_file} ]]; then
        info: "direnv init has been appended to ${bldylw}${init_file}...";
    else
        error: "direnv init could not be appended";
    fi;
    eval "$(direnv hook bash)"
}

```
### `lib::util::is-a-function`

```
lib::util::is-a-function ()
{
    type "$1" 2> /dev/null | head -1 | grep -q 'is a function'
}

```
### `lib::util::is-numeric`

```
lib::util::is-numeric ()
{
    [[ -z $(echo ${1} | sed -E 's/^[0-9]+$//g') ]]
}

```
### `lib::util::is-variable-defined`

```
lib::util::is-variable-defined ()
{
    local var_name="$1";
    [[ -n ${!var_name+x} ]]
}

```
### `lib::util::lines-in-folder`

```
lib::util::lines-in-folder ()
{
    local folder=${1:-'.'};
    find ${folder} -type f -exec wc -l {} \; | awk 'BEGIN{a=0}{a+=$1}END{print a}'
}

```
### `lib::util::remove-from-init-files`

```
lib::util::remove-from-init-files ()
{
    local search="${1}";
    local backup_extension="${2}";
    [[ -z ${backup_extension} ]] && backup_extension="$(epoch).backup";
    [[ -z ${search} ]] && return;
    declare -a shell_files=($(lib::util::shell-init-files));
    local temp_holder=$(mktemp);
    for init_file in ${shell_files[@]};
    do
        is_detail && inf "verifying file ${init_file}...";
        file=${HOME}/${init_file};
        if [[ -f ${file} && -n $(grep "${search}" ${file}) ]]; then
            is_detail && ok:;
            local matches=$(grep -c "${search}" ${file});
            is_detail && info "file ${init_file} matches with ${bldylw}${matches} matches";
            run "grep -v \"${search}\" ${file} > ${temp_holder}";
            if [[ -n "${backup_extension}" ]]; then
                local backup="${file}.${backup_extension}";
                is_detail && info "backup file will created in ${bldylw}${backup}";
                [[ -n "${do_backup_changes}" ]] && "mv ${file} ${backup}";
            fi;
            run "cp -v ${temp_holder} ${file}";
        else
            is_detail && not_ok:;
        fi;
    done;
    return ${LibRun__LastExitCode}
}

```
### `lib::util::shell-init-files`

```
lib::util::shell-init-files ()
{
    shell_name=$(lib::util::shell-name);
    if [[ ${shell_name} == "bash" ]]; then
        echo ".bash_${USER} .bash_profile .bashrc .profile";
    else
        if [[ ${shell_name} == "zsh" ]]; then
            echo ".zsh_${USER} .zshrc .profile";
        fi;
    fi
}

```
### `lib::util::shell-name`

```
lib::util::shell-name ()
{
    echo $(basename $(printf $SHELL))
}

```
### `lib::util::ver-to-i`

```
lib::util::ver-to-i ()
{
    version=${1};
    echo ${version} | awk 'BEGIN{FS="."}{ printf "1%02d%03.3d%03.3d", $1, $2, $3}'
}

```
### `lib::util::whats-installed`

```
lib::util::whats-installed ()
{
    declare -a hb_aliases=($(alias | grep -E 'hb\..*=' | hbsed 's/alias//g; s/=.*$//g'));
    h2 "Installed app aliases:" ' ' "${hb_aliases[@]}";
    h2 "Installed DB Functions:";
    info "hb.db  [ ms | r1 | r2 | c ]";
    info "hb.ssh <server-name-substring>, eg hb.ssh web"
}

```
### `lib::vim::gvim-off`

```
lib::vim::gvim-off ()
{
    lib::vim::setup;
    [[ "${EDITOR}" == "vim" ]] && return 0;
    local regex_from='^export EDITOR=.*$';
    local regex_to='export EDITOR=vim';
    lib::file::gsub "${LibVim__initFile}" "${regex_from}" "${regex_to}";
    lib::file::gsub "${LibVim__initFile}" '^gvim.on$' 'gvim.off';
    egrep -q "${regex_from}" ${LibVim__initFile} || echo "${regex_to}" >> ${LibVim__initFile};
    egrep -q "^gvim\.o" ${LibVim__initFile} || echo "gvim.off" >> ${LibVim__initFile};
    eval "
    [[ -n '${DEBUG}' ]] && set -x
    export EDITOR=${LibVim__editorGvimOff}
    unalias ${LibVim__editorVi} 2>/dev/null
    unalias ${LibVim__editorGvimOff} 2>/dev/null
  "
}

```
### `lib::vim::gvim-on`

```
lib::vim::gvim-on ()
{
    lib::vim::setup;
    [[ "${EDITOR}" == "gvim" ]] && return 0;
    local regex_from='^export EDITOR=.*$';
    local regex_to='export EDITOR=gvim';
    lib::file::gsub "${LibVim__initFile}" "${regex_from}" "${regex_to}";
    lib::file::gsub "${LibVim__initFile}" '^gvim.off$' 'gvim.on';
    egrep -q "${regex_from}" ${LibVim__initFile} || echo "${regex_to}" >> ${LibVim__initFile};
    egrep -q "^gvim\.o.*" ${LibVim__initFile} || echo "gvim.on" >> ${LibVim__initFile};
    eval "
    [[ -n '${DEBUG}' ]] && set -x
    export EDITOR=${LibVim__editorGvimOn}
    alias ${LibVim__editorVi}=${LibVim__editorGvimOn}
    alias ${LibVim__editorGvimOff}=${LibVim__editorGvimOn}
  "
}

```
### `lib::vim::setup`

```
lib::vim::setup ()
{
    export LibVim__initFile="${HOME}/.bash_profile";
    export LibVim__editorVi="vi";
    export LibVim__editorGvimOn="gvim";
    export LibVim__editorGvimOff="vim"
}

```
### `lib::yaml::diff`

```
lib::yaml::diff ()
{
    local f1="$1";
    shift;
    local f2="$1";
    shift;
    [[ -f "$f1" && -f "$f2" ]] || {
        h2 "USAGE: ${bldylw}yaml-diff file1.yml file2.yml [ ydiff-options ]";
        return 1
    };
    [[ -n $(which ${BashMatic__DiffTool}) ]] || lib::brew::package::install ${BashMatic__DiffTool};
    local t1="/tmp/${RANDOM}.$(basename ${f1}).$$.yml";
    local t2="/tmp/${RANDOM}.$(basename ${f2}).$$.yml";
    lib::yaml::expand-aliases "$f1" > "$t1";
    lib::yaml::expand-aliases "$f2" > "$t2";
    run::set-next show-output-on;
    hr;
    run "ydiff $* ${t1} ${t2}";
    hr;
    run "rm -rf ${t1} ${t2}"
}

```
### `lib::yaml::dump`

```
lib::yaml::dump ()
{
    local f1="$1";
    shift;
    [[ -f "$f1" ]] || {
        h2 "USAGE: ${bldylw}yaml-dump file.yml";
        return 1
    };
    [[ -n $(which ${BashMatic__DiffTool}) ]] || lib::brew::package::install ${BashMatic__DiffTool};
    local t1="/tmp/${RANDOM}.$(basename ${f1}).$$.yml";
    lib::yaml::expand-aliases "$f1" > "$t1";
    vim "$t1";
    run "rm -rf ${t1}"
}

```
### `lib::yaml::expand-aliases`

```
lib::yaml::expand-aliases ()
{
    ruby -e "require 'yaml'; require 'json'; puts YAML.dump(JSON.parse(JSON.pretty_generate(YAML.load(File.read('${1}')))))"
}

```
### `long-pause`

```
long-pause ()
{
    sleep "${1:-10}"
}

```
### `millis`

```
millis ()
{
    __lib::run::millis
}

```
### `not_ok`

```
not_ok ()
{
    __lib::output::cursor-left-by 1000;
    printf " ${bakred}${bldwht} ‚úò ${clr} "
}

```
### `not_ok:`

```
not_ok: ()
{
    not_ok $@;
    echo
}

```
### `odie`

```
odie ()
{
    onoe "$@";
    exit 1
}

```
### `ok`

```
ok ()
{
    __lib::output::cursor-left-by 1000;
    printf " ${txtblk}${bakgrn} ‚úîÔ∏é ${clr} "
}

```
### `ok:`

```
ok: ()
{
    ok $@;
    echo
}

```
### `okay`

```
okay ()
{
    printf -- " ${bldgrn} ‚úì ALL OK üëç  $*${clr}" 1>&2;
    echo
}

```
### `onoe`

```
onoe ()
{
    if [[ -t 2 ]]; then
        echo -ne "\033[4;31mError\033[0m: " 1>&2;
    else
        echo -n "Error: " 1>&2;
    fi;
    if [[ $# -eq 0 ]]; then
        /bin/cat 1>&2;
    else
        echo "$*" 1>&2;
    fi
}

```
### `pall`

```
pall ()
{
    pids::all "$@"
}

```
### `pause`

```
pause ()
{
    sleep "${1:-1}"
}

```
### `pid::alive`

```
pid::alive ()
{
    local pid="$1";
    lib::util::is-numeric || {
        error "First argument to pid::alive must be numeric.";
        return 1
    };
    [[ -n "${pid}" && -n $(ps -p "${pid}" | grep -v TTY) ]]
}

```
### `pid::sig`

```
pid::sig ()
{
    local pid="${1}";
    shift;
    local signal="${1}";
    shift;
    [[ -z "${pid}" || -z "${signal}" ]] && {
        printf "
USAGE:
  pid::sig pid signal
";
        return 1
    };
    lib::util::is-numeric ${pid} || {
        error "First argument to pid::sig must be numeric.";
        return 1
    };
    lib::util::is-numeric ${signal} || sig::is-valid ${signal} || {
        error "First argument to pid::sig must be numeric.";
        return 1
    };
    if pid::alive ${pid}; then
        info "sending ${bldred}${signal}$(txt-info) to ${bldylw}${pid}...";
        /bin/kill -s ${signal} ${pid} 2>&1 | cat > /dev/null;
    else
        warning "pid ${pid} was dead by the time we tried sending ${sig} to it.";
        return 1;
    fi
}

```
### `pid::stop`

```
pid::stop ()
{
    local pid=${1};
    shift;
    local delay=${1:-"0.3"};
    shift;
    if [[ -z ${pid} ]]; then
        printf "
DESCRIPTION:
  If the given PID is active, first sends kill -TERM, waits a bit,
  then sends kill -9.

USAGE:
  ${bldgrn}pid::stop pid${clr}

EXAMPLES:
  # stop all sidekiqs, waiting half a sec in between
  ${bldgrn}pid::stop sidekiq 0.5${clr}
";
        return 1;
    fi;
    pid::alive "${pid}" && ( pid::sig "${pid}" "TERM" || true ) && sleep ${delay};
    pid::alive "${pid}" && pid::sig "${pid}" "KILL"
}

```
### `pids-with-args`

```
pids-with-args ()
{
    local -a permitted=("%cpu" "%mem" acflag acflg args blocked caught comm command cpu cputime etime f flags gid group ignored inblk inblock jobc ktrace ktracep lim login logname lstart majflt minflt msgrcv msgsnd ni nice nivcsw nsignals nsigs nswap nvcsw nwchan oublk oublock p_ru paddr pagein pcpu pending pgid pid pmem ppid pri pstime putime re rgid rgroup rss ruid ruser sess sig sigmask sl start stat state stime svgid svuid tdev time tpgid tsess tsiz tt tty ucomm uid upr user usrpri utime vsize vsz wchan wq wqb wql wqr xstat);
    local -a additional=();
    local -a matching=();
    for arg in $@;
    do
        lib::array::contains-element "${arg}" "${permitted[@]}" && additional=(${additional[@]} $arg) && continue;
        matching=("${matching[@]}" "${arg}");
    done;
    local columns="pid,ppid,user,%cpu,%mem,command";
    if [[ ${#additional[@]} -gt 0 ]]; then
        columns="${columns},$(lib::array::join ',' "${additional[@]}")";
    fi;
    pids::matching::regexp "${matching[*]}" | xargs /bin/ps -www -o"${columns}" -p
}

```
### `pids::all`

```
pids::all ()
{
    if [[ -z "${1}" ]]; then
        printf "
DESCRIPTION:
  prints processes matching a given pattern

USAGE:
  ${bldgrn}pids::all pattern${clr}

EXAMPLES:
  ${bldgrn}pids::all puma${clr}
";
        return 0;
    fi;
    local pattern="$(pids::normalize::search-string "$1")";
    shift;
    ps -ef | egrep "${pattern}" | egrep -v grep
}

```
### `pids::for-each`

```
pids::for-each ()
{
    if [[ -z "${1}" || -z "${2}" ]]; then
        printf "
DESCRIPTION:
  loops over matching PIDs and calls a named BASH function

USAGE:
  ${bldgrn}pids::for-each pattern function${clr}

EXAMPLES:
  ${bldgrn}pids::for-each puma echo
  function hup() { kill -HUP \$1; }; pids::for-each sidekiq hup${clr}
";
        return 0;
    fi;
    local pattern="$(pids::normalize::search-string "$1")";
    shift;
    local func=${1:-"echo"};
    if [[ -z $(which ${func}) && -z $(type ${func} 2>/dev/null) ]]; then
        errror "Function ${func} does not exist.";
        return 1;
    fi;
    while true; do
        local -a pids=($(pids::matching "${pattern}"));
        [[ ${#pids[@]} == 0 ]] && break;
        eval "${func} ${pids[0]}";
        sleep 0.1;
    done
}

```
### `pids::matching`

```
pids::matching ()
{
    local pattern="${1}";
    if [[ -z "${pattern}" ]]; then
        printf "
DESCRIPTION:
  Finds process IDs matching a given string.

USAGE:
  ${bldgrn}pids::matching string${clr}

EXAMPLES:
  ${bldgrn}pids::matching sidekiq${clr}
";
        return 0;
    fi;
    pattern="$(pids::normalize::search-string ${pattern})";
    pids::matching::regexp "${pattern}"
}

```
### `pids::matching::regexp`

```
pids::matching::regexp ()
{
    local pattern="${1}";
    if [[ -z "${pattern}" ]]; then
        printf "
DESCRIPTION:
  Finds process IDs matching a given regexp.

USAGE:
  ${bldgrn}pids::matching regular-expression${clr}

EXAMPLES:
  ${bldgrn}pids::matching '[s]idekiq\s+' ${clr}
";
        return 0;
    fi;
    ps -ef | egrep "${pattern}" | egrep -v grep | awk '{print $2}' | sort -n
}

```
### `pids::normalize::search-string`

```
pids::normalize::search-string ()
{
    local pattern="$*";
    [[ "${pattern:0:1}" == '[' ]] || pattern="[${pattern:0:1}]${pattern:1}";
    printf "${pattern}"
}

```
### `pids::stop`

```
pids::stop ()
{
    if [[ -z "${1}" ]]; then
        printf "
DESCRIPTION:
  finds and stops IDs matching a given pattern

USAGE:
  ${bldgrn}pids::stop <pattern>${clr}

EXAMPLES:
  ${bldgrn}pids::stop puma${clr}
";
        return 0;
    fi;
    pids::for-each "${1}" "pid::stop"
}

```
### `press-any-key-to-continue`

```
press-any-key-to-continue ()
{
    local prompt="$*";
    [[ -z ${prompt} ]] && prompt="Press any key to continue...";
    br;
    printf "    ${txtgrn}${italic}${prompt} ${clr}  ";
    read -r -s -n1 key;
    cursor.rewind;
    printf "                                                           ";
    cursor.up 2;
    cursor.rewind;
    echo
}

```
### `pstop`

```
pstop ()
{
    pids::stop "$@"
}

```
### `puts`

```
puts ()
{
    printf "  ‚á® ${txtwht}$*${clr}"
}

```
### `red`

```
red ()
{
    ansi 31 "$@"
}

```
### `repos.update`

```
repos.update ()
{
    export root_folder="$(pwd)";
    bash -c "
    [[ -d ~/.bashmatic ]] || {
      echo 'Can not find bashmatic installation sorry'
      return
    }
    source ~/.bashmatic/init.sh
    lib::repos::init-interrupt
    lib::repos::recursive-update '$*'
  "
}

```
### `reset-color`

```
reset-color ()
{
    printf "${clr}\n"
}

```
### `reset-color:`

```
reset-color: ()
{
    printf "${clr}"
}

```
### `ruby.compiled-with`

```
ruby.compiled-with ()
{
    if [[ -z "$*" ]]; then
        error "usage: ruby.compiled-with <library>";
        return 1;
    fi;
    ruby -r rbconfig -e "puts RbConfig::CONFIG['LIBS']" | grep -q "$*"
}

```
### `ruby.default-gems`

```
ruby.default-gems ()
{
    declare -a DEFAULT_RUBY_GEMS=(rubocop relaxed-rubocop rubocop-performance warp-dir colored2 sym pg pry pry-doc pry-byebug rspec rspec-its awesome_print activesupport pivotal_git_scripts git-smart travis awscli irbtools);
    export DEFAULT_RUBY_GEMS;
    printf "${DEFAULT_RUBY_GEMS[*]}"
}

```
### `ruby.full-version`

```
ruby.full-version ()
{
    /usr/bin/env ruby --version
}

```
### `ruby.gems`

```
ruby.gems ()
{
    ruby.gems.install "$@"
}

```
### `ruby.gems.install`

```
ruby.gems.install ()
{
    local -a gems=($@);
    gem.clear-cache;
    [[ ${#gems[@]} -eq 0 ]] && gems=($(ruby.default-gems));
    local -a existing=($(ruby.installed-gems));
    [[ ${#gems[@]} -eq 0 ]] && {
        error 'Unable to determine what gems to install. ' "Argument is empty, so is ${DEFAULT_RUBY_GEMS[@]}" "USAGE: ${bldgrn}ruby.gems ${bldred} rails rubocop puma pry";
        return 1
    };
    h2 "There are a total of ${#existing[@]} of globally installed Gems." "Total of ${#gems[@]} need to be installed unless they already exist. " "${bldylw}Checking for gems that still missing...";
    local -a gems_to_be_installed=();
    for gem in "${gems[@]}";
    do
        local gem_info=;
        if [[ $(array-contains-element "${gem}" "${existing[@]}") == "true" ]]; then
            gem_info="${bldgrn} ‚úî  ${gem}${clr}\n";
        else
            gem_info="${bldred} x  ${gem}${clr}\n";
            gems_to_be_installed=(${gems_to_be_installed[@]} ${gem});
        fi;
        printf "   ${gem_info}";
    done;
    hl::subtle "It appears that only ${#gems_to_be_installed[@]} gems are left to install...";
    local -a gems_installed=();
    for gem in ${gems_to_be_installed[@]};
    do
        run "gem install -q --force --no-document $gem";
        if [[ ${LibRun__LastExitCode} -ne 0 ]]; then
            error "Gem ${gem} refuses to install." "Perhaps try installing it manually?" "${bldgrn}Action: Skip and Continuing...";
            break;
        else
            gem_installed=(${gem_installed[@]} ${gem});
            continue;
        fi;
    done;
    hr;
    echo;
    gem.clear-cache;
    success "Total of ${#gem_installed[@]} gems were successfully installed.";
    echo
}

```
### `ruby.gems.uninstall`

```
ruby.gems.uninstall ()
{
    local -a gems=($@);
    gem.clear-cache;
    [[ ${#gems[@]} -eq 0 ]] && declare -a gems=($(ruby.default-gems));
    local -a existing=($(ruby.installed-gems));
    [[ ${#gems[@]} -eq 0 ]] && {
        error "Unable to determine what gems to remove. Argument is empty, so is ${DEFAULT_RUBY_GEMS[@]}" "USAGE: ${bldgrn}ruby.gems.uninstall ${bldred} rails rubocop puma pry";
        return 1
    };
    h1::blue "There are a total of ${#existing[@]} of gems installed in a global namespace." "Total of ${#gems[@]} need to be removed.";
    local deleted=0;
    for gem in ${gems[@]};
    do
        local gem_info=;
        if [[ $(array-contains-element "${gem}" "${existing[@]}") == "true" ]]; then
            run "gem uninstall -a -x -I -D --force ${gem}";
            deleted=$(( $deleted +1 ));
        else
            gem_info="${bldred} x [not found] ${bldylw}${gem}${clr}\n";
        fi;
        printf "   ${gem_info}";
    done;
    gem.clear-cache;
    echo;
    success "Total of ${deleted} gems were successfully obliterated.";
    echo
}

```
### `ruby.init`

```
ruby.init ()
{
    h1 "Installing Critical Gems for Your Glove, Thanos...";
    ruby.rubygems-update;
    ruby.install-upgrade-bundler;
    ruby.gems.install;
    ruby.kigs-gems
}

```
### `ruby.install`

```
ruby.install ()
{
    lib::ruby::install-ruby "$@"
}

```
### `ruby.install-upgrade-bundler`

```
ruby.install-upgrade-bundler ()
{
    lib::gem::install bundler;
    run "bundle --update bundler || true"
}

```
### `ruby.installed-gems`

```
ruby.installed-gems ()
{
    gem list | cut -d ' ' -f 1 | uniq
}

```
### `ruby.kigs-gems`

```
ruby.kigs-gems ()
{
    if [[ -z $(type wd 2>/dev/null) ]]; then
        wd install --dotfile ~/.bashrc > /dev/null;
        [[ -f ~/.bash_wd ]] && source ~/.bash_wd;
    fi;
    sym -B ~/.bashrc;
    for file in .sym.completion.bash .sym.symit.bash;
    do
        [[ -f ${file} ]] && next;
        sym -B ~/.bashrc;
        break;
    done
}

```
### `ruby.linked-libs`

```
ruby.linked-libs ()
{
    ruby -r rbconfig -e "puts RbConfig::CONFIG['LIBS']"
}

```
### `ruby.numeric-version`

```
ruby.numeric-version ()
{
    /usr/bin/env ruby --version | sed 's/^ruby //g; s/ (.*//g'
}

```
### `ruby.rbenv`

```
ruby.rbenv ()
{
    if [[ -n "$*" ]]; then
        rbenv $*;
    else
        eval "$(rbenv init - )";
    fi;
    run "rbenv rehash"
}

```
### `ruby.rubygems-update`

```
ruby.rubygems-update ()
{
    info "This might take a little white, darling. Smoke a spliff, would you?";
    run "gem update --system"
}

```
### `ruby.stop`

```
ruby.stop ()
{
    local regex='/[r]uby| [p]uma| [i]rb| [r]ails | [b]undle| [u]nicorn| [r]ake';
    local procs=$(ps -ef | egrep "${regex}" | egrep -v grep | awk '{print $2}' | sort | uniq | wc -l);
    [[ ${procs} -eq 0 ]] && {
        info: "No ruby processes were found.";
        return 0
    };
    local -a pids=$(ps -ef | egrep "${regex}" | egrep -v grep | awk '{print $2}' | sort | uniq | tr '\n' ' -p ');
    h2 "Detected ${#pids[@]} Ruby Processes..., here is the tree:";
    printf "${txtcyn}";
    pstree ${pids[*]};
    printf "${clr}";
    hr;
    printf "To abort, press Ctrl-C. To kill them all press any key..";
    press-any-key-to-continue;
    ps -ef | egrep "${regex}" | egrep -v grep | awk '{print $2}' | sort | uniq | xargs kill -9
}

```
### `ruby.top-versions`

```
ruby.top-versions ()
{
    local platform="${1:-"2\."}";
    rbenv install --list | egrep "^${platform}" | ruby -e '
      last_v = nil;
      last_m = nil;
      ARGF.each do |line|
        v = line.split(".")[0..1].join(".")
        if last_v != v
          puts last_m if last_m
          last_v = v;
        end;
        last_m = line
      end
      puts last_m if last_m'
}

```
### `ruby.top-versions-as-yaml`

```
ruby.top-versions-as-yaml ()
{
    ruby.top-versions | sed 's/^/ - /g'
}

```
### `run`

```
run ()
{
    __lib::run $@;
    return ${LibRun__LastExitCode}
}

```
### `run::inspect`

```
run::inspect ()
{
    lib::run::inspect
}

```
### `run::set-all`

```
run::set-all ()
{
    ____run::configure all "$@"
}

```
### `run::set-all::list`

```
run::set-all::list ()
{
    set | egrep '^____run::set::all' | awk 'BEGIN{FS="::"}{print $4}' | hbsed 's/[() ]//g'
}

```
### `run::set-next`

```
run::set-next ()
{
    ____run::configure next "$@"
}

```
### `run::set-next::list`

```
run::set-next::list ()
{
    set | egrep '^____run::set::next' | awk 'BEGIN{FS="::"}{print $4}' | hbsed 's/[() ]//g'
}

```
### `save-restore-x`

```
save-restore-x ()
{
    shell-set::pop-stack x
}

```
### `save-set-x`

```
save-set-x ()
{
    shell-set::push-stack x
}

```
### `screen-width`

```
screen-width ()
{
    __lib::output::screen-width
}

```
### `screen.height`

```
screen.height ()
{
    __lib::output::screen-height
}

```
### `screen.width`

```
screen.width ()
{
    __lib::output::screen-width
}

```
### `set-e-restore`

```
set-e-restore ()
{
    [[ -f ${__bash_set_errexit_status} ]] && {
        error "You must first save it with the function:s ${bldgrn}set-e-save";
        return 1
    };
    local status=$(cat ${__bash_set_errexit_status} | tr -d '\n');
    if [[ ${status} != 'on' && ${status} != 'off' ]]; then
        error "Invalid data in the set -e tempfile:" "$(cat ${__bash_set_errexit_status})";
        return 1;
    fi;
    set -o errexit ${status};
    rm -f ${__bash_set_errexit_status} 2> /dev/null
}

```
### `set-e-save`

```
set-e-save ()
{
    export __bash_set_errexit_status=$(mktemp -t 'errexit');
    rm -f ${__bash_set_errexit_status} 2> /dev/null;
    set-e-status > ${__bash_set_errexit_status}
}

```
### `set-e-status`

```
set-e-status ()
{
    set -o | grep errexit | awk '{print $2}'
}

```
### `shell-set::init-stack`

```
shell-set::init-stack ()
{
    unset SetOptsStack;
    declare -a SetOptsStack=();
    export SetOptsStack
}

```
### `shell-set::is-set`

```
shell-set::is-set ()
{
    local v="$1";
    local is_set=${-//[^${v}]/};
    if [[ -n ${is_set} ]]; then
        return 0;
    else
        return 1;
    fi
}

```
### `shell-set::pop-stack`

```
shell-set::pop-stack ()
{
    local value="$1";
    local len=${#SetOptsStack[@]};
    local last_index=$(( len - 1 ));
    local last=${SetOptsStack[${last_index}]};
    if [[ ${last} != "-${value}" && ${last} != "+${value}" ]]; then
        error "Can not restore ${value}, not the last element in ${SetOptsStack[*]} stack.";
        return 1;
    fi;
    local pop=(${last});
    export SetOptsStack=("${SetOptsStack[@]/$pop}");
    [[ -n ${DEBUG} ]] && shell-set-show;
    eval "set ${last}"
}

```
### `shell-set::push-stack`

```
shell-set::push-stack ()
{
    local value="$1";
    local is_set=${-//[^${value}]/};
    shell-set::is-set ${value} && export SetOptsStack=(${SetOptsStack[@]} "-${value}");
    shell-set::is-set ${value} || export SetOptsStack=(${SetOptsStack[@]} "+${value}");
    [[ -n ${DEBUG} ]] && shell-set-show
}

```
### `shell-set::show-stack`

```
shell-set::show-stack ()
{
    info "Current Shell Set Stack: ${bldylw}[${SetOptsStack[*]}]"
}

```
### `short-pause`

```
short-pause ()
{
    sleep "${1:-0.1}"
}

```
### `shortish-pause`

```
shortish-pause ()
{
    sleep "${1:-0.3}"
}

```
### `shutdown`

```
shutdown ()
{
    local message=${1:-"Shutting down..."};
    echo;
    box::red-in-red "${message}";
    echo;
    exit 1
}

```
### `sig::is-valid`

```
sig::is-valid ()
{
    [[ -n $(kill -l ${1} 2>/dev/null) ]]
}

```
### `sig::list`

```
sig::list ()
{
    /bin/kill -l | sed -E 's/([ 0-9][0-9]\) SIG)//g; s/\s+/\n/g' | tr 'a-z' 'A-Z' | sort
}

```
### `stderr`

```
stderr ()
{
    local file=$1;
    hl::subtle STDERR;
    printf "${txtred}";
    [[ -s ${file} ]] && cat ${file};
    reset-color
}

```
### `stdout`

```
stdout ()
{
    local file=$1;
    hl::subtle STDOUT;
    printf "${clr}";
    [[ -s ${file} ]] && cat ${file};
    reset-color
}

```
### `strikethrough`

```
strikethrough ()
{
    ansi 9 "$@"
}

```
### `success`

```
success ()
{
    echo;
    printf -- "${LibOutput__LeftPrefix}${txtblk}${bakgrn}  ¬´ SUCCESS ¬ª  ${clr} ${bldwht} ‚úî  ${bldgrn}$*${clr}" 1>&2;
    echo;
    echo
}

```
### `sym::hb::configure`

```
sym::hb::configure ()
{
    export SYMIT__KEY="APP_SYM_KEY"
}

```
### `sym::hb::files`

```
sym::hb::files ()
{
    find . -name '*.enc' -type f
}

```
### `sym::hb::have_key`

```
sym::hb::have_key ()
{
    sym::hb::configure;
    if [[ -z ${CI} ]]; then
        [[ -z "$(keychain ${SYMIT__KEY} find 2>/dev/null)" ]] || printf "yes";
    else
        [[ -n "${APP_SYM_KEY}" ]] && print "yes";
    fi
}

```
### `sym::hb::import`

```
sym::hb::import ()
{
    local skip_instructions=${1:-0};
    if [[ ${AppCurrentOS} != 'Darwin' ]]; then
        error 'This is only meant to run on Mac OS-X';
        return;
    fi;
    sym::hb::configure;
    sym::install::symit;
    [[ -f ~/.sym.symit.bash ]] && source ~/.sym.symit.bash;
    h2 'Encryption Key Import';
    info "Checking for the existence of the current key...";
    if [[ -n "$(sym::hb::have_key)" ]]; then
        info: "Key ${SYMIT_KEY} is already in you your OS-X Key Chain.";
        lib::run::ask "Would you like to re-import it?";
        [[ $? != 0 ]] && return;
    fi;
    if [[ ${skip_instructions} == ${false} ]]; then
        hr;
        echo;
        info "1. Please open 1Password App and search for 'Encryption Key'";
        echo;
        info "2. Once you find the entry, it will contain two items: encryption key";
        info "      and password. Start by copying the key to the clipboard.";
        echo;
        info "3. You will need to paste the key first, and then copy/paste";
        info "      the key password (also in 1Password)";
        echo;
        info "4. As a final setup, you will be asked to create a new password.";
        info "      It must be at least 7 characters long, and will be used to encrypt";
        info "      the key locally on your machine.";
        echo;
        echo;
        lib::run::ask "Ready?";
        [[ $? != 0 ]] && return;
    fi;
    echo;
    hr;
    sym -iqpx APP_SYM_KEY;
    code=$?;
    [[ ${code} != 0 ]] && {
        error "Sym exited with error code ${code}";
        return ${code}
    };
    hr;
    echo;
    info "Key import was successful, great job! ${bldylw}‚ò∫ ";
    info "You can test that it works by encrypting, and decrypting a string,";
    echo;
    info "\$ ${bldylw}source bin/lib.bash";
    info "\$ ${bldylw}hb::encrypt::str hello";
    info "\$ ${bldylw}hb::decrypt::str \$(hb::encrypt::str hello )";
    echo;
    info "Or a file:";
    info "\$ ${bldylw}hb::decrypt::file config/application.dev.yml.enc";
    echo;
    info "You can edit the file as if it wasn't encrypted:";
    info "\$ ${bldylw}hb::edit::file config/application.dev.yml.enc";
    echo
}

```
### `sym::hb::install-shell-helpers`

```
sym::hb::install-shell-helpers ()
{
    local found=;
    declare -a init_files=($(lib::util::shell-init-files));
    for file in ${init_files[@]};
    do
        f=${HOME}/${file};
        [[ ! -f "${f}" ]] && continue;
        [[ -n $(grep sym.symit ${f}) ]] && {
            found=${f};
            break
        };
    done;
    if [[ -z ${found} ]]; then
        for file in ${init_files[@]};
        do
            f="${HOME}/${file}";
            if [[ -f "${f}" ]]; then
                run "sym -B ${f} 1>/dev/null";
                return $?;
            fi;
        done;
    else
        run "sym -B ${found} 1>/dev/null";
    fi
}

```
### `sym::install::symit`

```
sym::install::symit ()
{
    if [[ ! -f config.ru ]]; then
        error "Please run this command from the RAILS_ROOT folder";
        return 1;
    fi;
    [[ -n "$(which sym 2>/dev/null)" && -f ~/.sym.symit.bash ]] && return;
    local symit_source="/tmp/sym.symit.bash.$$";
    trap "rm -f ${symit__source}; " EXIT;
    local symit_url="https://raw.githubusercontent.com/kigster/sym/master/bin/sym.symit.bash";
    local cmd="curl -fsSL ${symit_url} -o ${symit_source}";
    export LibRun__AbortOnError=${True};
    run "${cmd}";
    if [[ ! -f ${symit_source} ]]; then
        err "unable to find downloaded file ${symit_source}";
        return 1;
    fi;
    source ${symit_source};
    rm -f ${symit_source};
    run "symit install";
    sym::hb::install-shell-helpers
}

```
### `test-group`

```
test-group ()
{
    [[ -z ${white_on_salmon} ]] && hr;
    hl::white-on-salmon "$@"
}

```
### `today`

```
today ()
{
    date +'%Y-%m-%d'
}

```
### `txt-err`

```
txt-err ()
{
    printf "${clr}${bldylw}${bakred}"
}

```
### `txt-info`

```
txt-info ()
{
    printf "${clr}${txtblu}"
}

```
### `txt-warn`

```
txt-warn ()
{
    printf "${clr}${bldylw}"
}

```
### `underline`

```
underline ()
{
    ansi 4 "$@"
}

```
### `warn`

```
warn ()
{
    printf -- "${LibOutput__LeftPrefix}${bldwht}${bakylw} ¬´ WARNING! ¬ª ${clr} ${bldylw}$*${clr}" 1>&2
}

```
### `warning`

```
warning ()
{
    header=$(printf -- "${txtblk}${bakylw} ¬´ WARNING ¬ª ${clr}");
    box::yellow-in-yellow "${header} ${bldylw}$*" 1>&2
}

```
### `warning:`

```
warning: ()
{
    warn $*;
    kind_of_ok:
}

```
### `watch-ls-al`

```
watch-ls-al ()
{
    while true; do
        ls -al;
        sleep 0.3;
        clear;
    done
}

```
### `with-bundle-exec`

```
with-bundle-exec ()
{
    __lib::run::bundle::exec "$@"
}

```
### `with-bundle-exec-and-output`

```
with-bundle-exec-and-output ()
{
    __lib::run::bundle::exec::with-output "$@"
}

```
### `with-min-duration`

```
with-min-duration ()
{
    lib::run::with-min-duration "$@"
}

```
### `yaml-diff`

```
yaml-diff ()
{
    lib::yaml::diff "$@"
}

```
### `yaml-dump`

```
yaml-dump ()
{
    lib::yaml::dump "$@"
}

```
### `√¶-wav2mp3`

```
√¶-wav2mp3 ()
{
    lib::audio::wav-to-mp3 "$@"
}

```
### `√¶-wavfreq`

```
√¶-wavfreq ()
{
    [[ -f ${1} ]] || {
        error "File ${1} does not exist.";
        return 1
    };
    lib::audio::wave-file-frequency "$@";
    echo " kHz"
}

```
